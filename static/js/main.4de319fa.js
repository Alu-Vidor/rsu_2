/*! For license information please see main.4de319fa.js.LICENSE.txt */
(()=>{var e={353:e=>{e.exports=n;var t=null;try{t=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(C){}function n(e,t,n){this.low=0|e,this.high=0|t,this.unsigned=!!n}function s(e){return!0===(e&&e.__isLong__)}n.prototype.__isLong__,Object.defineProperty(n.prototype,"__isLong__",{value:!0}),n.isLong=s;var r={},i={};function a(e,t){var n,s,a;return t?(a=0<=(e>>>=0)&&e<256)&&(s=i[e])?s:(n=l(e,(0|e)<0?-1:0,!0),a&&(i[e]=n),n):(a=-128<=(e|=0)&&e<128)&&(s=r[e])?s:(n=l(e,e<0?-1:0,!1),a&&(r[e]=n),n)}function o(e,t){if(isNaN(e))return t?b:m;if(t){if(e<0)return b;if(e>=p)return k}else{if(e<=-f)return S;if(e+1>=f)return w}return e<0?o(-e,t).neg():l(e%d|0,e/d|0,t)}function l(e,t,s){return new n(e,t,s)}n.fromInt=a,n.fromNumber=o,n.fromBits=l;var u=Math.pow;function c(e,t,n){if(0===e.length)throw Error("empty string");if("NaN"===e||"Infinity"===e||"+Infinity"===e||"-Infinity"===e)return m;if("number"===typeof t?(n=t,t=!1):t=!!t,(n=n||10)<2||36<n)throw RangeError("radix");var s;if((s=e.indexOf("-"))>0)throw Error("interior hyphen");if(0===s)return c(e.substring(1),t,n).neg();for(var r=o(u(n,8)),i=m,a=0;a<e.length;a+=8){var l=Math.min(8,e.length-a),h=parseInt(e.substring(a,a+l),n);if(l<8){var d=o(u(n,l));i=i.mul(d).add(o(h))}else i=(i=i.mul(r)).add(o(h))}return i.unsigned=t,i}function h(e,t){return"number"===typeof e?o(e,t):"string"===typeof e?c(e,t):l(e.low,e.high,"boolean"===typeof t?t:e.unsigned)}n.fromString=c,n.fromValue=h;var d=4294967296,p=d*d,f=p/2,g=a(1<<24),m=a(0);n.ZERO=m;var b=a(0,!0);n.UZERO=b;var x=a(1);n.ONE=x;var y=a(1,!0);n.UONE=y;var v=a(-1);n.NEG_ONE=v;var w=l(-1,2147483647,!1);n.MAX_VALUE=w;var k=l(-1,-1,!0);n.MAX_UNSIGNED_VALUE=k;var S=l(0,-2147483648,!1);n.MIN_VALUE=S;var I=n.prototype;I.toInt=function(){return this.unsigned?this.low>>>0:this.low},I.toNumber=function(){return this.unsigned?(this.high>>>0)*d+(this.low>>>0):this.high*d+(this.low>>>0)},I.toString=function(e){if((e=e||10)<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(S)){var t=o(e),n=this.div(t),s=n.mul(t).sub(this);return n.toString(e)+s.toInt().toString(e)}return"-"+this.neg().toString(e)}for(var r=o(u(e,6),this.unsigned),i=this,a="";;){var l=i.div(r),c=(i.sub(l.mul(r)).toInt()>>>0).toString(e);if((i=l).isZero())return c+a;for(;c.length<6;)c="0"+c;a=""+c+a}},I.getHighBits=function(){return this.high},I.getHighBitsUnsigned=function(){return this.high>>>0},I.getLowBits=function(){return this.low},I.getLowBitsUnsigned=function(){return this.low>>>0},I.getNumBitsAbs=function(){if(this.isNegative())return this.eq(S)?64:this.neg().getNumBitsAbs();for(var e=0!=this.high?this.high:this.low,t=31;t>0&&0==(e&1<<t);t--);return 0!=this.high?t+33:t+1},I.isZero=function(){return 0===this.high&&0===this.low},I.eqz=I.isZero,I.isNegative=function(){return!this.unsigned&&this.high<0},I.isPositive=function(){return this.unsigned||this.high>=0},I.isOdd=function(){return 1===(1&this.low)},I.isEven=function(){return 0===(1&this.low)},I.equals=function(e){return s(e)||(e=h(e)),(this.unsigned===e.unsigned||this.high>>>31!==1||e.high>>>31!==1)&&(this.high===e.high&&this.low===e.low)},I.eq=I.equals,I.notEquals=function(e){return!this.eq(e)},I.neq=I.notEquals,I.ne=I.notEquals,I.lessThan=function(e){return this.comp(e)<0},I.lt=I.lessThan,I.lessThanOrEqual=function(e){return this.comp(e)<=0},I.lte=I.lessThanOrEqual,I.le=I.lessThanOrEqual,I.greaterThan=function(e){return this.comp(e)>0},I.gt=I.greaterThan,I.greaterThanOrEqual=function(e){return this.comp(e)>=0},I.gte=I.greaterThanOrEqual,I.ge=I.greaterThanOrEqual,I.compare=function(e){if(s(e)||(e=h(e)),this.eq(e))return 0;var t=this.isNegative(),n=e.isNegative();return t&&!n?-1:!t&&n?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},I.comp=I.compare,I.negate=function(){return!this.unsigned&&this.eq(S)?S:this.not().add(x)},I.neg=I.negate,I.add=function(e){s(e)||(e=h(e));var t=this.high>>>16,n=65535&this.high,r=this.low>>>16,i=65535&this.low,a=e.high>>>16,o=65535&e.high,u=e.low>>>16,c=0,d=0,p=0,f=0;return p+=(f+=i+(65535&e.low))>>>16,d+=(p+=r+u)>>>16,c+=(d+=n+o)>>>16,c+=t+a,l((p&=65535)<<16|(f&=65535),(c&=65535)<<16|(d&=65535),this.unsigned)},I.subtract=function(e){return s(e)||(e=h(e)),this.add(e.neg())},I.sub=I.subtract,I.multiply=function(e){if(this.isZero())return m;if(s(e)||(e=h(e)),t)return l(t.mul(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned);if(e.isZero())return m;if(this.eq(S))return e.isOdd()?S:m;if(e.eq(S))return this.isOdd()?S:m;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(g)&&e.lt(g))return o(this.toNumber()*e.toNumber(),this.unsigned);var n=this.high>>>16,r=65535&this.high,i=this.low>>>16,a=65535&this.low,u=e.high>>>16,c=65535&e.high,d=e.low>>>16,p=65535&e.low,f=0,b=0,x=0,y=0;return x+=(y+=a*p)>>>16,b+=(x+=i*p)>>>16,x&=65535,b+=(x+=a*d)>>>16,f+=(b+=r*p)>>>16,b&=65535,f+=(b+=i*d)>>>16,b&=65535,f+=(b+=a*c)>>>16,f+=n*p+r*d+i*c+a*u,l((x&=65535)<<16|(y&=65535),(f&=65535)<<16|(b&=65535),this.unsigned)},I.mul=I.multiply,I.divide=function(e){if(s(e)||(e=h(e)),e.isZero())throw Error("division by zero");var n,r,i;if(t)return this.unsigned||-2147483648!==this.high||-1!==e.low||-1!==e.high?l((this.unsigned?t.div_u:t.div_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?b:m;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return b;if(e.gt(this.shru(1)))return y;i=b}else{if(this.eq(S))return e.eq(x)||e.eq(v)?S:e.eq(S)?x:(n=this.shr(1).div(e).shl(1)).eq(m)?e.isNegative()?x:v:(r=this.sub(e.mul(n)),i=n.add(r.div(e)));if(e.eq(S))return this.unsigned?b:m;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();i=m}for(r=this;r.gte(e);){n=Math.max(1,Math.floor(r.toNumber()/e.toNumber()));for(var a=Math.ceil(Math.log(n)/Math.LN2),c=a<=48?1:u(2,a-48),d=o(n),p=d.mul(e);p.isNegative()||p.gt(r);)p=(d=o(n-=c,this.unsigned)).mul(e);d.isZero()&&(d=x),i=i.add(d),r=r.sub(p)}return i},I.div=I.divide,I.modulo=function(e){return s(e)||(e=h(e)),t?l((this.unsigned?t.rem_u:t.rem_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this.sub(this.div(e).mul(e))},I.mod=I.modulo,I.rem=I.modulo,I.not=function(){return l(~this.low,~this.high,this.unsigned)},I.and=function(e){return s(e)||(e=h(e)),l(this.low&e.low,this.high&e.high,this.unsigned)},I.or=function(e){return s(e)||(e=h(e)),l(this.low|e.low,this.high|e.high,this.unsigned)},I.xor=function(e){return s(e)||(e=h(e)),l(this.low^e.low,this.high^e.high,this.unsigned)},I.shiftLeft=function(e){return s(e)&&(e=e.toInt()),0===(e&=63)?this:e<32?l(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):l(0,this.low<<e-32,this.unsigned)},I.shl=I.shiftLeft,I.shiftRight=function(e){return s(e)&&(e=e.toInt()),0===(e&=63)?this:e<32?l(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):l(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},I.shr=I.shiftRight,I.shiftRightUnsigned=function(e){if(s(e)&&(e=e.toInt()),0===(e&=63))return this;var t=this.high;return e<32?l(this.low>>>e|t<<32-e,t>>>e,this.unsigned):l(32===e?t:t>>>e-32,0,this.unsigned)},I.shru=I.shiftRightUnsigned,I.shr_u=I.shiftRightUnsigned,I.toSigned=function(){return this.unsigned?l(this.low,this.high,!1):this},I.toUnsigned=function(){return this.unsigned?this:l(this.low,this.high,!0)},I.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},I.toBytesLE=function(){var e=this.high,t=this.low;return[255&t,t>>>8&255,t>>>16&255,t>>>24,255&e,e>>>8&255,e>>>16&255,e>>>24]},I.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,255&e,t>>>24,t>>>16&255,t>>>8&255,255&t]},n.fromBytes=function(e,t,s){return s?n.fromBytesLE(e,t):n.fromBytesBE(e,t)},n.fromBytesLE=function(e,t){return new n(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)},n.fromBytesBE=function(e,t){return new n(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}},730:(e,t,n)=>{"use strict";var s=n(43),r=n(853);function i(e){for(var t="https://reactjs.org/docs/error-decoder.html?invariant="+e,n=1;n<arguments.length;n++)t+="&args[]="+encodeURIComponent(arguments[n]);return"Minified React error #"+e+"; visit "+t+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var a=new Set,o={};function l(e,t){u(e,t),u(e+"Capture",t)}function u(e,t){for(o[e]=t,e=0;e<t.length;e++)a.add(t[e])}var c=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),h=Object.prototype.hasOwnProperty,d=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,p={},f={};function g(e,t,n,s,r,i,a){this.acceptsBooleans=2===t||3===t||4===t,this.attributeName=s,this.attributeNamespace=r,this.mustUseProperty=n,this.propertyName=e,this.type=t,this.sanitizeURL=i,this.removeEmptyString=a}var m={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach((function(e){m[e]=new g(e,0,!1,e,null,!1,!1)})),[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach((function(e){var t=e[0];m[t]=new g(t,1,!1,e[1],null,!1,!1)})),["contentEditable","draggable","spellCheck","value"].forEach((function(e){m[e]=new g(e,2,!1,e.toLowerCase(),null,!1,!1)})),["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach((function(e){m[e]=new g(e,2,!1,e,null,!1,!1)})),"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach((function(e){m[e]=new g(e,3,!1,e.toLowerCase(),null,!1,!1)})),["checked","multiple","muted","selected"].forEach((function(e){m[e]=new g(e,3,!0,e,null,!1,!1)})),["capture","download"].forEach((function(e){m[e]=new g(e,4,!1,e,null,!1,!1)})),["cols","rows","size","span"].forEach((function(e){m[e]=new g(e,6,!1,e,null,!1,!1)})),["rowSpan","start"].forEach((function(e){m[e]=new g(e,5,!1,e.toLowerCase(),null,!1,!1)}));var b=/[\-:]([a-z])/g;function x(e){return e[1].toUpperCase()}function y(e,t,n,s){var r=m.hasOwnProperty(t)?m[t]:null;(null!==r?0!==r.type:s||!(2<t.length)||"o"!==t[0]&&"O"!==t[0]||"n"!==t[1]&&"N"!==t[1])&&(function(e,t,n,s){if(null===t||"undefined"===typeof t||function(e,t,n,s){if(null!==n&&0===n.type)return!1;switch(typeof t){case"function":case"symbol":return!0;case"boolean":return!s&&(null!==n?!n.acceptsBooleans:"data-"!==(e=e.toLowerCase().slice(0,5))&&"aria-"!==e);default:return!1}}(e,t,n,s))return!0;if(s)return!1;if(null!==n)switch(n.type){case 3:return!t;case 4:return!1===t;case 5:return isNaN(t);case 6:return isNaN(t)||1>t}return!1}(t,n,r,s)&&(n=null),s||null===r?function(e){return!!h.call(f,e)||!h.call(p,e)&&(d.test(e)?f[e]=!0:(p[e]=!0,!1))}(t)&&(null===n?e.removeAttribute(t):e.setAttribute(t,""+n)):r.mustUseProperty?e[r.propertyName]=null===n?3!==r.type&&"":n:(t=r.attributeName,s=r.attributeNamespace,null===n?e.removeAttribute(t):(n=3===(r=r.type)||4===r&&!0===n?"":""+n,s?e.setAttributeNS(s,t,n):e.setAttribute(t,n))))}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach((function(e){var t=e.replace(b,x);m[t]=new g(t,1,!1,e,null,!1,!1)})),"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach((function(e){var t=e.replace(b,x);m[t]=new g(t,1,!1,e,"http://www.w3.org/1999/xlink",!1,!1)})),["xml:base","xml:lang","xml:space"].forEach((function(e){var t=e.replace(b,x);m[t]=new g(t,1,!1,e,"http://www.w3.org/XML/1998/namespace",!1,!1)})),["tabIndex","crossOrigin"].forEach((function(e){m[e]=new g(e,1,!1,e.toLowerCase(),null,!1,!1)})),m.xlinkHref=new g("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1),["src","href","action","formAction"].forEach((function(e){m[e]=new g(e,1,!1,e.toLowerCase(),null,!0,!0)}));var v=s.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,w=Symbol.for("react.element"),k=Symbol.for("react.portal"),S=Symbol.for("react.fragment"),I=Symbol.for("react.strict_mode"),C=Symbol.for("react.profiler"),N=Symbol.for("react.provider"),T=Symbol.for("react.context"),_=Symbol.for("react.forward_ref"),E=Symbol.for("react.suspense"),$=Symbol.for("react.suspense_list"),R=Symbol.for("react.memo"),A=Symbol.for("react.lazy");Symbol.for("react.scope"),Symbol.for("react.debug_trace_mode");var D=Symbol.for("react.offscreen");Symbol.for("react.legacy_hidden"),Symbol.for("react.cache"),Symbol.for("react.tracing_marker");var F=Symbol.iterator;function M(e){return null===e||"object"!==typeof e?null:"function"===typeof(e=F&&e[F]||e["@@iterator"])?e:null}var O,L=Object.assign;function P(e){if(void 0===O)try{throw Error()}catch(n){var t=n.stack.trim().match(/\n( *(at )?)/);O=t&&t[1]||""}return"\n"+O+e}var z=!1;function B(e,t){if(!e||z)return"";z=!0;var n=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(t)if(t=function(){throw Error()},Object.defineProperty(t.prototype,"props",{set:function(){throw Error()}}),"object"===typeof Reflect&&Reflect.construct){try{Reflect.construct(t,[])}catch(u){var s=u}Reflect.construct(e,[],t)}else{try{t.call()}catch(u){s=u}e.call(t.prototype)}else{try{throw Error()}catch(u){s=u}e()}}catch(u){if(u&&s&&"string"===typeof u.stack){for(var r=u.stack.split("\n"),i=s.stack.split("\n"),a=r.length-1,o=i.length-1;1<=a&&0<=o&&r[a]!==i[o];)o--;for(;1<=a&&0<=o;a--,o--)if(r[a]!==i[o]){if(1!==a||1!==o)do{if(a--,0>--o||r[a]!==i[o]){var l="\n"+r[a].replace(" at new "," at ");return e.displayName&&l.includes("<anonymous>")&&(l=l.replace("<anonymous>",e.displayName)),l}}while(1<=a&&0<=o);break}}}finally{z=!1,Error.prepareStackTrace=n}return(e=e?e.displayName||e.name:"")?P(e):""}function W(e){switch(e.tag){case 5:return P(e.type);case 16:return P("Lazy");case 13:return P("Suspense");case 19:return P("SuspenseList");case 0:case 2:case 15:return e=B(e.type,!1);case 11:return e=B(e.type.render,!1);case 1:return e=B(e.type,!0);default:return""}}function V(e){if(null==e)return null;if("function"===typeof e)return e.displayName||e.name||null;if("string"===typeof e)return e;switch(e){case S:return"Fragment";case k:return"Portal";case C:return"Profiler";case I:return"StrictMode";case E:return"Suspense";case $:return"SuspenseList"}if("object"===typeof e)switch(e.$$typeof){case T:return(e.displayName||"Context")+".Consumer";case N:return(e._context.displayName||"Context")+".Provider";case _:var t=e.render;return(e=e.displayName)||(e=""!==(e=t.displayName||t.name||"")?"ForwardRef("+e+")":"ForwardRef"),e;case R:return null!==(t=e.displayName||null)?t:V(e.type)||"Memo";case A:t=e._payload,e=e._init;try{return V(e(t))}catch(n){}}return null}function U(e){var t=e.type;switch(e.tag){case 24:return"Cache";case 9:return(t.displayName||"Context")+".Consumer";case 10:return(t._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return e=(e=t.render).displayName||e.name||"",t.displayName||(""!==e?"ForwardRef("+e+")":"ForwardRef");case 7:return"Fragment";case 5:return t;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return V(t);case 8:return t===I?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if("function"===typeof t)return t.displayName||t.name||null;if("string"===typeof t)return t}return null}function G(e){switch(typeof e){case"boolean":case"number":case"string":case"undefined":case"object":return e;default:return""}}function H(e){var t=e.type;return(e=e.nodeName)&&"input"===e.toLowerCase()&&("checkbox"===t||"radio"===t)}function j(e){e._valueTracker||(e._valueTracker=function(e){var t=H(e)?"checked":"value",n=Object.getOwnPropertyDescriptor(e.constructor.prototype,t),s=""+e[t];if(!e.hasOwnProperty(t)&&"undefined"!==typeof n&&"function"===typeof n.get&&"function"===typeof n.set){var r=n.get,i=n.set;return Object.defineProperty(e,t,{configurable:!0,get:function(){return r.call(this)},set:function(e){s=""+e,i.call(this,e)}}),Object.defineProperty(e,t,{enumerable:n.enumerable}),{getValue:function(){return s},setValue:function(e){s=""+e},stopTracking:function(){e._valueTracker=null,delete e[t]}}}}(e))}function K(e){if(!e)return!1;var t=e._valueTracker;if(!t)return!0;var n=t.getValue(),s="";return e&&(s=H(e)?e.checked?"true":"false":e.value),(e=s)!==n&&(t.setValue(e),!0)}function X(e){if("undefined"===typeof(e=e||("undefined"!==typeof document?document:void 0)))return null;try{return e.activeElement||e.body}catch(t){return e.body}}function q(e,t){var n=t.checked;return L({},t,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=n?n:e._wrapperState.initialChecked})}function Y(e,t){var n=null==t.defaultValue?"":t.defaultValue,s=null!=t.checked?t.checked:t.defaultChecked;n=G(null!=t.value?t.value:n),e._wrapperState={initialChecked:s,initialValue:n,controlled:"checkbox"===t.type||"radio"===t.type?null!=t.checked:null!=t.value}}function Q(e,t){null!=(t=t.checked)&&y(e,"checked",t,!1)}function Z(e,t){Q(e,t);var n=G(t.value),s=t.type;if(null!=n)"number"===s?(0===n&&""===e.value||e.value!=n)&&(e.value=""+n):e.value!==""+n&&(e.value=""+n);else if("submit"===s||"reset"===s)return void e.removeAttribute("value");t.hasOwnProperty("value")?ee(e,t.type,n):t.hasOwnProperty("defaultValue")&&ee(e,t.type,G(t.defaultValue)),null==t.checked&&null!=t.defaultChecked&&(e.defaultChecked=!!t.defaultChecked)}function J(e,t,n){if(t.hasOwnProperty("value")||t.hasOwnProperty("defaultValue")){var s=t.type;if(!("submit"!==s&&"reset"!==s||void 0!==t.value&&null!==t.value))return;t=""+e._wrapperState.initialValue,n||t===e.value||(e.value=t),e.defaultValue=t}""!==(n=e.name)&&(e.name=""),e.defaultChecked=!!e._wrapperState.initialChecked,""!==n&&(e.name=n)}function ee(e,t,n){"number"===t&&X(e.ownerDocument)===e||(null==n?e.defaultValue=""+e._wrapperState.initialValue:e.defaultValue!==""+n&&(e.defaultValue=""+n))}var te=Array.isArray;function ne(e,t,n,s){if(e=e.options,t){t={};for(var r=0;r<n.length;r++)t["$"+n[r]]=!0;for(n=0;n<e.length;n++)r=t.hasOwnProperty("$"+e[n].value),e[n].selected!==r&&(e[n].selected=r),r&&s&&(e[n].defaultSelected=!0)}else{for(n=""+G(n),t=null,r=0;r<e.length;r++){if(e[r].value===n)return e[r].selected=!0,void(s&&(e[r].defaultSelected=!0));null!==t||e[r].disabled||(t=e[r])}null!==t&&(t.selected=!0)}}function se(e,t){if(null!=t.dangerouslySetInnerHTML)throw Error(i(91));return L({},t,{value:void 0,defaultValue:void 0,children:""+e._wrapperState.initialValue})}function re(e,t){var n=t.value;if(null==n){if(n=t.children,t=t.defaultValue,null!=n){if(null!=t)throw Error(i(92));if(te(n)){if(1<n.length)throw Error(i(93));n=n[0]}t=n}null==t&&(t=""),n=t}e._wrapperState={initialValue:G(n)}}function ie(e,t){var n=G(t.value),s=G(t.defaultValue);null!=n&&((n=""+n)!==e.value&&(e.value=n),null==t.defaultValue&&e.defaultValue!==n&&(e.defaultValue=n)),null!=s&&(e.defaultValue=""+s)}function ae(e){var t=e.textContent;t===e._wrapperState.initialValue&&""!==t&&null!==t&&(e.value=t)}function oe(e){switch(e){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function le(e,t){return null==e||"http://www.w3.org/1999/xhtml"===e?oe(t):"http://www.w3.org/2000/svg"===e&&"foreignObject"===t?"http://www.w3.org/1999/xhtml":e}var ue,ce,he=(ce=function(e,t){if("http://www.w3.org/2000/svg"!==e.namespaceURI||"innerHTML"in e)e.innerHTML=t;else{for((ue=ue||document.createElement("div")).innerHTML="<svg>"+t.valueOf().toString()+"</svg>",t=ue.firstChild;e.firstChild;)e.removeChild(e.firstChild);for(;t.firstChild;)e.appendChild(t.firstChild)}},"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(e,t,n,s){MSApp.execUnsafeLocalFunction((function(){return ce(e,t)}))}:ce);function de(e,t){if(t){var n=e.firstChild;if(n&&n===e.lastChild&&3===n.nodeType)return void(n.nodeValue=t)}e.textContent=t}var pe={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},fe=["Webkit","ms","Moz","O"];function ge(e,t,n){return null==t||"boolean"===typeof t||""===t?"":n||"number"!==typeof t||0===t||pe.hasOwnProperty(e)&&pe[e]?(""+t).trim():t+"px"}function me(e,t){for(var n in e=e.style,t)if(t.hasOwnProperty(n)){var s=0===n.indexOf("--"),r=ge(n,t[n],s);"float"===n&&(n="cssFloat"),s?e.setProperty(n,r):e[n]=r}}Object.keys(pe).forEach((function(e){fe.forEach((function(t){t=t+e.charAt(0).toUpperCase()+e.substring(1),pe[t]=pe[e]}))}));var be=L({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function xe(e,t){if(t){if(be[e]&&(null!=t.children||null!=t.dangerouslySetInnerHTML))throw Error(i(137,e));if(null!=t.dangerouslySetInnerHTML){if(null!=t.children)throw Error(i(60));if("object"!==typeof t.dangerouslySetInnerHTML||!("__html"in t.dangerouslySetInnerHTML))throw Error(i(61))}if(null!=t.style&&"object"!==typeof t.style)throw Error(i(62))}}function ye(e,t){if(-1===e.indexOf("-"))return"string"===typeof t.is;switch(e){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var ve=null;function we(e){return(e=e.target||e.srcElement||window).correspondingUseElement&&(e=e.correspondingUseElement),3===e.nodeType?e.parentNode:e}var ke=null,Se=null,Ie=null;function Ce(e){if(e=yr(e)){if("function"!==typeof ke)throw Error(i(280));var t=e.stateNode;t&&(t=wr(t),ke(e.stateNode,e.type,t))}}function Ne(e){Se?Ie?Ie.push(e):Ie=[e]:Se=e}function Te(){if(Se){var e=Se,t=Ie;if(Ie=Se=null,Ce(e),t)for(e=0;e<t.length;e++)Ce(t[e])}}function _e(e,t){return e(t)}function Ee(){}var $e=!1;function Re(e,t,n){if($e)return e(t,n);$e=!0;try{return _e(e,t,n)}finally{$e=!1,(null!==Se||null!==Ie)&&(Ee(),Te())}}function Ae(e,t){var n=e.stateNode;if(null===n)return null;var s=wr(n);if(null===s)return null;n=s[t];e:switch(t){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(s=!s.disabled)||(s=!("button"===(e=e.type)||"input"===e||"select"===e||"textarea"===e)),e=!s;break e;default:e=!1}if(e)return null;if(n&&"function"!==typeof n)throw Error(i(231,t,typeof n));return n}var De=!1;if(c)try{var Fe={};Object.defineProperty(Fe,"passive",{get:function(){De=!0}}),window.addEventListener("test",Fe,Fe),window.removeEventListener("test",Fe,Fe)}catch(ce){De=!1}function Me(e,t,n,s,r,i,a,o,l){var u=Array.prototype.slice.call(arguments,3);try{t.apply(n,u)}catch(c){this.onError(c)}}var Oe=!1,Le=null,Pe=!1,ze=null,Be={onError:function(e){Oe=!0,Le=e}};function We(e,t,n,s,r,i,a,o,l){Oe=!1,Le=null,Me.apply(Be,arguments)}function Ve(e){var t=e,n=e;if(e.alternate)for(;t.return;)t=t.return;else{e=t;do{0!==(4098&(t=e).flags)&&(n=t.return),e=t.return}while(e)}return 3===t.tag?n:null}function Ue(e){if(13===e.tag){var t=e.memoizedState;if(null===t&&(null!==(e=e.alternate)&&(t=e.memoizedState)),null!==t)return t.dehydrated}return null}function Ge(e){if(Ve(e)!==e)throw Error(i(188))}function He(e){return null!==(e=function(e){var t=e.alternate;if(!t){if(null===(t=Ve(e)))throw Error(i(188));return t!==e?null:e}for(var n=e,s=t;;){var r=n.return;if(null===r)break;var a=r.alternate;if(null===a){if(null!==(s=r.return)){n=s;continue}break}if(r.child===a.child){for(a=r.child;a;){if(a===n)return Ge(r),e;if(a===s)return Ge(r),t;a=a.sibling}throw Error(i(188))}if(n.return!==s.return)n=r,s=a;else{for(var o=!1,l=r.child;l;){if(l===n){o=!0,n=r,s=a;break}if(l===s){o=!0,s=r,n=a;break}l=l.sibling}if(!o){for(l=a.child;l;){if(l===n){o=!0,n=a,s=r;break}if(l===s){o=!0,s=a,n=r;break}l=l.sibling}if(!o)throw Error(i(189))}}if(n.alternate!==s)throw Error(i(190))}if(3!==n.tag)throw Error(i(188));return n.stateNode.current===n?e:t}(e))?je(e):null}function je(e){if(5===e.tag||6===e.tag)return e;for(e=e.child;null!==e;){var t=je(e);if(null!==t)return t;e=e.sibling}return null}var Ke=r.unstable_scheduleCallback,Xe=r.unstable_cancelCallback,qe=r.unstable_shouldYield,Ye=r.unstable_requestPaint,Qe=r.unstable_now,Ze=r.unstable_getCurrentPriorityLevel,Je=r.unstable_ImmediatePriority,et=r.unstable_UserBlockingPriority,tt=r.unstable_NormalPriority,nt=r.unstable_LowPriority,st=r.unstable_IdlePriority,rt=null,it=null;var at=Math.clz32?Math.clz32:function(e){return e>>>=0,0===e?32:31-(ot(e)/lt|0)|0},ot=Math.log,lt=Math.LN2;var ut=64,ct=4194304;function ht(e){switch(e&-e){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return 4194240&e;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return 130023424&e;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return e}}function dt(e,t){var n=e.pendingLanes;if(0===n)return 0;var s=0,r=e.suspendedLanes,i=e.pingedLanes,a=268435455&n;if(0!==a){var o=a&~r;0!==o?s=ht(o):0!==(i&=a)&&(s=ht(i))}else 0!==(a=n&~r)?s=ht(a):0!==i&&(s=ht(i));if(0===s)return 0;if(0!==t&&t!==s&&0===(t&r)&&((r=s&-s)>=(i=t&-t)||16===r&&0!==(4194240&i)))return t;if(0!==(4&s)&&(s|=16&n),0!==(t=e.entangledLanes))for(e=e.entanglements,t&=s;0<t;)r=1<<(n=31-at(t)),s|=e[n],t&=~r;return s}function pt(e,t){switch(e){case 1:case 2:case 4:return t+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return t+5e3;default:return-1}}function ft(e){return 0!==(e=-1073741825&e.pendingLanes)?e:1073741824&e?1073741824:0}function gt(){var e=ut;return 0===(4194240&(ut<<=1))&&(ut=64),e}function mt(e){for(var t=[],n=0;31>n;n++)t.push(e);return t}function bt(e,t,n){e.pendingLanes|=t,536870912!==t&&(e.suspendedLanes=0,e.pingedLanes=0),(e=e.eventTimes)[t=31-at(t)]=n}function xt(e,t){var n=e.entangledLanes|=t;for(e=e.entanglements;n;){var s=31-at(n),r=1<<s;r&t|e[s]&t&&(e[s]|=t),n&=~r}}var yt=0;function vt(e){return 1<(e&=-e)?4<e?0!==(268435455&e)?16:536870912:4:1}var wt,kt,St,It,Ct,Nt=!1,Tt=[],_t=null,Et=null,$t=null,Rt=new Map,At=new Map,Dt=[],Ft="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function Mt(e,t){switch(e){case"focusin":case"focusout":_t=null;break;case"dragenter":case"dragleave":Et=null;break;case"mouseover":case"mouseout":$t=null;break;case"pointerover":case"pointerout":Rt.delete(t.pointerId);break;case"gotpointercapture":case"lostpointercapture":At.delete(t.pointerId)}}function Ot(e,t,n,s,r,i){return null===e||e.nativeEvent!==i?(e={blockedOn:t,domEventName:n,eventSystemFlags:s,nativeEvent:i,targetContainers:[r]},null!==t&&(null!==(t=yr(t))&&kt(t)),e):(e.eventSystemFlags|=s,t=e.targetContainers,null!==r&&-1===t.indexOf(r)&&t.push(r),e)}function Lt(e){var t=xr(e.target);if(null!==t){var n=Ve(t);if(null!==n)if(13===(t=n.tag)){if(null!==(t=Ue(n)))return e.blockedOn=t,void Ct(e.priority,(function(){St(n)}))}else if(3===t&&n.stateNode.current.memoizedState.isDehydrated)return void(e.blockedOn=3===n.tag?n.stateNode.containerInfo:null)}e.blockedOn=null}function Pt(e){if(null!==e.blockedOn)return!1;for(var t=e.targetContainers;0<t.length;){var n=qt(e.domEventName,e.eventSystemFlags,t[0],e.nativeEvent);if(null!==n)return null!==(t=yr(n))&&kt(t),e.blockedOn=n,!1;var s=new(n=e.nativeEvent).constructor(n.type,n);ve=s,n.target.dispatchEvent(s),ve=null,t.shift()}return!0}function zt(e,t,n){Pt(e)&&n.delete(t)}function Bt(){Nt=!1,null!==_t&&Pt(_t)&&(_t=null),null!==Et&&Pt(Et)&&(Et=null),null!==$t&&Pt($t)&&($t=null),Rt.forEach(zt),At.forEach(zt)}function Wt(e,t){e.blockedOn===t&&(e.blockedOn=null,Nt||(Nt=!0,r.unstable_scheduleCallback(r.unstable_NormalPriority,Bt)))}function Vt(e){function t(t){return Wt(t,e)}if(0<Tt.length){Wt(Tt[0],e);for(var n=1;n<Tt.length;n++){var s=Tt[n];s.blockedOn===e&&(s.blockedOn=null)}}for(null!==_t&&Wt(_t,e),null!==Et&&Wt(Et,e),null!==$t&&Wt($t,e),Rt.forEach(t),At.forEach(t),n=0;n<Dt.length;n++)(s=Dt[n]).blockedOn===e&&(s.blockedOn=null);for(;0<Dt.length&&null===(n=Dt[0]).blockedOn;)Lt(n),null===n.blockedOn&&Dt.shift()}var Ut=v.ReactCurrentBatchConfig,Gt=!0;function Ht(e,t,n,s){var r=yt,i=Ut.transition;Ut.transition=null;try{yt=1,Kt(e,t,n,s)}finally{yt=r,Ut.transition=i}}function jt(e,t,n,s){var r=yt,i=Ut.transition;Ut.transition=null;try{yt=4,Kt(e,t,n,s)}finally{yt=r,Ut.transition=i}}function Kt(e,t,n,s){if(Gt){var r=qt(e,t,n,s);if(null===r)Gs(e,t,s,Xt,n),Mt(e,s);else if(function(e,t,n,s,r){switch(t){case"focusin":return _t=Ot(_t,e,t,n,s,r),!0;case"dragenter":return Et=Ot(Et,e,t,n,s,r),!0;case"mouseover":return $t=Ot($t,e,t,n,s,r),!0;case"pointerover":var i=r.pointerId;return Rt.set(i,Ot(Rt.get(i)||null,e,t,n,s,r)),!0;case"gotpointercapture":return i=r.pointerId,At.set(i,Ot(At.get(i)||null,e,t,n,s,r)),!0}return!1}(r,e,t,n,s))s.stopPropagation();else if(Mt(e,s),4&t&&-1<Ft.indexOf(e)){for(;null!==r;){var i=yr(r);if(null!==i&&wt(i),null===(i=qt(e,t,n,s))&&Gs(e,t,s,Xt,n),i===r)break;r=i}null!==r&&s.stopPropagation()}else Gs(e,t,s,null,n)}}var Xt=null;function qt(e,t,n,s){if(Xt=null,null!==(e=xr(e=we(s))))if(null===(t=Ve(e)))e=null;else if(13===(n=t.tag)){if(null!==(e=Ue(t)))return e;e=null}else if(3===n){if(t.stateNode.current.memoizedState.isDehydrated)return 3===t.tag?t.stateNode.containerInfo:null;e=null}else t!==e&&(e=null);return Xt=e,null}function Yt(e){switch(e){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(Ze()){case Je:return 1;case et:return 4;case tt:case nt:return 16;case st:return 536870912;default:return 16}default:return 16}}var Qt=null,Zt=null,Jt=null;function en(){if(Jt)return Jt;var e,t,n=Zt,s=n.length,r="value"in Qt?Qt.value:Qt.textContent,i=r.length;for(e=0;e<s&&n[e]===r[e];e++);var a=s-e;for(t=1;t<=a&&n[s-t]===r[i-t];t++);return Jt=r.slice(e,1<t?1-t:void 0)}function tn(e){var t=e.keyCode;return"charCode"in e?0===(e=e.charCode)&&13===t&&(e=13):e=t,10===e&&(e=13),32<=e||13===e?e:0}function nn(){return!0}function sn(){return!1}function rn(e){function t(t,n,s,r,i){for(var a in this._reactName=t,this._targetInst=s,this.type=n,this.nativeEvent=r,this.target=i,this.currentTarget=null,e)e.hasOwnProperty(a)&&(t=e[a],this[a]=t?t(r):r[a]);return this.isDefaultPrevented=(null!=r.defaultPrevented?r.defaultPrevented:!1===r.returnValue)?nn:sn,this.isPropagationStopped=sn,this}return L(t.prototype,{preventDefault:function(){this.defaultPrevented=!0;var e=this.nativeEvent;e&&(e.preventDefault?e.preventDefault():"unknown"!==typeof e.returnValue&&(e.returnValue=!1),this.isDefaultPrevented=nn)},stopPropagation:function(){var e=this.nativeEvent;e&&(e.stopPropagation?e.stopPropagation():"unknown"!==typeof e.cancelBubble&&(e.cancelBubble=!0),this.isPropagationStopped=nn)},persist:function(){},isPersistent:nn}),t}var an,on,ln,un={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(e){return e.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},cn=rn(un),hn=L({},un,{view:0,detail:0}),dn=rn(hn),pn=L({},hn,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:Cn,button:0,buttons:0,relatedTarget:function(e){return void 0===e.relatedTarget?e.fromElement===e.srcElement?e.toElement:e.fromElement:e.relatedTarget},movementX:function(e){return"movementX"in e?e.movementX:(e!==ln&&(ln&&"mousemove"===e.type?(an=e.screenX-ln.screenX,on=e.screenY-ln.screenY):on=an=0,ln=e),an)},movementY:function(e){return"movementY"in e?e.movementY:on}}),fn=rn(pn),gn=rn(L({},pn,{dataTransfer:0})),mn=rn(L({},hn,{relatedTarget:0})),bn=rn(L({},un,{animationName:0,elapsedTime:0,pseudoElement:0})),xn=L({},un,{clipboardData:function(e){return"clipboardData"in e?e.clipboardData:window.clipboardData}}),yn=rn(xn),vn=rn(L({},un,{data:0})),wn={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},kn={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Sn={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function In(e){var t=this.nativeEvent;return t.getModifierState?t.getModifierState(e):!!(e=Sn[e])&&!!t[e]}function Cn(){return In}var Nn=L({},hn,{key:function(e){if(e.key){var t=wn[e.key]||e.key;if("Unidentified"!==t)return t}return"keypress"===e.type?13===(e=tn(e))?"Enter":String.fromCharCode(e):"keydown"===e.type||"keyup"===e.type?kn[e.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:Cn,charCode:function(e){return"keypress"===e.type?tn(e):0},keyCode:function(e){return"keydown"===e.type||"keyup"===e.type?e.keyCode:0},which:function(e){return"keypress"===e.type?tn(e):"keydown"===e.type||"keyup"===e.type?e.keyCode:0}}),Tn=rn(Nn),_n=rn(L({},pn,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0})),En=rn(L({},hn,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:Cn})),$n=rn(L({},un,{propertyName:0,elapsedTime:0,pseudoElement:0})),Rn=L({},pn,{deltaX:function(e){return"deltaX"in e?e.deltaX:"wheelDeltaX"in e?-e.wheelDeltaX:0},deltaY:function(e){return"deltaY"in e?e.deltaY:"wheelDeltaY"in e?-e.wheelDeltaY:"wheelDelta"in e?-e.wheelDelta:0},deltaZ:0,deltaMode:0}),An=rn(Rn),Dn=[9,13,27,32],Fn=c&&"CompositionEvent"in window,Mn=null;c&&"documentMode"in document&&(Mn=document.documentMode);var On=c&&"TextEvent"in window&&!Mn,Ln=c&&(!Fn||Mn&&8<Mn&&11>=Mn),Pn=String.fromCharCode(32),zn=!1;function Bn(e,t){switch(e){case"keyup":return-1!==Dn.indexOf(t.keyCode);case"keydown":return 229!==t.keyCode;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function Wn(e){return"object"===typeof(e=e.detail)&&"data"in e?e.data:null}var Vn=!1;var Un={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function Gn(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return"input"===t?!!Un[e.type]:"textarea"===t}function Hn(e,t,n,s){Ne(s),0<(t=js(t,"onChange")).length&&(n=new cn("onChange","change",null,n,s),e.push({event:n,listeners:t}))}var jn=null,Kn=null;function Xn(e){Ps(e,0)}function qn(e){if(K(vr(e)))return e}function Yn(e,t){if("change"===e)return t}var Qn=!1;if(c){var Zn;if(c){var Jn="oninput"in document;if(!Jn){var es=document.createElement("div");es.setAttribute("oninput","return;"),Jn="function"===typeof es.oninput}Zn=Jn}else Zn=!1;Qn=Zn&&(!document.documentMode||9<document.documentMode)}function ts(){jn&&(jn.detachEvent("onpropertychange",ns),Kn=jn=null)}function ns(e){if("value"===e.propertyName&&qn(Kn)){var t=[];Hn(t,Kn,e,we(e)),Re(Xn,t)}}function ss(e,t,n){"focusin"===e?(ts(),Kn=n,(jn=t).attachEvent("onpropertychange",ns)):"focusout"===e&&ts()}function rs(e){if("selectionchange"===e||"keyup"===e||"keydown"===e)return qn(Kn)}function is(e,t){if("click"===e)return qn(t)}function as(e,t){if("input"===e||"change"===e)return qn(t)}var os="function"===typeof Object.is?Object.is:function(e,t){return e===t&&(0!==e||1/e===1/t)||e!==e&&t!==t};function ls(e,t){if(os(e,t))return!0;if("object"!==typeof e||null===e||"object"!==typeof t||null===t)return!1;var n=Object.keys(e),s=Object.keys(t);if(n.length!==s.length)return!1;for(s=0;s<n.length;s++){var r=n[s];if(!h.call(t,r)||!os(e[r],t[r]))return!1}return!0}function us(e){for(;e&&e.firstChild;)e=e.firstChild;return e}function cs(e,t){var n,s=us(e);for(e=0;s;){if(3===s.nodeType){if(n=e+s.textContent.length,e<=t&&n>=t)return{node:s,offset:t-e};e=n}e:{for(;s;){if(s.nextSibling){s=s.nextSibling;break e}s=s.parentNode}s=void 0}s=us(s)}}function hs(e,t){return!(!e||!t)&&(e===t||(!e||3!==e.nodeType)&&(t&&3===t.nodeType?hs(e,t.parentNode):"contains"in e?e.contains(t):!!e.compareDocumentPosition&&!!(16&e.compareDocumentPosition(t))))}function ds(){for(var e=window,t=X();t instanceof e.HTMLIFrameElement;){try{var n="string"===typeof t.contentWindow.location.href}catch(s){n=!1}if(!n)break;t=X((e=t.contentWindow).document)}return t}function ps(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t&&("input"===t&&("text"===e.type||"search"===e.type||"tel"===e.type||"url"===e.type||"password"===e.type)||"textarea"===t||"true"===e.contentEditable)}function fs(e){var t=ds(),n=e.focusedElem,s=e.selectionRange;if(t!==n&&n&&n.ownerDocument&&hs(n.ownerDocument.documentElement,n)){if(null!==s&&ps(n))if(t=s.start,void 0===(e=s.end)&&(e=t),"selectionStart"in n)n.selectionStart=t,n.selectionEnd=Math.min(e,n.value.length);else if((e=(t=n.ownerDocument||document)&&t.defaultView||window).getSelection){e=e.getSelection();var r=n.textContent.length,i=Math.min(s.start,r);s=void 0===s.end?i:Math.min(s.end,r),!e.extend&&i>s&&(r=s,s=i,i=r),r=cs(n,i);var a=cs(n,s);r&&a&&(1!==e.rangeCount||e.anchorNode!==r.node||e.anchorOffset!==r.offset||e.focusNode!==a.node||e.focusOffset!==a.offset)&&((t=t.createRange()).setStart(r.node,r.offset),e.removeAllRanges(),i>s?(e.addRange(t),e.extend(a.node,a.offset)):(t.setEnd(a.node,a.offset),e.addRange(t)))}for(t=[],e=n;e=e.parentNode;)1===e.nodeType&&t.push({element:e,left:e.scrollLeft,top:e.scrollTop});for("function"===typeof n.focus&&n.focus(),n=0;n<t.length;n++)(e=t[n]).element.scrollLeft=e.left,e.element.scrollTop=e.top}}var gs=c&&"documentMode"in document&&11>=document.documentMode,ms=null,bs=null,xs=null,ys=!1;function vs(e,t,n){var s=n.window===n?n.document:9===n.nodeType?n:n.ownerDocument;ys||null==ms||ms!==X(s)||("selectionStart"in(s=ms)&&ps(s)?s={start:s.selectionStart,end:s.selectionEnd}:s={anchorNode:(s=(s.ownerDocument&&s.ownerDocument.defaultView||window).getSelection()).anchorNode,anchorOffset:s.anchorOffset,focusNode:s.focusNode,focusOffset:s.focusOffset},xs&&ls(xs,s)||(xs=s,0<(s=js(bs,"onSelect")).length&&(t=new cn("onSelect","select",null,t,n),e.push({event:t,listeners:s}),t.target=ms)))}function ws(e,t){var n={};return n[e.toLowerCase()]=t.toLowerCase(),n["Webkit"+e]="webkit"+t,n["Moz"+e]="moz"+t,n}var ks={animationend:ws("Animation","AnimationEnd"),animationiteration:ws("Animation","AnimationIteration"),animationstart:ws("Animation","AnimationStart"),transitionend:ws("Transition","TransitionEnd")},Ss={},Is={};function Cs(e){if(Ss[e])return Ss[e];if(!ks[e])return e;var t,n=ks[e];for(t in n)if(n.hasOwnProperty(t)&&t in Is)return Ss[e]=n[t];return e}c&&(Is=document.createElement("div").style,"AnimationEvent"in window||(delete ks.animationend.animation,delete ks.animationiteration.animation,delete ks.animationstart.animation),"TransitionEvent"in window||delete ks.transitionend.transition);var Ns=Cs("animationend"),Ts=Cs("animationiteration"),_s=Cs("animationstart"),Es=Cs("transitionend"),$s=new Map,Rs="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function As(e,t){$s.set(e,t),l(t,[e])}for(var Ds=0;Ds<Rs.length;Ds++){var Fs=Rs[Ds];As(Fs.toLowerCase(),"on"+(Fs[0].toUpperCase()+Fs.slice(1)))}As(Ns,"onAnimationEnd"),As(Ts,"onAnimationIteration"),As(_s,"onAnimationStart"),As("dblclick","onDoubleClick"),As("focusin","onFocus"),As("focusout","onBlur"),As(Es,"onTransitionEnd"),u("onMouseEnter",["mouseout","mouseover"]),u("onMouseLeave",["mouseout","mouseover"]),u("onPointerEnter",["pointerout","pointerover"]),u("onPointerLeave",["pointerout","pointerover"]),l("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),l("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),l("onBeforeInput",["compositionend","keypress","textInput","paste"]),l("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),l("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),l("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Ms="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Os=new Set("cancel close invalid load scroll toggle".split(" ").concat(Ms));function Ls(e,t,n){var s=e.type||"unknown-event";e.currentTarget=n,function(e,t,n,s,r,a,o,l,u){if(We.apply(this,arguments),Oe){if(!Oe)throw Error(i(198));var c=Le;Oe=!1,Le=null,Pe||(Pe=!0,ze=c)}}(s,t,void 0,e),e.currentTarget=null}function Ps(e,t){t=0!==(4&t);for(var n=0;n<e.length;n++){var s=e[n],r=s.event;s=s.listeners;e:{var i=void 0;if(t)for(var a=s.length-1;0<=a;a--){var o=s[a],l=o.instance,u=o.currentTarget;if(o=o.listener,l!==i&&r.isPropagationStopped())break e;Ls(r,o,u),i=l}else for(a=0;a<s.length;a++){if(l=(o=s[a]).instance,u=o.currentTarget,o=o.listener,l!==i&&r.isPropagationStopped())break e;Ls(r,o,u),i=l}}}if(Pe)throw e=ze,Pe=!1,ze=null,e}function zs(e,t){var n=t[gr];void 0===n&&(n=t[gr]=new Set);var s=e+"__bubble";n.has(s)||(Us(t,e,2,!1),n.add(s))}function Bs(e,t,n){var s=0;t&&(s|=4),Us(n,e,s,t)}var Ws="_reactListening"+Math.random().toString(36).slice(2);function Vs(e){if(!e[Ws]){e[Ws]=!0,a.forEach((function(t){"selectionchange"!==t&&(Os.has(t)||Bs(t,!1,e),Bs(t,!0,e))}));var t=9===e.nodeType?e:e.ownerDocument;null===t||t[Ws]||(t[Ws]=!0,Bs("selectionchange",!1,t))}}function Us(e,t,n,s){switch(Yt(t)){case 1:var r=Ht;break;case 4:r=jt;break;default:r=Kt}n=r.bind(null,t,n,e),r=void 0,!De||"touchstart"!==t&&"touchmove"!==t&&"wheel"!==t||(r=!0),s?void 0!==r?e.addEventListener(t,n,{capture:!0,passive:r}):e.addEventListener(t,n,!0):void 0!==r?e.addEventListener(t,n,{passive:r}):e.addEventListener(t,n,!1)}function Gs(e,t,n,s,r){var i=s;if(0===(1&t)&&0===(2&t)&&null!==s)e:for(;;){if(null===s)return;var a=s.tag;if(3===a||4===a){var o=s.stateNode.containerInfo;if(o===r||8===o.nodeType&&o.parentNode===r)break;if(4===a)for(a=s.return;null!==a;){var l=a.tag;if((3===l||4===l)&&((l=a.stateNode.containerInfo)===r||8===l.nodeType&&l.parentNode===r))return;a=a.return}for(;null!==o;){if(null===(a=xr(o)))return;if(5===(l=a.tag)||6===l){s=i=a;continue e}o=o.parentNode}}s=s.return}Re((function(){var s=i,r=we(n),a=[];e:{var o=$s.get(e);if(void 0!==o){var l=cn,u=e;switch(e){case"keypress":if(0===tn(n))break e;case"keydown":case"keyup":l=Tn;break;case"focusin":u="focus",l=mn;break;case"focusout":u="blur",l=mn;break;case"beforeblur":case"afterblur":l=mn;break;case"click":if(2===n.button)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":l=fn;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":l=gn;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":l=En;break;case Ns:case Ts:case _s:l=bn;break;case Es:l=$n;break;case"scroll":l=dn;break;case"wheel":l=An;break;case"copy":case"cut":case"paste":l=yn;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":l=_n}var c=0!==(4&t),h=!c&&"scroll"===e,d=c?null!==o?o+"Capture":null:o;c=[];for(var p,f=s;null!==f;){var g=(p=f).stateNode;if(5===p.tag&&null!==g&&(p=g,null!==d&&(null!=(g=Ae(f,d))&&c.push(Hs(f,g,p)))),h)break;f=f.return}0<c.length&&(o=new l(o,u,null,n,r),a.push({event:o,listeners:c}))}}if(0===(7&t)){if(l="mouseout"===e||"pointerout"===e,(!(o="mouseover"===e||"pointerover"===e)||n===ve||!(u=n.relatedTarget||n.fromElement)||!xr(u)&&!u[fr])&&(l||o)&&(o=r.window===r?r:(o=r.ownerDocument)?o.defaultView||o.parentWindow:window,l?(l=s,null!==(u=(u=n.relatedTarget||n.toElement)?xr(u):null)&&(u!==(h=Ve(u))||5!==u.tag&&6!==u.tag)&&(u=null)):(l=null,u=s),l!==u)){if(c=fn,g="onMouseLeave",d="onMouseEnter",f="mouse","pointerout"!==e&&"pointerover"!==e||(c=_n,g="onPointerLeave",d="onPointerEnter",f="pointer"),h=null==l?o:vr(l),p=null==u?o:vr(u),(o=new c(g,f+"leave",l,n,r)).target=h,o.relatedTarget=p,g=null,xr(r)===s&&((c=new c(d,f+"enter",u,n,r)).target=p,c.relatedTarget=h,g=c),h=g,l&&u)e:{for(d=u,f=0,p=c=l;p;p=Ks(p))f++;for(p=0,g=d;g;g=Ks(g))p++;for(;0<f-p;)c=Ks(c),f--;for(;0<p-f;)d=Ks(d),p--;for(;f--;){if(c===d||null!==d&&c===d.alternate)break e;c=Ks(c),d=Ks(d)}c=null}else c=null;null!==l&&Xs(a,o,l,c,!1),null!==u&&null!==h&&Xs(a,h,u,c,!0)}if("select"===(l=(o=s?vr(s):window).nodeName&&o.nodeName.toLowerCase())||"input"===l&&"file"===o.type)var m=Yn;else if(Gn(o))if(Qn)m=as;else{m=rs;var b=ss}else(l=o.nodeName)&&"input"===l.toLowerCase()&&("checkbox"===o.type||"radio"===o.type)&&(m=is);switch(m&&(m=m(e,s))?Hn(a,m,n,r):(b&&b(e,o,s),"focusout"===e&&(b=o._wrapperState)&&b.controlled&&"number"===o.type&&ee(o,"number",o.value)),b=s?vr(s):window,e){case"focusin":(Gn(b)||"true"===b.contentEditable)&&(ms=b,bs=s,xs=null);break;case"focusout":xs=bs=ms=null;break;case"mousedown":ys=!0;break;case"contextmenu":case"mouseup":case"dragend":ys=!1,vs(a,n,r);break;case"selectionchange":if(gs)break;case"keydown":case"keyup":vs(a,n,r)}var x;if(Fn)e:{switch(e){case"compositionstart":var y="onCompositionStart";break e;case"compositionend":y="onCompositionEnd";break e;case"compositionupdate":y="onCompositionUpdate";break e}y=void 0}else Vn?Bn(e,n)&&(y="onCompositionEnd"):"keydown"===e&&229===n.keyCode&&(y="onCompositionStart");y&&(Ln&&"ko"!==n.locale&&(Vn||"onCompositionStart"!==y?"onCompositionEnd"===y&&Vn&&(x=en()):(Zt="value"in(Qt=r)?Qt.value:Qt.textContent,Vn=!0)),0<(b=js(s,y)).length&&(y=new vn(y,e,null,n,r),a.push({event:y,listeners:b}),x?y.data=x:null!==(x=Wn(n))&&(y.data=x))),(x=On?function(e,t){switch(e){case"compositionend":return Wn(t);case"keypress":return 32!==t.which?null:(zn=!0,Pn);case"textInput":return(e=t.data)===Pn&&zn?null:e;default:return null}}(e,n):function(e,t){if(Vn)return"compositionend"===e||!Fn&&Bn(e,t)?(e=en(),Jt=Zt=Qt=null,Vn=!1,e):null;switch(e){case"paste":default:return null;case"keypress":if(!(t.ctrlKey||t.altKey||t.metaKey)||t.ctrlKey&&t.altKey){if(t.char&&1<t.char.length)return t.char;if(t.which)return String.fromCharCode(t.which)}return null;case"compositionend":return Ln&&"ko"!==t.locale?null:t.data}}(e,n))&&(0<(s=js(s,"onBeforeInput")).length&&(r=new vn("onBeforeInput","beforeinput",null,n,r),a.push({event:r,listeners:s}),r.data=x))}Ps(a,t)}))}function Hs(e,t,n){return{instance:e,listener:t,currentTarget:n}}function js(e,t){for(var n=t+"Capture",s=[];null!==e;){var r=e,i=r.stateNode;5===r.tag&&null!==i&&(r=i,null!=(i=Ae(e,n))&&s.unshift(Hs(e,i,r)),null!=(i=Ae(e,t))&&s.push(Hs(e,i,r))),e=e.return}return s}function Ks(e){if(null===e)return null;do{e=e.return}while(e&&5!==e.tag);return e||null}function Xs(e,t,n,s,r){for(var i=t._reactName,a=[];null!==n&&n!==s;){var o=n,l=o.alternate,u=o.stateNode;if(null!==l&&l===s)break;5===o.tag&&null!==u&&(o=u,r?null!=(l=Ae(n,i))&&a.unshift(Hs(n,l,o)):r||null!=(l=Ae(n,i))&&a.push(Hs(n,l,o))),n=n.return}0!==a.length&&e.push({event:t,listeners:a})}var qs=/\r\n?/g,Ys=/\u0000|\uFFFD/g;function Qs(e){return("string"===typeof e?e:""+e).replace(qs,"\n").replace(Ys,"")}function Zs(e,t,n){if(t=Qs(t),Qs(e)!==t&&n)throw Error(i(425))}function Js(){}var er=null,tr=null;function nr(e,t){return"textarea"===e||"noscript"===e||"string"===typeof t.children||"number"===typeof t.children||"object"===typeof t.dangerouslySetInnerHTML&&null!==t.dangerouslySetInnerHTML&&null!=t.dangerouslySetInnerHTML.__html}var sr="function"===typeof setTimeout?setTimeout:void 0,rr="function"===typeof clearTimeout?clearTimeout:void 0,ir="function"===typeof Promise?Promise:void 0,ar="function"===typeof queueMicrotask?queueMicrotask:"undefined"!==typeof ir?function(e){return ir.resolve(null).then(e).catch(or)}:sr;function or(e){setTimeout((function(){throw e}))}function lr(e,t){var n=t,s=0;do{var r=n.nextSibling;if(e.removeChild(n),r&&8===r.nodeType)if("/$"===(n=r.data)){if(0===s)return e.removeChild(r),void Vt(t);s--}else"$"!==n&&"$?"!==n&&"$!"!==n||s++;n=r}while(n);Vt(t)}function ur(e){for(;null!=e;e=e.nextSibling){var t=e.nodeType;if(1===t||3===t)break;if(8===t){if("$"===(t=e.data)||"$!"===t||"$?"===t)break;if("/$"===t)return null}}return e}function cr(e){e=e.previousSibling;for(var t=0;e;){if(8===e.nodeType){var n=e.data;if("$"===n||"$!"===n||"$?"===n){if(0===t)return e;t--}else"/$"===n&&t++}e=e.previousSibling}return null}var hr=Math.random().toString(36).slice(2),dr="__reactFiber$"+hr,pr="__reactProps$"+hr,fr="__reactContainer$"+hr,gr="__reactEvents$"+hr,mr="__reactListeners$"+hr,br="__reactHandles$"+hr;function xr(e){var t=e[dr];if(t)return t;for(var n=e.parentNode;n;){if(t=n[fr]||n[dr]){if(n=t.alternate,null!==t.child||null!==n&&null!==n.child)for(e=cr(e);null!==e;){if(n=e[dr])return n;e=cr(e)}return t}n=(e=n).parentNode}return null}function yr(e){return!(e=e[dr]||e[fr])||5!==e.tag&&6!==e.tag&&13!==e.tag&&3!==e.tag?null:e}function vr(e){if(5===e.tag||6===e.tag)return e.stateNode;throw Error(i(33))}function wr(e){return e[pr]||null}var kr=[],Sr=-1;function Ir(e){return{current:e}}function Cr(e){0>Sr||(e.current=kr[Sr],kr[Sr]=null,Sr--)}function Nr(e,t){Sr++,kr[Sr]=e.current,e.current=t}var Tr={},_r=Ir(Tr),Er=Ir(!1),$r=Tr;function Rr(e,t){var n=e.type.contextTypes;if(!n)return Tr;var s=e.stateNode;if(s&&s.__reactInternalMemoizedUnmaskedChildContext===t)return s.__reactInternalMemoizedMaskedChildContext;var r,i={};for(r in n)i[r]=t[r];return s&&((e=e.stateNode).__reactInternalMemoizedUnmaskedChildContext=t,e.__reactInternalMemoizedMaskedChildContext=i),i}function Ar(e){return null!==(e=e.childContextTypes)&&void 0!==e}function Dr(){Cr(Er),Cr(_r)}function Fr(e,t,n){if(_r.current!==Tr)throw Error(i(168));Nr(_r,t),Nr(Er,n)}function Mr(e,t,n){var s=e.stateNode;if(t=t.childContextTypes,"function"!==typeof s.getChildContext)return n;for(var r in s=s.getChildContext())if(!(r in t))throw Error(i(108,U(e)||"Unknown",r));return L({},n,s)}function Or(e){return e=(e=e.stateNode)&&e.__reactInternalMemoizedMergedChildContext||Tr,$r=_r.current,Nr(_r,e),Nr(Er,Er.current),!0}function Lr(e,t,n){var s=e.stateNode;if(!s)throw Error(i(169));n?(e=Mr(e,t,$r),s.__reactInternalMemoizedMergedChildContext=e,Cr(Er),Cr(_r),Nr(_r,e)):Cr(Er),Nr(Er,n)}var Pr=null,zr=!1,Br=!1;function Wr(e){null===Pr?Pr=[e]:Pr.push(e)}function Vr(){if(!Br&&null!==Pr){Br=!0;var e=0,t=yt;try{var n=Pr;for(yt=1;e<n.length;e++){var s=n[e];do{s=s(!0)}while(null!==s)}Pr=null,zr=!1}catch(r){throw null!==Pr&&(Pr=Pr.slice(e+1)),Ke(Je,Vr),r}finally{yt=t,Br=!1}}return null}var Ur=[],Gr=0,Hr=null,jr=0,Kr=[],Xr=0,qr=null,Yr=1,Qr="";function Zr(e,t){Ur[Gr++]=jr,Ur[Gr++]=Hr,Hr=e,jr=t}function Jr(e,t,n){Kr[Xr++]=Yr,Kr[Xr++]=Qr,Kr[Xr++]=qr,qr=e;var s=Yr;e=Qr;var r=32-at(s)-1;s&=~(1<<r),n+=1;var i=32-at(t)+r;if(30<i){var a=r-r%5;i=(s&(1<<a)-1).toString(32),s>>=a,r-=a,Yr=1<<32-at(t)+r|n<<r|s,Qr=i+e}else Yr=1<<i|n<<r|s,Qr=e}function ei(e){null!==e.return&&(Zr(e,1),Jr(e,1,0))}function ti(e){for(;e===Hr;)Hr=Ur[--Gr],Ur[Gr]=null,jr=Ur[--Gr],Ur[Gr]=null;for(;e===qr;)qr=Kr[--Xr],Kr[Xr]=null,Qr=Kr[--Xr],Kr[Xr]=null,Yr=Kr[--Xr],Kr[Xr]=null}var ni=null,si=null,ri=!1,ii=null;function ai(e,t){var n=Ru(5,null,null,0);n.elementType="DELETED",n.stateNode=t,n.return=e,null===(t=e.deletions)?(e.deletions=[n],e.flags|=16):t.push(n)}function oi(e,t){switch(e.tag){case 5:var n=e.type;return null!==(t=1!==t.nodeType||n.toLowerCase()!==t.nodeName.toLowerCase()?null:t)&&(e.stateNode=t,ni=e,si=ur(t.firstChild),!0);case 6:return null!==(t=""===e.pendingProps||3!==t.nodeType?null:t)&&(e.stateNode=t,ni=e,si=null,!0);case 13:return null!==(t=8!==t.nodeType?null:t)&&(n=null!==qr?{id:Yr,overflow:Qr}:null,e.memoizedState={dehydrated:t,treeContext:n,retryLane:1073741824},(n=Ru(18,null,null,0)).stateNode=t,n.return=e,e.child=n,ni=e,si=null,!0);default:return!1}}function li(e){return 0!==(1&e.mode)&&0===(128&e.flags)}function ui(e){if(ri){var t=si;if(t){var n=t;if(!oi(e,t)){if(li(e))throw Error(i(418));t=ur(n.nextSibling);var s=ni;t&&oi(e,t)?ai(s,n):(e.flags=-4097&e.flags|2,ri=!1,ni=e)}}else{if(li(e))throw Error(i(418));e.flags=-4097&e.flags|2,ri=!1,ni=e}}}function ci(e){for(e=e.return;null!==e&&5!==e.tag&&3!==e.tag&&13!==e.tag;)e=e.return;ni=e}function hi(e){if(e!==ni)return!1;if(!ri)return ci(e),ri=!0,!1;var t;if((t=3!==e.tag)&&!(t=5!==e.tag)&&(t="head"!==(t=e.type)&&"body"!==t&&!nr(e.type,e.memoizedProps)),t&&(t=si)){if(li(e))throw di(),Error(i(418));for(;t;)ai(e,t),t=ur(t.nextSibling)}if(ci(e),13===e.tag){if(!(e=null!==(e=e.memoizedState)?e.dehydrated:null))throw Error(i(317));e:{for(e=e.nextSibling,t=0;e;){if(8===e.nodeType){var n=e.data;if("/$"===n){if(0===t){si=ur(e.nextSibling);break e}t--}else"$"!==n&&"$!"!==n&&"$?"!==n||t++}e=e.nextSibling}si=null}}else si=ni?ur(e.stateNode.nextSibling):null;return!0}function di(){for(var e=si;e;)e=ur(e.nextSibling)}function pi(){si=ni=null,ri=!1}function fi(e){null===ii?ii=[e]:ii.push(e)}var gi=v.ReactCurrentBatchConfig;function mi(e,t,n){if(null!==(e=n.ref)&&"function"!==typeof e&&"object"!==typeof e){if(n._owner){if(n=n._owner){if(1!==n.tag)throw Error(i(309));var s=n.stateNode}if(!s)throw Error(i(147,e));var r=s,a=""+e;return null!==t&&null!==t.ref&&"function"===typeof t.ref&&t.ref._stringRef===a?t.ref:(t=function(e){var t=r.refs;null===e?delete t[a]:t[a]=e},t._stringRef=a,t)}if("string"!==typeof e)throw Error(i(284));if(!n._owner)throw Error(i(290,e))}return e}function bi(e,t){throw e=Object.prototype.toString.call(t),Error(i(31,"[object Object]"===e?"object with keys {"+Object.keys(t).join(", ")+"}":e))}function xi(e){return(0,e._init)(e._payload)}function yi(e){function t(t,n){if(e){var s=t.deletions;null===s?(t.deletions=[n],t.flags|=16):s.push(n)}}function n(n,s){if(!e)return null;for(;null!==s;)t(n,s),s=s.sibling;return null}function s(e,t){for(e=new Map;null!==t;)null!==t.key?e.set(t.key,t):e.set(t.index,t),t=t.sibling;return e}function r(e,t){return(e=Du(e,t)).index=0,e.sibling=null,e}function a(t,n,s){return t.index=s,e?null!==(s=t.alternate)?(s=s.index)<n?(t.flags|=2,n):s:(t.flags|=2,n):(t.flags|=1048576,n)}function o(t){return e&&null===t.alternate&&(t.flags|=2),t}function l(e,t,n,s){return null===t||6!==t.tag?((t=Lu(n,e.mode,s)).return=e,t):((t=r(t,n)).return=e,t)}function u(e,t,n,s){var i=n.type;return i===S?h(e,t,n.props.children,s,n.key):null!==t&&(t.elementType===i||"object"===typeof i&&null!==i&&i.$$typeof===A&&xi(i)===t.type)?((s=r(t,n.props)).ref=mi(e,t,n),s.return=e,s):((s=Fu(n.type,n.key,n.props,null,e.mode,s)).ref=mi(e,t,n),s.return=e,s)}function c(e,t,n,s){return null===t||4!==t.tag||t.stateNode.containerInfo!==n.containerInfo||t.stateNode.implementation!==n.implementation?((t=Pu(n,e.mode,s)).return=e,t):((t=r(t,n.children||[])).return=e,t)}function h(e,t,n,s,i){return null===t||7!==t.tag?((t=Mu(n,e.mode,s,i)).return=e,t):((t=r(t,n)).return=e,t)}function d(e,t,n){if("string"===typeof t&&""!==t||"number"===typeof t)return(t=Lu(""+t,e.mode,n)).return=e,t;if("object"===typeof t&&null!==t){switch(t.$$typeof){case w:return(n=Fu(t.type,t.key,t.props,null,e.mode,n)).ref=mi(e,null,t),n.return=e,n;case k:return(t=Pu(t,e.mode,n)).return=e,t;case A:return d(e,(0,t._init)(t._payload),n)}if(te(t)||M(t))return(t=Mu(t,e.mode,n,null)).return=e,t;bi(e,t)}return null}function p(e,t,n,s){var r=null!==t?t.key:null;if("string"===typeof n&&""!==n||"number"===typeof n)return null!==r?null:l(e,t,""+n,s);if("object"===typeof n&&null!==n){switch(n.$$typeof){case w:return n.key===r?u(e,t,n,s):null;case k:return n.key===r?c(e,t,n,s):null;case A:return p(e,t,(r=n._init)(n._payload),s)}if(te(n)||M(n))return null!==r?null:h(e,t,n,s,null);bi(e,n)}return null}function f(e,t,n,s,r){if("string"===typeof s&&""!==s||"number"===typeof s)return l(t,e=e.get(n)||null,""+s,r);if("object"===typeof s&&null!==s){switch(s.$$typeof){case w:return u(t,e=e.get(null===s.key?n:s.key)||null,s,r);case k:return c(t,e=e.get(null===s.key?n:s.key)||null,s,r);case A:return f(e,t,n,(0,s._init)(s._payload),r)}if(te(s)||M(s))return h(t,e=e.get(n)||null,s,r,null);bi(t,s)}return null}function g(r,i,o,l){for(var u=null,c=null,h=i,g=i=0,m=null;null!==h&&g<o.length;g++){h.index>g?(m=h,h=null):m=h.sibling;var b=p(r,h,o[g],l);if(null===b){null===h&&(h=m);break}e&&h&&null===b.alternate&&t(r,h),i=a(b,i,g),null===c?u=b:c.sibling=b,c=b,h=m}if(g===o.length)return n(r,h),ri&&Zr(r,g),u;if(null===h){for(;g<o.length;g++)null!==(h=d(r,o[g],l))&&(i=a(h,i,g),null===c?u=h:c.sibling=h,c=h);return ri&&Zr(r,g),u}for(h=s(r,h);g<o.length;g++)null!==(m=f(h,r,g,o[g],l))&&(e&&null!==m.alternate&&h.delete(null===m.key?g:m.key),i=a(m,i,g),null===c?u=m:c.sibling=m,c=m);return e&&h.forEach((function(e){return t(r,e)})),ri&&Zr(r,g),u}function m(r,o,l,u){var c=M(l);if("function"!==typeof c)throw Error(i(150));if(null==(l=c.call(l)))throw Error(i(151));for(var h=c=null,g=o,m=o=0,b=null,x=l.next();null!==g&&!x.done;m++,x=l.next()){g.index>m?(b=g,g=null):b=g.sibling;var y=p(r,g,x.value,u);if(null===y){null===g&&(g=b);break}e&&g&&null===y.alternate&&t(r,g),o=a(y,o,m),null===h?c=y:h.sibling=y,h=y,g=b}if(x.done)return n(r,g),ri&&Zr(r,m),c;if(null===g){for(;!x.done;m++,x=l.next())null!==(x=d(r,x.value,u))&&(o=a(x,o,m),null===h?c=x:h.sibling=x,h=x);return ri&&Zr(r,m),c}for(g=s(r,g);!x.done;m++,x=l.next())null!==(x=f(g,r,m,x.value,u))&&(e&&null!==x.alternate&&g.delete(null===x.key?m:x.key),o=a(x,o,m),null===h?c=x:h.sibling=x,h=x);return e&&g.forEach((function(e){return t(r,e)})),ri&&Zr(r,m),c}return function e(s,i,a,l){if("object"===typeof a&&null!==a&&a.type===S&&null===a.key&&(a=a.props.children),"object"===typeof a&&null!==a){switch(a.$$typeof){case w:e:{for(var u=a.key,c=i;null!==c;){if(c.key===u){if((u=a.type)===S){if(7===c.tag){n(s,c.sibling),(i=r(c,a.props.children)).return=s,s=i;break e}}else if(c.elementType===u||"object"===typeof u&&null!==u&&u.$$typeof===A&&xi(u)===c.type){n(s,c.sibling),(i=r(c,a.props)).ref=mi(s,c,a),i.return=s,s=i;break e}n(s,c);break}t(s,c),c=c.sibling}a.type===S?((i=Mu(a.props.children,s.mode,l,a.key)).return=s,s=i):((l=Fu(a.type,a.key,a.props,null,s.mode,l)).ref=mi(s,i,a),l.return=s,s=l)}return o(s);case k:e:{for(c=a.key;null!==i;){if(i.key===c){if(4===i.tag&&i.stateNode.containerInfo===a.containerInfo&&i.stateNode.implementation===a.implementation){n(s,i.sibling),(i=r(i,a.children||[])).return=s,s=i;break e}n(s,i);break}t(s,i),i=i.sibling}(i=Pu(a,s.mode,l)).return=s,s=i}return o(s);case A:return e(s,i,(c=a._init)(a._payload),l)}if(te(a))return g(s,i,a,l);if(M(a))return m(s,i,a,l);bi(s,a)}return"string"===typeof a&&""!==a||"number"===typeof a?(a=""+a,null!==i&&6===i.tag?(n(s,i.sibling),(i=r(i,a)).return=s,s=i):(n(s,i),(i=Lu(a,s.mode,l)).return=s,s=i),o(s)):n(s,i)}}var vi=yi(!0),wi=yi(!1),ki=Ir(null),Si=null,Ii=null,Ci=null;function Ni(){Ci=Ii=Si=null}function Ti(e){var t=ki.current;Cr(ki),e._currentValue=t}function _i(e,t,n){for(;null!==e;){var s=e.alternate;if((e.childLanes&t)!==t?(e.childLanes|=t,null!==s&&(s.childLanes|=t)):null!==s&&(s.childLanes&t)!==t&&(s.childLanes|=t),e===n)break;e=e.return}}function Ei(e,t){Si=e,Ci=Ii=null,null!==(e=e.dependencies)&&null!==e.firstContext&&(0!==(e.lanes&t)&&(yo=!0),e.firstContext=null)}function $i(e){var t=e._currentValue;if(Ci!==e)if(e={context:e,memoizedValue:t,next:null},null===Ii){if(null===Si)throw Error(i(308));Ii=e,Si.dependencies={lanes:0,firstContext:e}}else Ii=Ii.next=e;return t}var Ri=null;function Ai(e){null===Ri?Ri=[e]:Ri.push(e)}function Di(e,t,n,s){var r=t.interleaved;return null===r?(n.next=n,Ai(t)):(n.next=r.next,r.next=n),t.interleaved=n,Fi(e,s)}function Fi(e,t){e.lanes|=t;var n=e.alternate;for(null!==n&&(n.lanes|=t),n=e,e=e.return;null!==e;)e.childLanes|=t,null!==(n=e.alternate)&&(n.childLanes|=t),n=e,e=e.return;return 3===n.tag?n.stateNode:null}var Mi=!1;function Oi(e){e.updateQueue={baseState:e.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function Li(e,t){e=e.updateQueue,t.updateQueue===e&&(t.updateQueue={baseState:e.baseState,firstBaseUpdate:e.firstBaseUpdate,lastBaseUpdate:e.lastBaseUpdate,shared:e.shared,effects:e.effects})}function Pi(e,t){return{eventTime:e,lane:t,tag:0,payload:null,callback:null,next:null}}function zi(e,t,n){var s=e.updateQueue;if(null===s)return null;if(s=s.shared,0!==(2&_l)){var r=s.pending;return null===r?t.next=t:(t.next=r.next,r.next=t),s.pending=t,Fi(e,n)}return null===(r=s.interleaved)?(t.next=t,Ai(s)):(t.next=r.next,r.next=t),s.interleaved=t,Fi(e,n)}function Bi(e,t,n){if(null!==(t=t.updateQueue)&&(t=t.shared,0!==(4194240&n))){var s=t.lanes;n|=s&=e.pendingLanes,t.lanes=n,xt(e,n)}}function Wi(e,t){var n=e.updateQueue,s=e.alternate;if(null!==s&&n===(s=s.updateQueue)){var r=null,i=null;if(null!==(n=n.firstBaseUpdate)){do{var a={eventTime:n.eventTime,lane:n.lane,tag:n.tag,payload:n.payload,callback:n.callback,next:null};null===i?r=i=a:i=i.next=a,n=n.next}while(null!==n);null===i?r=i=t:i=i.next=t}else r=i=t;return n={baseState:s.baseState,firstBaseUpdate:r,lastBaseUpdate:i,shared:s.shared,effects:s.effects},void(e.updateQueue=n)}null===(e=n.lastBaseUpdate)?n.firstBaseUpdate=t:e.next=t,n.lastBaseUpdate=t}function Vi(e,t,n,s){var r=e.updateQueue;Mi=!1;var i=r.firstBaseUpdate,a=r.lastBaseUpdate,o=r.shared.pending;if(null!==o){r.shared.pending=null;var l=o,u=l.next;l.next=null,null===a?i=u:a.next=u,a=l;var c=e.alternate;null!==c&&((o=(c=c.updateQueue).lastBaseUpdate)!==a&&(null===o?c.firstBaseUpdate=u:o.next=u,c.lastBaseUpdate=l))}if(null!==i){var h=r.baseState;for(a=0,c=u=l=null,o=i;;){var d=o.lane,p=o.eventTime;if((s&d)===d){null!==c&&(c=c.next={eventTime:p,lane:0,tag:o.tag,payload:o.payload,callback:o.callback,next:null});e:{var f=e,g=o;switch(d=t,p=n,g.tag){case 1:if("function"===typeof(f=g.payload)){h=f.call(p,h,d);break e}h=f;break e;case 3:f.flags=-65537&f.flags|128;case 0:if(null===(d="function"===typeof(f=g.payload)?f.call(p,h,d):f)||void 0===d)break e;h=L({},h,d);break e;case 2:Mi=!0}}null!==o.callback&&0!==o.lane&&(e.flags|=64,null===(d=r.effects)?r.effects=[o]:d.push(o))}else p={eventTime:p,lane:d,tag:o.tag,payload:o.payload,callback:o.callback,next:null},null===c?(u=c=p,l=h):c=c.next=p,a|=d;if(null===(o=o.next)){if(null===(o=r.shared.pending))break;o=(d=o).next,d.next=null,r.lastBaseUpdate=d,r.shared.pending=null}}if(null===c&&(l=h),r.baseState=l,r.firstBaseUpdate=u,r.lastBaseUpdate=c,null!==(t=r.shared.interleaved)){r=t;do{a|=r.lane,r=r.next}while(r!==t)}else null===i&&(r.shared.lanes=0);Ol|=a,e.lanes=a,e.memoizedState=h}}function Ui(e,t,n){if(e=t.effects,t.effects=null,null!==e)for(t=0;t<e.length;t++){var s=e[t],r=s.callback;if(null!==r){if(s.callback=null,s=n,"function"!==typeof r)throw Error(i(191,r));r.call(s)}}}var Gi={},Hi=Ir(Gi),ji=Ir(Gi),Ki=Ir(Gi);function Xi(e){if(e===Gi)throw Error(i(174));return e}function qi(e,t){switch(Nr(Ki,t),Nr(ji,e),Nr(Hi,Gi),e=t.nodeType){case 9:case 11:t=(t=t.documentElement)?t.namespaceURI:le(null,"");break;default:t=le(t=(e=8===e?t.parentNode:t).namespaceURI||null,e=e.tagName)}Cr(Hi),Nr(Hi,t)}function Yi(){Cr(Hi),Cr(ji),Cr(Ki)}function Qi(e){Xi(Ki.current);var t=Xi(Hi.current),n=le(t,e.type);t!==n&&(Nr(ji,e),Nr(Hi,n))}function Zi(e){ji.current===e&&(Cr(Hi),Cr(ji))}var Ji=Ir(0);function ea(e){for(var t=e;null!==t;){if(13===t.tag){var n=t.memoizedState;if(null!==n&&(null===(n=n.dehydrated)||"$?"===n.data||"$!"===n.data))return t}else if(19===t.tag&&void 0!==t.memoizedProps.revealOrder){if(0!==(128&t.flags))return t}else if(null!==t.child){t.child.return=t,t=t.child;continue}if(t===e)break;for(;null===t.sibling;){if(null===t.return||t.return===e)return null;t=t.return}t.sibling.return=t.return,t=t.sibling}return null}var ta=[];function na(){for(var e=0;e<ta.length;e++)ta[e]._workInProgressVersionPrimary=null;ta.length=0}var sa=v.ReactCurrentDispatcher,ra=v.ReactCurrentBatchConfig,ia=0,aa=null,oa=null,la=null,ua=!1,ca=!1,ha=0,da=0;function pa(){throw Error(i(321))}function fa(e,t){if(null===t)return!1;for(var n=0;n<t.length&&n<e.length;n++)if(!os(e[n],t[n]))return!1;return!0}function ga(e,t,n,s,r,a){if(ia=a,aa=t,t.memoizedState=null,t.updateQueue=null,t.lanes=0,sa.current=null===e||null===e.memoizedState?Za:Ja,e=n(s,r),ca){a=0;do{if(ca=!1,ha=0,25<=a)throw Error(i(301));a+=1,la=oa=null,t.updateQueue=null,sa.current=eo,e=n(s,r)}while(ca)}if(sa.current=Qa,t=null!==oa&&null!==oa.next,ia=0,la=oa=aa=null,ua=!1,t)throw Error(i(300));return e}function ma(){var e=0!==ha;return ha=0,e}function ba(){var e={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return null===la?aa.memoizedState=la=e:la=la.next=e,la}function xa(){if(null===oa){var e=aa.alternate;e=null!==e?e.memoizedState:null}else e=oa.next;var t=null===la?aa.memoizedState:la.next;if(null!==t)la=t,oa=e;else{if(null===e)throw Error(i(310));e={memoizedState:(oa=e).memoizedState,baseState:oa.baseState,baseQueue:oa.baseQueue,queue:oa.queue,next:null},null===la?aa.memoizedState=la=e:la=la.next=e}return la}function ya(e,t){return"function"===typeof t?t(e):t}function va(e){var t=xa(),n=t.queue;if(null===n)throw Error(i(311));n.lastRenderedReducer=e;var s=oa,r=s.baseQueue,a=n.pending;if(null!==a){if(null!==r){var o=r.next;r.next=a.next,a.next=o}s.baseQueue=r=a,n.pending=null}if(null!==r){a=r.next,s=s.baseState;var l=o=null,u=null,c=a;do{var h=c.lane;if((ia&h)===h)null!==u&&(u=u.next={lane:0,action:c.action,hasEagerState:c.hasEagerState,eagerState:c.eagerState,next:null}),s=c.hasEagerState?c.eagerState:e(s,c.action);else{var d={lane:h,action:c.action,hasEagerState:c.hasEagerState,eagerState:c.eagerState,next:null};null===u?(l=u=d,o=s):u=u.next=d,aa.lanes|=h,Ol|=h}c=c.next}while(null!==c&&c!==a);null===u?o=s:u.next=l,os(s,t.memoizedState)||(yo=!0),t.memoizedState=s,t.baseState=o,t.baseQueue=u,n.lastRenderedState=s}if(null!==(e=n.interleaved)){r=e;do{a=r.lane,aa.lanes|=a,Ol|=a,r=r.next}while(r!==e)}else null===r&&(n.lanes=0);return[t.memoizedState,n.dispatch]}function wa(e){var t=xa(),n=t.queue;if(null===n)throw Error(i(311));n.lastRenderedReducer=e;var s=n.dispatch,r=n.pending,a=t.memoizedState;if(null!==r){n.pending=null;var o=r=r.next;do{a=e(a,o.action),o=o.next}while(o!==r);os(a,t.memoizedState)||(yo=!0),t.memoizedState=a,null===t.baseQueue&&(t.baseState=a),n.lastRenderedState=a}return[a,s]}function ka(){}function Sa(e,t){var n=aa,s=xa(),r=t(),a=!os(s.memoizedState,r);if(a&&(s.memoizedState=r,yo=!0),s=s.queue,Ma(Na.bind(null,n,s,e),[e]),s.getSnapshot!==t||a||null!==la&&1&la.memoizedState.tag){if(n.flags|=2048,$a(9,Ca.bind(null,n,s,r,t),void 0,null),null===El)throw Error(i(349));0!==(30&ia)||Ia(n,t,r)}return r}function Ia(e,t,n){e.flags|=16384,e={getSnapshot:t,value:n},null===(t=aa.updateQueue)?(t={lastEffect:null,stores:null},aa.updateQueue=t,t.stores=[e]):null===(n=t.stores)?t.stores=[e]:n.push(e)}function Ca(e,t,n,s){t.value=n,t.getSnapshot=s,Ta(t)&&_a(e)}function Na(e,t,n){return n((function(){Ta(t)&&_a(e)}))}function Ta(e){var t=e.getSnapshot;e=e.value;try{var n=t();return!os(e,n)}catch(s){return!0}}function _a(e){var t=Fi(e,1);null!==t&&nu(t,e,1,-1)}function Ea(e){var t=ba();return"function"===typeof e&&(e=e()),t.memoizedState=t.baseState=e,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:ya,lastRenderedState:e},t.queue=e,e=e.dispatch=Ka.bind(null,aa,e),[t.memoizedState,e]}function $a(e,t,n,s){return e={tag:e,create:t,destroy:n,deps:s,next:null},null===(t=aa.updateQueue)?(t={lastEffect:null,stores:null},aa.updateQueue=t,t.lastEffect=e.next=e):null===(n=t.lastEffect)?t.lastEffect=e.next=e:(s=n.next,n.next=e,e.next=s,t.lastEffect=e),e}function Ra(){return xa().memoizedState}function Aa(e,t,n,s){var r=ba();aa.flags|=e,r.memoizedState=$a(1|t,n,void 0,void 0===s?null:s)}function Da(e,t,n,s){var r=xa();s=void 0===s?null:s;var i=void 0;if(null!==oa){var a=oa.memoizedState;if(i=a.destroy,null!==s&&fa(s,a.deps))return void(r.memoizedState=$a(t,n,i,s))}aa.flags|=e,r.memoizedState=$a(1|t,n,i,s)}function Fa(e,t){return Aa(8390656,8,e,t)}function Ma(e,t){return Da(2048,8,e,t)}function Oa(e,t){return Da(4,2,e,t)}function La(e,t){return Da(4,4,e,t)}function Pa(e,t){return"function"===typeof t?(e=e(),t(e),function(){t(null)}):null!==t&&void 0!==t?(e=e(),t.current=e,function(){t.current=null}):void 0}function za(e,t,n){return n=null!==n&&void 0!==n?n.concat([e]):null,Da(4,4,Pa.bind(null,t,e),n)}function Ba(){}function Wa(e,t){var n=xa();t=void 0===t?null:t;var s=n.memoizedState;return null!==s&&null!==t&&fa(t,s[1])?s[0]:(n.memoizedState=[e,t],e)}function Va(e,t){var n=xa();t=void 0===t?null:t;var s=n.memoizedState;return null!==s&&null!==t&&fa(t,s[1])?s[0]:(e=e(),n.memoizedState=[e,t],e)}function Ua(e,t,n){return 0===(21&ia)?(e.baseState&&(e.baseState=!1,yo=!0),e.memoizedState=n):(os(n,t)||(n=gt(),aa.lanes|=n,Ol|=n,e.baseState=!0),t)}function Ga(e,t){var n=yt;yt=0!==n&&4>n?n:4,e(!0);var s=ra.transition;ra.transition={};try{e(!1),t()}finally{yt=n,ra.transition=s}}function Ha(){return xa().memoizedState}function ja(e,t,n){var s=tu(e);if(n={lane:s,action:n,hasEagerState:!1,eagerState:null,next:null},Xa(e))qa(t,n);else if(null!==(n=Di(e,t,n,s))){nu(n,e,s,eu()),Ya(n,t,s)}}function Ka(e,t,n){var s=tu(e),r={lane:s,action:n,hasEagerState:!1,eagerState:null,next:null};if(Xa(e))qa(t,r);else{var i=e.alternate;if(0===e.lanes&&(null===i||0===i.lanes)&&null!==(i=t.lastRenderedReducer))try{var a=t.lastRenderedState,o=i(a,n);if(r.hasEagerState=!0,r.eagerState=o,os(o,a)){var l=t.interleaved;return null===l?(r.next=r,Ai(t)):(r.next=l.next,l.next=r),void(t.interleaved=r)}}catch(u){}null!==(n=Di(e,t,r,s))&&(nu(n,e,s,r=eu()),Ya(n,t,s))}}function Xa(e){var t=e.alternate;return e===aa||null!==t&&t===aa}function qa(e,t){ca=ua=!0;var n=e.pending;null===n?t.next=t:(t.next=n.next,n.next=t),e.pending=t}function Ya(e,t,n){if(0!==(4194240&n)){var s=t.lanes;n|=s&=e.pendingLanes,t.lanes=n,xt(e,n)}}var Qa={readContext:$i,useCallback:pa,useContext:pa,useEffect:pa,useImperativeHandle:pa,useInsertionEffect:pa,useLayoutEffect:pa,useMemo:pa,useReducer:pa,useRef:pa,useState:pa,useDebugValue:pa,useDeferredValue:pa,useTransition:pa,useMutableSource:pa,useSyncExternalStore:pa,useId:pa,unstable_isNewReconciler:!1},Za={readContext:$i,useCallback:function(e,t){return ba().memoizedState=[e,void 0===t?null:t],e},useContext:$i,useEffect:Fa,useImperativeHandle:function(e,t,n){return n=null!==n&&void 0!==n?n.concat([e]):null,Aa(4194308,4,Pa.bind(null,t,e),n)},useLayoutEffect:function(e,t){return Aa(4194308,4,e,t)},useInsertionEffect:function(e,t){return Aa(4,2,e,t)},useMemo:function(e,t){var n=ba();return t=void 0===t?null:t,e=e(),n.memoizedState=[e,t],e},useReducer:function(e,t,n){var s=ba();return t=void 0!==n?n(t):t,s.memoizedState=s.baseState=t,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:e,lastRenderedState:t},s.queue=e,e=e.dispatch=ja.bind(null,aa,e),[s.memoizedState,e]},useRef:function(e){return e={current:e},ba().memoizedState=e},useState:Ea,useDebugValue:Ba,useDeferredValue:function(e){return ba().memoizedState=e},useTransition:function(){var e=Ea(!1),t=e[0];return e=Ga.bind(null,e[1]),ba().memoizedState=e,[t,e]},useMutableSource:function(){},useSyncExternalStore:function(e,t,n){var s=aa,r=ba();if(ri){if(void 0===n)throw Error(i(407));n=n()}else{if(n=t(),null===El)throw Error(i(349));0!==(30&ia)||Ia(s,t,n)}r.memoizedState=n;var a={value:n,getSnapshot:t};return r.queue=a,Fa(Na.bind(null,s,a,e),[e]),s.flags|=2048,$a(9,Ca.bind(null,s,a,n,t),void 0,null),n},useId:function(){var e=ba(),t=El.identifierPrefix;if(ri){var n=Qr;t=":"+t+"R"+(n=(Yr&~(1<<32-at(Yr)-1)).toString(32)+n),0<(n=ha++)&&(t+="H"+n.toString(32)),t+=":"}else t=":"+t+"r"+(n=da++).toString(32)+":";return e.memoizedState=t},unstable_isNewReconciler:!1},Ja={readContext:$i,useCallback:Wa,useContext:$i,useEffect:Ma,useImperativeHandle:za,useInsertionEffect:Oa,useLayoutEffect:La,useMemo:Va,useReducer:va,useRef:Ra,useState:function(){return va(ya)},useDebugValue:Ba,useDeferredValue:function(e){return Ua(xa(),oa.memoizedState,e)},useTransition:function(){return[va(ya)[0],xa().memoizedState]},useMutableSource:ka,useSyncExternalStore:Sa,useId:Ha,unstable_isNewReconciler:!1},eo={readContext:$i,useCallback:Wa,useContext:$i,useEffect:Ma,useImperativeHandle:za,useInsertionEffect:Oa,useLayoutEffect:La,useMemo:Va,useReducer:wa,useRef:Ra,useState:function(){return wa(ya)},useDebugValue:Ba,useDeferredValue:function(e){var t=xa();return null===oa?t.memoizedState=e:Ua(t,oa.memoizedState,e)},useTransition:function(){return[wa(ya)[0],xa().memoizedState]},useMutableSource:ka,useSyncExternalStore:Sa,useId:Ha,unstable_isNewReconciler:!1};function to(e,t){if(e&&e.defaultProps){for(var n in t=L({},t),e=e.defaultProps)void 0===t[n]&&(t[n]=e[n]);return t}return t}function no(e,t,n,s){n=null===(n=n(s,t=e.memoizedState))||void 0===n?t:L({},t,n),e.memoizedState=n,0===e.lanes&&(e.updateQueue.baseState=n)}var so={isMounted:function(e){return!!(e=e._reactInternals)&&Ve(e)===e},enqueueSetState:function(e,t,n){e=e._reactInternals;var s=eu(),r=tu(e),i=Pi(s,r);i.payload=t,void 0!==n&&null!==n&&(i.callback=n),null!==(t=zi(e,i,r))&&(nu(t,e,r,s),Bi(t,e,r))},enqueueReplaceState:function(e,t,n){e=e._reactInternals;var s=eu(),r=tu(e),i=Pi(s,r);i.tag=1,i.payload=t,void 0!==n&&null!==n&&(i.callback=n),null!==(t=zi(e,i,r))&&(nu(t,e,r,s),Bi(t,e,r))},enqueueForceUpdate:function(e,t){e=e._reactInternals;var n=eu(),s=tu(e),r=Pi(n,s);r.tag=2,void 0!==t&&null!==t&&(r.callback=t),null!==(t=zi(e,r,s))&&(nu(t,e,s,n),Bi(t,e,s))}};function ro(e,t,n,s,r,i,a){return"function"===typeof(e=e.stateNode).shouldComponentUpdate?e.shouldComponentUpdate(s,i,a):!t.prototype||!t.prototype.isPureReactComponent||(!ls(n,s)||!ls(r,i))}function io(e,t,n){var s=!1,r=Tr,i=t.contextType;return"object"===typeof i&&null!==i?i=$i(i):(r=Ar(t)?$r:_r.current,i=(s=null!==(s=t.contextTypes)&&void 0!==s)?Rr(e,r):Tr),t=new t(n,i),e.memoizedState=null!==t.state&&void 0!==t.state?t.state:null,t.updater=so,e.stateNode=t,t._reactInternals=e,s&&((e=e.stateNode).__reactInternalMemoizedUnmaskedChildContext=r,e.__reactInternalMemoizedMaskedChildContext=i),t}function ao(e,t,n,s){e=t.state,"function"===typeof t.componentWillReceiveProps&&t.componentWillReceiveProps(n,s),"function"===typeof t.UNSAFE_componentWillReceiveProps&&t.UNSAFE_componentWillReceiveProps(n,s),t.state!==e&&so.enqueueReplaceState(t,t.state,null)}function oo(e,t,n,s){var r=e.stateNode;r.props=n,r.state=e.memoizedState,r.refs={},Oi(e);var i=t.contextType;"object"===typeof i&&null!==i?r.context=$i(i):(i=Ar(t)?$r:_r.current,r.context=Rr(e,i)),r.state=e.memoizedState,"function"===typeof(i=t.getDerivedStateFromProps)&&(no(e,t,i,n),r.state=e.memoizedState),"function"===typeof t.getDerivedStateFromProps||"function"===typeof r.getSnapshotBeforeUpdate||"function"!==typeof r.UNSAFE_componentWillMount&&"function"!==typeof r.componentWillMount||(t=r.state,"function"===typeof r.componentWillMount&&r.componentWillMount(),"function"===typeof r.UNSAFE_componentWillMount&&r.UNSAFE_componentWillMount(),t!==r.state&&so.enqueueReplaceState(r,r.state,null),Vi(e,n,r,s),r.state=e.memoizedState),"function"===typeof r.componentDidMount&&(e.flags|=4194308)}function lo(e,t){try{var n="",s=t;do{n+=W(s),s=s.return}while(s);var r=n}catch(i){r="\nError generating stack: "+i.message+"\n"+i.stack}return{value:e,source:t,stack:r,digest:null}}function uo(e,t,n){return{value:e,source:null,stack:null!=n?n:null,digest:null!=t?t:null}}function co(e,t){try{console.error(t.value)}catch(n){setTimeout((function(){throw n}))}}var ho="function"===typeof WeakMap?WeakMap:Map;function po(e,t,n){(n=Pi(-1,n)).tag=3,n.payload={element:null};var s=t.value;return n.callback=function(){Gl||(Gl=!0,Hl=s),co(0,t)},n}function fo(e,t,n){(n=Pi(-1,n)).tag=3;var s=e.type.getDerivedStateFromError;if("function"===typeof s){var r=t.value;n.payload=function(){return s(r)},n.callback=function(){co(0,t)}}var i=e.stateNode;return null!==i&&"function"===typeof i.componentDidCatch&&(n.callback=function(){co(0,t),"function"!==typeof s&&(null===jl?jl=new Set([this]):jl.add(this));var e=t.stack;this.componentDidCatch(t.value,{componentStack:null!==e?e:""})}),n}function go(e,t,n){var s=e.pingCache;if(null===s){s=e.pingCache=new ho;var r=new Set;s.set(t,r)}else void 0===(r=s.get(t))&&(r=new Set,s.set(t,r));r.has(n)||(r.add(n),e=Cu.bind(null,e,t,n),t.then(e,e))}function mo(e){do{var t;if((t=13===e.tag)&&(t=null===(t=e.memoizedState)||null!==t.dehydrated),t)return e;e=e.return}while(null!==e);return null}function bo(e,t,n,s,r){return 0===(1&e.mode)?(e===t?e.flags|=65536:(e.flags|=128,n.flags|=131072,n.flags&=-52805,1===n.tag&&(null===n.alternate?n.tag=17:((t=Pi(-1,1)).tag=2,zi(n,t,1))),n.lanes|=1),e):(e.flags|=65536,e.lanes=r,e)}var xo=v.ReactCurrentOwner,yo=!1;function vo(e,t,n,s){t.child=null===e?wi(t,null,n,s):vi(t,e.child,n,s)}function wo(e,t,n,s,r){n=n.render;var i=t.ref;return Ei(t,r),s=ga(e,t,n,s,i,r),n=ma(),null===e||yo?(ri&&n&&ei(t),t.flags|=1,vo(e,t,s,r),t.child):(t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~r,Go(e,t,r))}function ko(e,t,n,s,r){if(null===e){var i=n.type;return"function"!==typeof i||Au(i)||void 0!==i.defaultProps||null!==n.compare||void 0!==n.defaultProps?((e=Fu(n.type,null,s,t,t.mode,r)).ref=t.ref,e.return=t,t.child=e):(t.tag=15,t.type=i,So(e,t,i,s,r))}if(i=e.child,0===(e.lanes&r)){var a=i.memoizedProps;if((n=null!==(n=n.compare)?n:ls)(a,s)&&e.ref===t.ref)return Go(e,t,r)}return t.flags|=1,(e=Du(i,s)).ref=t.ref,e.return=t,t.child=e}function So(e,t,n,s,r){if(null!==e){var i=e.memoizedProps;if(ls(i,s)&&e.ref===t.ref){if(yo=!1,t.pendingProps=s=i,0===(e.lanes&r))return t.lanes=e.lanes,Go(e,t,r);0!==(131072&e.flags)&&(yo=!0)}}return No(e,t,n,s,r)}function Io(e,t,n){var s=t.pendingProps,r=s.children,i=null!==e?e.memoizedState:null;if("hidden"===s.mode)if(0===(1&t.mode))t.memoizedState={baseLanes:0,cachePool:null,transitions:null},Nr(Dl,Al),Al|=n;else{if(0===(1073741824&n))return e=null!==i?i.baseLanes|n:n,t.lanes=t.childLanes=1073741824,t.memoizedState={baseLanes:e,cachePool:null,transitions:null},t.updateQueue=null,Nr(Dl,Al),Al|=e,null;t.memoizedState={baseLanes:0,cachePool:null,transitions:null},s=null!==i?i.baseLanes:n,Nr(Dl,Al),Al|=s}else null!==i?(s=i.baseLanes|n,t.memoizedState=null):s=n,Nr(Dl,Al),Al|=s;return vo(e,t,r,n),t.child}function Co(e,t){var n=t.ref;(null===e&&null!==n||null!==e&&e.ref!==n)&&(t.flags|=512,t.flags|=2097152)}function No(e,t,n,s,r){var i=Ar(n)?$r:_r.current;return i=Rr(t,i),Ei(t,r),n=ga(e,t,n,s,i,r),s=ma(),null===e||yo?(ri&&s&&ei(t),t.flags|=1,vo(e,t,n,r),t.child):(t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~r,Go(e,t,r))}function To(e,t,n,s,r){if(Ar(n)){var i=!0;Or(t)}else i=!1;if(Ei(t,r),null===t.stateNode)Uo(e,t),io(t,n,s),oo(t,n,s,r),s=!0;else if(null===e){var a=t.stateNode,o=t.memoizedProps;a.props=o;var l=a.context,u=n.contextType;"object"===typeof u&&null!==u?u=$i(u):u=Rr(t,u=Ar(n)?$r:_r.current);var c=n.getDerivedStateFromProps,h="function"===typeof c||"function"===typeof a.getSnapshotBeforeUpdate;h||"function"!==typeof a.UNSAFE_componentWillReceiveProps&&"function"!==typeof a.componentWillReceiveProps||(o!==s||l!==u)&&ao(t,a,s,u),Mi=!1;var d=t.memoizedState;a.state=d,Vi(t,s,a,r),l=t.memoizedState,o!==s||d!==l||Er.current||Mi?("function"===typeof c&&(no(t,n,c,s),l=t.memoizedState),(o=Mi||ro(t,n,o,s,d,l,u))?(h||"function"!==typeof a.UNSAFE_componentWillMount&&"function"!==typeof a.componentWillMount||("function"===typeof a.componentWillMount&&a.componentWillMount(),"function"===typeof a.UNSAFE_componentWillMount&&a.UNSAFE_componentWillMount()),"function"===typeof a.componentDidMount&&(t.flags|=4194308)):("function"===typeof a.componentDidMount&&(t.flags|=4194308),t.memoizedProps=s,t.memoizedState=l),a.props=s,a.state=l,a.context=u,s=o):("function"===typeof a.componentDidMount&&(t.flags|=4194308),s=!1)}else{a=t.stateNode,Li(e,t),o=t.memoizedProps,u=t.type===t.elementType?o:to(t.type,o),a.props=u,h=t.pendingProps,d=a.context,"object"===typeof(l=n.contextType)&&null!==l?l=$i(l):l=Rr(t,l=Ar(n)?$r:_r.current);var p=n.getDerivedStateFromProps;(c="function"===typeof p||"function"===typeof a.getSnapshotBeforeUpdate)||"function"!==typeof a.UNSAFE_componentWillReceiveProps&&"function"!==typeof a.componentWillReceiveProps||(o!==h||d!==l)&&ao(t,a,s,l),Mi=!1,d=t.memoizedState,a.state=d,Vi(t,s,a,r);var f=t.memoizedState;o!==h||d!==f||Er.current||Mi?("function"===typeof p&&(no(t,n,p,s),f=t.memoizedState),(u=Mi||ro(t,n,u,s,d,f,l)||!1)?(c||"function"!==typeof a.UNSAFE_componentWillUpdate&&"function"!==typeof a.componentWillUpdate||("function"===typeof a.componentWillUpdate&&a.componentWillUpdate(s,f,l),"function"===typeof a.UNSAFE_componentWillUpdate&&a.UNSAFE_componentWillUpdate(s,f,l)),"function"===typeof a.componentDidUpdate&&(t.flags|=4),"function"===typeof a.getSnapshotBeforeUpdate&&(t.flags|=1024)):("function"!==typeof a.componentDidUpdate||o===e.memoizedProps&&d===e.memoizedState||(t.flags|=4),"function"!==typeof a.getSnapshotBeforeUpdate||o===e.memoizedProps&&d===e.memoizedState||(t.flags|=1024),t.memoizedProps=s,t.memoizedState=f),a.props=s,a.state=f,a.context=l,s=u):("function"!==typeof a.componentDidUpdate||o===e.memoizedProps&&d===e.memoizedState||(t.flags|=4),"function"!==typeof a.getSnapshotBeforeUpdate||o===e.memoizedProps&&d===e.memoizedState||(t.flags|=1024),s=!1)}return _o(e,t,n,s,i,r)}function _o(e,t,n,s,r,i){Co(e,t);var a=0!==(128&t.flags);if(!s&&!a)return r&&Lr(t,n,!1),Go(e,t,i);s=t.stateNode,xo.current=t;var o=a&&"function"!==typeof n.getDerivedStateFromError?null:s.render();return t.flags|=1,null!==e&&a?(t.child=vi(t,e.child,null,i),t.child=vi(t,null,o,i)):vo(e,t,o,i),t.memoizedState=s.state,r&&Lr(t,n,!0),t.child}function Eo(e){var t=e.stateNode;t.pendingContext?Fr(0,t.pendingContext,t.pendingContext!==t.context):t.context&&Fr(0,t.context,!1),qi(e,t.containerInfo)}function $o(e,t,n,s,r){return pi(),fi(r),t.flags|=256,vo(e,t,n,s),t.child}var Ro,Ao,Do,Fo,Mo={dehydrated:null,treeContext:null,retryLane:0};function Oo(e){return{baseLanes:e,cachePool:null,transitions:null}}function Lo(e,t,n){var s,r=t.pendingProps,a=Ji.current,o=!1,l=0!==(128&t.flags);if((s=l)||(s=(null===e||null!==e.memoizedState)&&0!==(2&a)),s?(o=!0,t.flags&=-129):null!==e&&null===e.memoizedState||(a|=1),Nr(Ji,1&a),null===e)return ui(t),null!==(e=t.memoizedState)&&null!==(e=e.dehydrated)?(0===(1&t.mode)?t.lanes=1:"$!"===e.data?t.lanes=8:t.lanes=1073741824,null):(l=r.children,e=r.fallback,o?(r=t.mode,o=t.child,l={mode:"hidden",children:l},0===(1&r)&&null!==o?(o.childLanes=0,o.pendingProps=l):o=Ou(l,r,0,null),e=Mu(e,r,n,null),o.return=t,e.return=t,o.sibling=e,t.child=o,t.child.memoizedState=Oo(n),t.memoizedState=Mo,e):Po(t,l));if(null!==(a=e.memoizedState)&&null!==(s=a.dehydrated))return function(e,t,n,s,r,a,o){if(n)return 256&t.flags?(t.flags&=-257,zo(e,t,o,s=uo(Error(i(422))))):null!==t.memoizedState?(t.child=e.child,t.flags|=128,null):(a=s.fallback,r=t.mode,s=Ou({mode:"visible",children:s.children},r,0,null),(a=Mu(a,r,o,null)).flags|=2,s.return=t,a.return=t,s.sibling=a,t.child=s,0!==(1&t.mode)&&vi(t,e.child,null,o),t.child.memoizedState=Oo(o),t.memoizedState=Mo,a);if(0===(1&t.mode))return zo(e,t,o,null);if("$!"===r.data){if(s=r.nextSibling&&r.nextSibling.dataset)var l=s.dgst;return s=l,zo(e,t,o,s=uo(a=Error(i(419)),s,void 0))}if(l=0!==(o&e.childLanes),yo||l){if(null!==(s=El)){switch(o&-o){case 4:r=2;break;case 16:r=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:r=32;break;case 536870912:r=268435456;break;default:r=0}0!==(r=0!==(r&(s.suspendedLanes|o))?0:r)&&r!==a.retryLane&&(a.retryLane=r,Fi(e,r),nu(s,e,r,-1))}return gu(),zo(e,t,o,s=uo(Error(i(421))))}return"$?"===r.data?(t.flags|=128,t.child=e.child,t=Tu.bind(null,e),r._reactRetry=t,null):(e=a.treeContext,si=ur(r.nextSibling),ni=t,ri=!0,ii=null,null!==e&&(Kr[Xr++]=Yr,Kr[Xr++]=Qr,Kr[Xr++]=qr,Yr=e.id,Qr=e.overflow,qr=t),t=Po(t,s.children),t.flags|=4096,t)}(e,t,l,r,s,a,n);if(o){o=r.fallback,l=t.mode,s=(a=e.child).sibling;var u={mode:"hidden",children:r.children};return 0===(1&l)&&t.child!==a?((r=t.child).childLanes=0,r.pendingProps=u,t.deletions=null):(r=Du(a,u)).subtreeFlags=14680064&a.subtreeFlags,null!==s?o=Du(s,o):(o=Mu(o,l,n,null)).flags|=2,o.return=t,r.return=t,r.sibling=o,t.child=r,r=o,o=t.child,l=null===(l=e.child.memoizedState)?Oo(n):{baseLanes:l.baseLanes|n,cachePool:null,transitions:l.transitions},o.memoizedState=l,o.childLanes=e.childLanes&~n,t.memoizedState=Mo,r}return e=(o=e.child).sibling,r=Du(o,{mode:"visible",children:r.children}),0===(1&t.mode)&&(r.lanes=n),r.return=t,r.sibling=null,null!==e&&(null===(n=t.deletions)?(t.deletions=[e],t.flags|=16):n.push(e)),t.child=r,t.memoizedState=null,r}function Po(e,t){return(t=Ou({mode:"visible",children:t},e.mode,0,null)).return=e,e.child=t}function zo(e,t,n,s){return null!==s&&fi(s),vi(t,e.child,null,n),(e=Po(t,t.pendingProps.children)).flags|=2,t.memoizedState=null,e}function Bo(e,t,n){e.lanes|=t;var s=e.alternate;null!==s&&(s.lanes|=t),_i(e.return,t,n)}function Wo(e,t,n,s,r){var i=e.memoizedState;null===i?e.memoizedState={isBackwards:t,rendering:null,renderingStartTime:0,last:s,tail:n,tailMode:r}:(i.isBackwards=t,i.rendering=null,i.renderingStartTime=0,i.last=s,i.tail=n,i.tailMode=r)}function Vo(e,t,n){var s=t.pendingProps,r=s.revealOrder,i=s.tail;if(vo(e,t,s.children,n),0!==(2&(s=Ji.current)))s=1&s|2,t.flags|=128;else{if(null!==e&&0!==(128&e.flags))e:for(e=t.child;null!==e;){if(13===e.tag)null!==e.memoizedState&&Bo(e,n,t);else if(19===e.tag)Bo(e,n,t);else if(null!==e.child){e.child.return=e,e=e.child;continue}if(e===t)break e;for(;null===e.sibling;){if(null===e.return||e.return===t)break e;e=e.return}e.sibling.return=e.return,e=e.sibling}s&=1}if(Nr(Ji,s),0===(1&t.mode))t.memoizedState=null;else switch(r){case"forwards":for(n=t.child,r=null;null!==n;)null!==(e=n.alternate)&&null===ea(e)&&(r=n),n=n.sibling;null===(n=r)?(r=t.child,t.child=null):(r=n.sibling,n.sibling=null),Wo(t,!1,r,n,i);break;case"backwards":for(n=null,r=t.child,t.child=null;null!==r;){if(null!==(e=r.alternate)&&null===ea(e)){t.child=r;break}e=r.sibling,r.sibling=n,n=r,r=e}Wo(t,!0,n,null,i);break;case"together":Wo(t,!1,null,null,void 0);break;default:t.memoizedState=null}return t.child}function Uo(e,t){0===(1&t.mode)&&null!==e&&(e.alternate=null,t.alternate=null,t.flags|=2)}function Go(e,t,n){if(null!==e&&(t.dependencies=e.dependencies),Ol|=t.lanes,0===(n&t.childLanes))return null;if(null!==e&&t.child!==e.child)throw Error(i(153));if(null!==t.child){for(n=Du(e=t.child,e.pendingProps),t.child=n,n.return=t;null!==e.sibling;)e=e.sibling,(n=n.sibling=Du(e,e.pendingProps)).return=t;n.sibling=null}return t.child}function Ho(e,t){if(!ri)switch(e.tailMode){case"hidden":t=e.tail;for(var n=null;null!==t;)null!==t.alternate&&(n=t),t=t.sibling;null===n?e.tail=null:n.sibling=null;break;case"collapsed":n=e.tail;for(var s=null;null!==n;)null!==n.alternate&&(s=n),n=n.sibling;null===s?t||null===e.tail?e.tail=null:e.tail.sibling=null:s.sibling=null}}function jo(e){var t=null!==e.alternate&&e.alternate.child===e.child,n=0,s=0;if(t)for(var r=e.child;null!==r;)n|=r.lanes|r.childLanes,s|=14680064&r.subtreeFlags,s|=14680064&r.flags,r.return=e,r=r.sibling;else for(r=e.child;null!==r;)n|=r.lanes|r.childLanes,s|=r.subtreeFlags,s|=r.flags,r.return=e,r=r.sibling;return e.subtreeFlags|=s,e.childLanes=n,t}function Ko(e,t,n){var s=t.pendingProps;switch(ti(t),t.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return jo(t),null;case 1:case 17:return Ar(t.type)&&Dr(),jo(t),null;case 3:return s=t.stateNode,Yi(),Cr(Er),Cr(_r),na(),s.pendingContext&&(s.context=s.pendingContext,s.pendingContext=null),null!==e&&null!==e.child||(hi(t)?t.flags|=4:null===e||e.memoizedState.isDehydrated&&0===(256&t.flags)||(t.flags|=1024,null!==ii&&(au(ii),ii=null))),Ao(e,t),jo(t),null;case 5:Zi(t);var r=Xi(Ki.current);if(n=t.type,null!==e&&null!=t.stateNode)Do(e,t,n,s,r),e.ref!==t.ref&&(t.flags|=512,t.flags|=2097152);else{if(!s){if(null===t.stateNode)throw Error(i(166));return jo(t),null}if(e=Xi(Hi.current),hi(t)){s=t.stateNode,n=t.type;var a=t.memoizedProps;switch(s[dr]=t,s[pr]=a,e=0!==(1&t.mode),n){case"dialog":zs("cancel",s),zs("close",s);break;case"iframe":case"object":case"embed":zs("load",s);break;case"video":case"audio":for(r=0;r<Ms.length;r++)zs(Ms[r],s);break;case"source":zs("error",s);break;case"img":case"image":case"link":zs("error",s),zs("load",s);break;case"details":zs("toggle",s);break;case"input":Y(s,a),zs("invalid",s);break;case"select":s._wrapperState={wasMultiple:!!a.multiple},zs("invalid",s);break;case"textarea":re(s,a),zs("invalid",s)}for(var l in xe(n,a),r=null,a)if(a.hasOwnProperty(l)){var u=a[l];"children"===l?"string"===typeof u?s.textContent!==u&&(!0!==a.suppressHydrationWarning&&Zs(s.textContent,u,e),r=["children",u]):"number"===typeof u&&s.textContent!==""+u&&(!0!==a.suppressHydrationWarning&&Zs(s.textContent,u,e),r=["children",""+u]):o.hasOwnProperty(l)&&null!=u&&"onScroll"===l&&zs("scroll",s)}switch(n){case"input":j(s),J(s,a,!0);break;case"textarea":j(s),ae(s);break;case"select":case"option":break;default:"function"===typeof a.onClick&&(s.onclick=Js)}s=r,t.updateQueue=s,null!==s&&(t.flags|=4)}else{l=9===r.nodeType?r:r.ownerDocument,"http://www.w3.org/1999/xhtml"===e&&(e=oe(n)),"http://www.w3.org/1999/xhtml"===e?"script"===n?((e=l.createElement("div")).innerHTML="<script><\/script>",e=e.removeChild(e.firstChild)):"string"===typeof s.is?e=l.createElement(n,{is:s.is}):(e=l.createElement(n),"select"===n&&(l=e,s.multiple?l.multiple=!0:s.size&&(l.size=s.size))):e=l.createElementNS(e,n),e[dr]=t,e[pr]=s,Ro(e,t,!1,!1),t.stateNode=e;e:{switch(l=ye(n,s),n){case"dialog":zs("cancel",e),zs("close",e),r=s;break;case"iframe":case"object":case"embed":zs("load",e),r=s;break;case"video":case"audio":for(r=0;r<Ms.length;r++)zs(Ms[r],e);r=s;break;case"source":zs("error",e),r=s;break;case"img":case"image":case"link":zs("error",e),zs("load",e),r=s;break;case"details":zs("toggle",e),r=s;break;case"input":Y(e,s),r=q(e,s),zs("invalid",e);break;case"option":default:r=s;break;case"select":e._wrapperState={wasMultiple:!!s.multiple},r=L({},s,{value:void 0}),zs("invalid",e);break;case"textarea":re(e,s),r=se(e,s),zs("invalid",e)}for(a in xe(n,r),u=r)if(u.hasOwnProperty(a)){var c=u[a];"style"===a?me(e,c):"dangerouslySetInnerHTML"===a?null!=(c=c?c.__html:void 0)&&he(e,c):"children"===a?"string"===typeof c?("textarea"!==n||""!==c)&&de(e,c):"number"===typeof c&&de(e,""+c):"suppressContentEditableWarning"!==a&&"suppressHydrationWarning"!==a&&"autoFocus"!==a&&(o.hasOwnProperty(a)?null!=c&&"onScroll"===a&&zs("scroll",e):null!=c&&y(e,a,c,l))}switch(n){case"input":j(e),J(e,s,!1);break;case"textarea":j(e),ae(e);break;case"option":null!=s.value&&e.setAttribute("value",""+G(s.value));break;case"select":e.multiple=!!s.multiple,null!=(a=s.value)?ne(e,!!s.multiple,a,!1):null!=s.defaultValue&&ne(e,!!s.multiple,s.defaultValue,!0);break;default:"function"===typeof r.onClick&&(e.onclick=Js)}switch(n){case"button":case"input":case"select":case"textarea":s=!!s.autoFocus;break e;case"img":s=!0;break e;default:s=!1}}s&&(t.flags|=4)}null!==t.ref&&(t.flags|=512,t.flags|=2097152)}return jo(t),null;case 6:if(e&&null!=t.stateNode)Fo(e,t,e.memoizedProps,s);else{if("string"!==typeof s&&null===t.stateNode)throw Error(i(166));if(n=Xi(Ki.current),Xi(Hi.current),hi(t)){if(s=t.stateNode,n=t.memoizedProps,s[dr]=t,(a=s.nodeValue!==n)&&null!==(e=ni))switch(e.tag){case 3:Zs(s.nodeValue,n,0!==(1&e.mode));break;case 5:!0!==e.memoizedProps.suppressHydrationWarning&&Zs(s.nodeValue,n,0!==(1&e.mode))}a&&(t.flags|=4)}else(s=(9===n.nodeType?n:n.ownerDocument).createTextNode(s))[dr]=t,t.stateNode=s}return jo(t),null;case 13:if(Cr(Ji),s=t.memoizedState,null===e||null!==e.memoizedState&&null!==e.memoizedState.dehydrated){if(ri&&null!==si&&0!==(1&t.mode)&&0===(128&t.flags))di(),pi(),t.flags|=98560,a=!1;else if(a=hi(t),null!==s&&null!==s.dehydrated){if(null===e){if(!a)throw Error(i(318));if(!(a=null!==(a=t.memoizedState)?a.dehydrated:null))throw Error(i(317));a[dr]=t}else pi(),0===(128&t.flags)&&(t.memoizedState=null),t.flags|=4;jo(t),a=!1}else null!==ii&&(au(ii),ii=null),a=!0;if(!a)return 65536&t.flags?t:null}return 0!==(128&t.flags)?(t.lanes=n,t):((s=null!==s)!==(null!==e&&null!==e.memoizedState)&&s&&(t.child.flags|=8192,0!==(1&t.mode)&&(null===e||0!==(1&Ji.current)?0===Fl&&(Fl=3):gu())),null!==t.updateQueue&&(t.flags|=4),jo(t),null);case 4:return Yi(),Ao(e,t),null===e&&Vs(t.stateNode.containerInfo),jo(t),null;case 10:return Ti(t.type._context),jo(t),null;case 19:if(Cr(Ji),null===(a=t.memoizedState))return jo(t),null;if(s=0!==(128&t.flags),null===(l=a.rendering))if(s)Ho(a,!1);else{if(0!==Fl||null!==e&&0!==(128&e.flags))for(e=t.child;null!==e;){if(null!==(l=ea(e))){for(t.flags|=128,Ho(a,!1),null!==(s=l.updateQueue)&&(t.updateQueue=s,t.flags|=4),t.subtreeFlags=0,s=n,n=t.child;null!==n;)e=s,(a=n).flags&=14680066,null===(l=a.alternate)?(a.childLanes=0,a.lanes=e,a.child=null,a.subtreeFlags=0,a.memoizedProps=null,a.memoizedState=null,a.updateQueue=null,a.dependencies=null,a.stateNode=null):(a.childLanes=l.childLanes,a.lanes=l.lanes,a.child=l.child,a.subtreeFlags=0,a.deletions=null,a.memoizedProps=l.memoizedProps,a.memoizedState=l.memoizedState,a.updateQueue=l.updateQueue,a.type=l.type,e=l.dependencies,a.dependencies=null===e?null:{lanes:e.lanes,firstContext:e.firstContext}),n=n.sibling;return Nr(Ji,1&Ji.current|2),t.child}e=e.sibling}null!==a.tail&&Qe()>Vl&&(t.flags|=128,s=!0,Ho(a,!1),t.lanes=4194304)}else{if(!s)if(null!==(e=ea(l))){if(t.flags|=128,s=!0,null!==(n=e.updateQueue)&&(t.updateQueue=n,t.flags|=4),Ho(a,!0),null===a.tail&&"hidden"===a.tailMode&&!l.alternate&&!ri)return jo(t),null}else 2*Qe()-a.renderingStartTime>Vl&&1073741824!==n&&(t.flags|=128,s=!0,Ho(a,!1),t.lanes=4194304);a.isBackwards?(l.sibling=t.child,t.child=l):(null!==(n=a.last)?n.sibling=l:t.child=l,a.last=l)}return null!==a.tail?(t=a.tail,a.rendering=t,a.tail=t.sibling,a.renderingStartTime=Qe(),t.sibling=null,n=Ji.current,Nr(Ji,s?1&n|2:1&n),t):(jo(t),null);case 22:case 23:return hu(),s=null!==t.memoizedState,null!==e&&null!==e.memoizedState!==s&&(t.flags|=8192),s&&0!==(1&t.mode)?0!==(1073741824&Al)&&(jo(t),6&t.subtreeFlags&&(t.flags|=8192)):jo(t),null;case 24:case 25:return null}throw Error(i(156,t.tag))}function Xo(e,t){switch(ti(t),t.tag){case 1:return Ar(t.type)&&Dr(),65536&(e=t.flags)?(t.flags=-65537&e|128,t):null;case 3:return Yi(),Cr(Er),Cr(_r),na(),0!==(65536&(e=t.flags))&&0===(128&e)?(t.flags=-65537&e|128,t):null;case 5:return Zi(t),null;case 13:if(Cr(Ji),null!==(e=t.memoizedState)&&null!==e.dehydrated){if(null===t.alternate)throw Error(i(340));pi()}return 65536&(e=t.flags)?(t.flags=-65537&e|128,t):null;case 19:return Cr(Ji),null;case 4:return Yi(),null;case 10:return Ti(t.type._context),null;case 22:case 23:return hu(),null;default:return null}}Ro=function(e,t){for(var n=t.child;null!==n;){if(5===n.tag||6===n.tag)e.appendChild(n.stateNode);else if(4!==n.tag&&null!==n.child){n.child.return=n,n=n.child;continue}if(n===t)break;for(;null===n.sibling;){if(null===n.return||n.return===t)return;n=n.return}n.sibling.return=n.return,n=n.sibling}},Ao=function(){},Do=function(e,t,n,s){var r=e.memoizedProps;if(r!==s){e=t.stateNode,Xi(Hi.current);var i,a=null;switch(n){case"input":r=q(e,r),s=q(e,s),a=[];break;case"select":r=L({},r,{value:void 0}),s=L({},s,{value:void 0}),a=[];break;case"textarea":r=se(e,r),s=se(e,s),a=[];break;default:"function"!==typeof r.onClick&&"function"===typeof s.onClick&&(e.onclick=Js)}for(c in xe(n,s),n=null,r)if(!s.hasOwnProperty(c)&&r.hasOwnProperty(c)&&null!=r[c])if("style"===c){var l=r[c];for(i in l)l.hasOwnProperty(i)&&(n||(n={}),n[i]="")}else"dangerouslySetInnerHTML"!==c&&"children"!==c&&"suppressContentEditableWarning"!==c&&"suppressHydrationWarning"!==c&&"autoFocus"!==c&&(o.hasOwnProperty(c)?a||(a=[]):(a=a||[]).push(c,null));for(c in s){var u=s[c];if(l=null!=r?r[c]:void 0,s.hasOwnProperty(c)&&u!==l&&(null!=u||null!=l))if("style"===c)if(l){for(i in l)!l.hasOwnProperty(i)||u&&u.hasOwnProperty(i)||(n||(n={}),n[i]="");for(i in u)u.hasOwnProperty(i)&&l[i]!==u[i]&&(n||(n={}),n[i]=u[i])}else n||(a||(a=[]),a.push(c,n)),n=u;else"dangerouslySetInnerHTML"===c?(u=u?u.__html:void 0,l=l?l.__html:void 0,null!=u&&l!==u&&(a=a||[]).push(c,u)):"children"===c?"string"!==typeof u&&"number"!==typeof u||(a=a||[]).push(c,""+u):"suppressContentEditableWarning"!==c&&"suppressHydrationWarning"!==c&&(o.hasOwnProperty(c)?(null!=u&&"onScroll"===c&&zs("scroll",e),a||l===u||(a=[])):(a=a||[]).push(c,u))}n&&(a=a||[]).push("style",n);var c=a;(t.updateQueue=c)&&(t.flags|=4)}},Fo=function(e,t,n,s){n!==s&&(t.flags|=4)};var qo=!1,Yo=!1,Qo="function"===typeof WeakSet?WeakSet:Set,Zo=null;function Jo(e,t){var n=e.ref;if(null!==n)if("function"===typeof n)try{n(null)}catch(s){Iu(e,t,s)}else n.current=null}function el(e,t,n){try{n()}catch(s){Iu(e,t,s)}}var tl=!1;function nl(e,t,n){var s=t.updateQueue;if(null!==(s=null!==s?s.lastEffect:null)){var r=s=s.next;do{if((r.tag&e)===e){var i=r.destroy;r.destroy=void 0,void 0!==i&&el(t,n,i)}r=r.next}while(r!==s)}}function sl(e,t){if(null!==(t=null!==(t=t.updateQueue)?t.lastEffect:null)){var n=t=t.next;do{if((n.tag&e)===e){var s=n.create;n.destroy=s()}n=n.next}while(n!==t)}}function rl(e){var t=e.ref;if(null!==t){var n=e.stateNode;e.tag,e=n,"function"===typeof t?t(e):t.current=e}}function il(e){var t=e.alternate;null!==t&&(e.alternate=null,il(t)),e.child=null,e.deletions=null,e.sibling=null,5===e.tag&&(null!==(t=e.stateNode)&&(delete t[dr],delete t[pr],delete t[gr],delete t[mr],delete t[br])),e.stateNode=null,e.return=null,e.dependencies=null,e.memoizedProps=null,e.memoizedState=null,e.pendingProps=null,e.stateNode=null,e.updateQueue=null}function al(e){return 5===e.tag||3===e.tag||4===e.tag}function ol(e){e:for(;;){for(;null===e.sibling;){if(null===e.return||al(e.return))return null;e=e.return}for(e.sibling.return=e.return,e=e.sibling;5!==e.tag&&6!==e.tag&&18!==e.tag;){if(2&e.flags)continue e;if(null===e.child||4===e.tag)continue e;e.child.return=e,e=e.child}if(!(2&e.flags))return e.stateNode}}function ll(e,t,n){var s=e.tag;if(5===s||6===s)e=e.stateNode,t?8===n.nodeType?n.parentNode.insertBefore(e,t):n.insertBefore(e,t):(8===n.nodeType?(t=n.parentNode).insertBefore(e,n):(t=n).appendChild(e),null!==(n=n._reactRootContainer)&&void 0!==n||null!==t.onclick||(t.onclick=Js));else if(4!==s&&null!==(e=e.child))for(ll(e,t,n),e=e.sibling;null!==e;)ll(e,t,n),e=e.sibling}function ul(e,t,n){var s=e.tag;if(5===s||6===s)e=e.stateNode,t?n.insertBefore(e,t):n.appendChild(e);else if(4!==s&&null!==(e=e.child))for(ul(e,t,n),e=e.sibling;null!==e;)ul(e,t,n),e=e.sibling}var cl=null,hl=!1;function dl(e,t,n){for(n=n.child;null!==n;)pl(e,t,n),n=n.sibling}function pl(e,t,n){if(it&&"function"===typeof it.onCommitFiberUnmount)try{it.onCommitFiberUnmount(rt,n)}catch(o){}switch(n.tag){case 5:Yo||Jo(n,t);case 6:var s=cl,r=hl;cl=null,dl(e,t,n),hl=r,null!==(cl=s)&&(hl?(e=cl,n=n.stateNode,8===e.nodeType?e.parentNode.removeChild(n):e.removeChild(n)):cl.removeChild(n.stateNode));break;case 18:null!==cl&&(hl?(e=cl,n=n.stateNode,8===e.nodeType?lr(e.parentNode,n):1===e.nodeType&&lr(e,n),Vt(e)):lr(cl,n.stateNode));break;case 4:s=cl,r=hl,cl=n.stateNode.containerInfo,hl=!0,dl(e,t,n),cl=s,hl=r;break;case 0:case 11:case 14:case 15:if(!Yo&&(null!==(s=n.updateQueue)&&null!==(s=s.lastEffect))){r=s=s.next;do{var i=r,a=i.destroy;i=i.tag,void 0!==a&&(0!==(2&i)||0!==(4&i))&&el(n,t,a),r=r.next}while(r!==s)}dl(e,t,n);break;case 1:if(!Yo&&(Jo(n,t),"function"===typeof(s=n.stateNode).componentWillUnmount))try{s.props=n.memoizedProps,s.state=n.memoizedState,s.componentWillUnmount()}catch(o){Iu(n,t,o)}dl(e,t,n);break;case 21:dl(e,t,n);break;case 22:1&n.mode?(Yo=(s=Yo)||null!==n.memoizedState,dl(e,t,n),Yo=s):dl(e,t,n);break;default:dl(e,t,n)}}function fl(e){var t=e.updateQueue;if(null!==t){e.updateQueue=null;var n=e.stateNode;null===n&&(n=e.stateNode=new Qo),t.forEach((function(t){var s=_u.bind(null,e,t);n.has(t)||(n.add(t),t.then(s,s))}))}}function gl(e,t){var n=t.deletions;if(null!==n)for(var s=0;s<n.length;s++){var r=n[s];try{var a=e,o=t,l=o;e:for(;null!==l;){switch(l.tag){case 5:cl=l.stateNode,hl=!1;break e;case 3:case 4:cl=l.stateNode.containerInfo,hl=!0;break e}l=l.return}if(null===cl)throw Error(i(160));pl(a,o,r),cl=null,hl=!1;var u=r.alternate;null!==u&&(u.return=null),r.return=null}catch(c){Iu(r,t,c)}}if(12854&t.subtreeFlags)for(t=t.child;null!==t;)ml(t,e),t=t.sibling}function ml(e,t){var n=e.alternate,s=e.flags;switch(e.tag){case 0:case 11:case 14:case 15:if(gl(t,e),bl(e),4&s){try{nl(3,e,e.return),sl(3,e)}catch(m){Iu(e,e.return,m)}try{nl(5,e,e.return)}catch(m){Iu(e,e.return,m)}}break;case 1:gl(t,e),bl(e),512&s&&null!==n&&Jo(n,n.return);break;case 5:if(gl(t,e),bl(e),512&s&&null!==n&&Jo(n,n.return),32&e.flags){var r=e.stateNode;try{de(r,"")}catch(m){Iu(e,e.return,m)}}if(4&s&&null!=(r=e.stateNode)){var a=e.memoizedProps,o=null!==n?n.memoizedProps:a,l=e.type,u=e.updateQueue;if(e.updateQueue=null,null!==u)try{"input"===l&&"radio"===a.type&&null!=a.name&&Q(r,a),ye(l,o);var c=ye(l,a);for(o=0;o<u.length;o+=2){var h=u[o],d=u[o+1];"style"===h?me(r,d):"dangerouslySetInnerHTML"===h?he(r,d):"children"===h?de(r,d):y(r,h,d,c)}switch(l){case"input":Z(r,a);break;case"textarea":ie(r,a);break;case"select":var p=r._wrapperState.wasMultiple;r._wrapperState.wasMultiple=!!a.multiple;var f=a.value;null!=f?ne(r,!!a.multiple,f,!1):p!==!!a.multiple&&(null!=a.defaultValue?ne(r,!!a.multiple,a.defaultValue,!0):ne(r,!!a.multiple,a.multiple?[]:"",!1))}r[pr]=a}catch(m){Iu(e,e.return,m)}}break;case 6:if(gl(t,e),bl(e),4&s){if(null===e.stateNode)throw Error(i(162));r=e.stateNode,a=e.memoizedProps;try{r.nodeValue=a}catch(m){Iu(e,e.return,m)}}break;case 3:if(gl(t,e),bl(e),4&s&&null!==n&&n.memoizedState.isDehydrated)try{Vt(t.containerInfo)}catch(m){Iu(e,e.return,m)}break;case 4:default:gl(t,e),bl(e);break;case 13:gl(t,e),bl(e),8192&(r=e.child).flags&&(a=null!==r.memoizedState,r.stateNode.isHidden=a,!a||null!==r.alternate&&null!==r.alternate.memoizedState||(Wl=Qe())),4&s&&fl(e);break;case 22:if(h=null!==n&&null!==n.memoizedState,1&e.mode?(Yo=(c=Yo)||h,gl(t,e),Yo=c):gl(t,e),bl(e),8192&s){if(c=null!==e.memoizedState,(e.stateNode.isHidden=c)&&!h&&0!==(1&e.mode))for(Zo=e,h=e.child;null!==h;){for(d=Zo=h;null!==Zo;){switch(f=(p=Zo).child,p.tag){case 0:case 11:case 14:case 15:nl(4,p,p.return);break;case 1:Jo(p,p.return);var g=p.stateNode;if("function"===typeof g.componentWillUnmount){s=p,n=p.return;try{t=s,g.props=t.memoizedProps,g.state=t.memoizedState,g.componentWillUnmount()}catch(m){Iu(s,n,m)}}break;case 5:Jo(p,p.return);break;case 22:if(null!==p.memoizedState){wl(d);continue}}null!==f?(f.return=p,Zo=f):wl(d)}h=h.sibling}e:for(h=null,d=e;;){if(5===d.tag){if(null===h){h=d;try{r=d.stateNode,c?"function"===typeof(a=r.style).setProperty?a.setProperty("display","none","important"):a.display="none":(l=d.stateNode,o=void 0!==(u=d.memoizedProps.style)&&null!==u&&u.hasOwnProperty("display")?u.display:null,l.style.display=ge("display",o))}catch(m){Iu(e,e.return,m)}}}else if(6===d.tag){if(null===h)try{d.stateNode.nodeValue=c?"":d.memoizedProps}catch(m){Iu(e,e.return,m)}}else if((22!==d.tag&&23!==d.tag||null===d.memoizedState||d===e)&&null!==d.child){d.child.return=d,d=d.child;continue}if(d===e)break e;for(;null===d.sibling;){if(null===d.return||d.return===e)break e;h===d&&(h=null),d=d.return}h===d&&(h=null),d.sibling.return=d.return,d=d.sibling}}break;case 19:gl(t,e),bl(e),4&s&&fl(e);case 21:}}function bl(e){var t=e.flags;if(2&t){try{e:{for(var n=e.return;null!==n;){if(al(n)){var s=n;break e}n=n.return}throw Error(i(160))}switch(s.tag){case 5:var r=s.stateNode;32&s.flags&&(de(r,""),s.flags&=-33),ul(e,ol(e),r);break;case 3:case 4:var a=s.stateNode.containerInfo;ll(e,ol(e),a);break;default:throw Error(i(161))}}catch(o){Iu(e,e.return,o)}e.flags&=-3}4096&t&&(e.flags&=-4097)}function xl(e,t,n){Zo=e,yl(e,t,n)}function yl(e,t,n){for(var s=0!==(1&e.mode);null!==Zo;){var r=Zo,i=r.child;if(22===r.tag&&s){var a=null!==r.memoizedState||qo;if(!a){var o=r.alternate,l=null!==o&&null!==o.memoizedState||Yo;o=qo;var u=Yo;if(qo=a,(Yo=l)&&!u)for(Zo=r;null!==Zo;)l=(a=Zo).child,22===a.tag&&null!==a.memoizedState?kl(r):null!==l?(l.return=a,Zo=l):kl(r);for(;null!==i;)Zo=i,yl(i,t,n),i=i.sibling;Zo=r,qo=o,Yo=u}vl(e)}else 0!==(8772&r.subtreeFlags)&&null!==i?(i.return=r,Zo=i):vl(e)}}function vl(e){for(;null!==Zo;){var t=Zo;if(0!==(8772&t.flags)){var n=t.alternate;try{if(0!==(8772&t.flags))switch(t.tag){case 0:case 11:case 15:Yo||sl(5,t);break;case 1:var s=t.stateNode;if(4&t.flags&&!Yo)if(null===n)s.componentDidMount();else{var r=t.elementType===t.type?n.memoizedProps:to(t.type,n.memoizedProps);s.componentDidUpdate(r,n.memoizedState,s.__reactInternalSnapshotBeforeUpdate)}var a=t.updateQueue;null!==a&&Ui(t,a,s);break;case 3:var o=t.updateQueue;if(null!==o){if(n=null,null!==t.child)switch(t.child.tag){case 5:case 1:n=t.child.stateNode}Ui(t,o,n)}break;case 5:var l=t.stateNode;if(null===n&&4&t.flags){n=l;var u=t.memoizedProps;switch(t.type){case"button":case"input":case"select":case"textarea":u.autoFocus&&n.focus();break;case"img":u.src&&(n.src=u.src)}}break;case 6:case 4:case 12:case 19:case 17:case 21:case 22:case 23:case 25:break;case 13:if(null===t.memoizedState){var c=t.alternate;if(null!==c){var h=c.memoizedState;if(null!==h){var d=h.dehydrated;null!==d&&Vt(d)}}}break;default:throw Error(i(163))}Yo||512&t.flags&&rl(t)}catch(p){Iu(t,t.return,p)}}if(t===e){Zo=null;break}if(null!==(n=t.sibling)){n.return=t.return,Zo=n;break}Zo=t.return}}function wl(e){for(;null!==Zo;){var t=Zo;if(t===e){Zo=null;break}var n=t.sibling;if(null!==n){n.return=t.return,Zo=n;break}Zo=t.return}}function kl(e){for(;null!==Zo;){var t=Zo;try{switch(t.tag){case 0:case 11:case 15:var n=t.return;try{sl(4,t)}catch(l){Iu(t,n,l)}break;case 1:var s=t.stateNode;if("function"===typeof s.componentDidMount){var r=t.return;try{s.componentDidMount()}catch(l){Iu(t,r,l)}}var i=t.return;try{rl(t)}catch(l){Iu(t,i,l)}break;case 5:var a=t.return;try{rl(t)}catch(l){Iu(t,a,l)}}}catch(l){Iu(t,t.return,l)}if(t===e){Zo=null;break}var o=t.sibling;if(null!==o){o.return=t.return,Zo=o;break}Zo=t.return}}var Sl,Il=Math.ceil,Cl=v.ReactCurrentDispatcher,Nl=v.ReactCurrentOwner,Tl=v.ReactCurrentBatchConfig,_l=0,El=null,$l=null,Rl=0,Al=0,Dl=Ir(0),Fl=0,Ml=null,Ol=0,Ll=0,Pl=0,zl=null,Bl=null,Wl=0,Vl=1/0,Ul=null,Gl=!1,Hl=null,jl=null,Kl=!1,Xl=null,ql=0,Yl=0,Ql=null,Zl=-1,Jl=0;function eu(){return 0!==(6&_l)?Qe():-1!==Zl?Zl:Zl=Qe()}function tu(e){return 0===(1&e.mode)?1:0!==(2&_l)&&0!==Rl?Rl&-Rl:null!==gi.transition?(0===Jl&&(Jl=gt()),Jl):0!==(e=yt)?e:e=void 0===(e=window.event)?16:Yt(e.type)}function nu(e,t,n,s){if(50<Yl)throw Yl=0,Ql=null,Error(i(185));bt(e,n,s),0!==(2&_l)&&e===El||(e===El&&(0===(2&_l)&&(Ll|=n),4===Fl&&ou(e,Rl)),su(e,s),1===n&&0===_l&&0===(1&t.mode)&&(Vl=Qe()+500,zr&&Vr()))}function su(e,t){var n=e.callbackNode;!function(e,t){for(var n=e.suspendedLanes,s=e.pingedLanes,r=e.expirationTimes,i=e.pendingLanes;0<i;){var a=31-at(i),o=1<<a,l=r[a];-1===l?0!==(o&n)&&0===(o&s)||(r[a]=pt(o,t)):l<=t&&(e.expiredLanes|=o),i&=~o}}(e,t);var s=dt(e,e===El?Rl:0);if(0===s)null!==n&&Xe(n),e.callbackNode=null,e.callbackPriority=0;else if(t=s&-s,e.callbackPriority!==t){if(null!=n&&Xe(n),1===t)0===e.tag?function(e){zr=!0,Wr(e)}(lu.bind(null,e)):Wr(lu.bind(null,e)),ar((function(){0===(6&_l)&&Vr()})),n=null;else{switch(vt(s)){case 1:n=Je;break;case 4:n=et;break;case 16:default:n=tt;break;case 536870912:n=st}n=Eu(n,ru.bind(null,e))}e.callbackPriority=t,e.callbackNode=n}}function ru(e,t){if(Zl=-1,Jl=0,0!==(6&_l))throw Error(i(327));var n=e.callbackNode;if(ku()&&e.callbackNode!==n)return null;var s=dt(e,e===El?Rl:0);if(0===s)return null;if(0!==(30&s)||0!==(s&e.expiredLanes)||t)t=mu(e,s);else{t=s;var r=_l;_l|=2;var a=fu();for(El===e&&Rl===t||(Ul=null,Vl=Qe()+500,du(e,t));;)try{xu();break}catch(l){pu(e,l)}Ni(),Cl.current=a,_l=r,null!==$l?t=0:(El=null,Rl=0,t=Fl)}if(0!==t){if(2===t&&(0!==(r=ft(e))&&(s=r,t=iu(e,r))),1===t)throw n=Ml,du(e,0),ou(e,s),su(e,Qe()),n;if(6===t)ou(e,s);else{if(r=e.current.alternate,0===(30&s)&&!function(e){for(var t=e;;){if(16384&t.flags){var n=t.updateQueue;if(null!==n&&null!==(n=n.stores))for(var s=0;s<n.length;s++){var r=n[s],i=r.getSnapshot;r=r.value;try{if(!os(i(),r))return!1}catch(o){return!1}}}if(n=t.child,16384&t.subtreeFlags&&null!==n)n.return=t,t=n;else{if(t===e)break;for(;null===t.sibling;){if(null===t.return||t.return===e)return!0;t=t.return}t.sibling.return=t.return,t=t.sibling}}return!0}(r)&&(2===(t=mu(e,s))&&(0!==(a=ft(e))&&(s=a,t=iu(e,a))),1===t))throw n=Ml,du(e,0),ou(e,s),su(e,Qe()),n;switch(e.finishedWork=r,e.finishedLanes=s,t){case 0:case 1:throw Error(i(345));case 2:case 5:wu(e,Bl,Ul);break;case 3:if(ou(e,s),(130023424&s)===s&&10<(t=Wl+500-Qe())){if(0!==dt(e,0))break;if(((r=e.suspendedLanes)&s)!==s){eu(),e.pingedLanes|=e.suspendedLanes&r;break}e.timeoutHandle=sr(wu.bind(null,e,Bl,Ul),t);break}wu(e,Bl,Ul);break;case 4:if(ou(e,s),(4194240&s)===s)break;for(t=e.eventTimes,r=-1;0<s;){var o=31-at(s);a=1<<o,(o=t[o])>r&&(r=o),s&=~a}if(s=r,10<(s=(120>(s=Qe()-s)?120:480>s?480:1080>s?1080:1920>s?1920:3e3>s?3e3:4320>s?4320:1960*Il(s/1960))-s)){e.timeoutHandle=sr(wu.bind(null,e,Bl,Ul),s);break}wu(e,Bl,Ul);break;default:throw Error(i(329))}}}return su(e,Qe()),e.callbackNode===n?ru.bind(null,e):null}function iu(e,t){var n=zl;return e.current.memoizedState.isDehydrated&&(du(e,t).flags|=256),2!==(e=mu(e,t))&&(t=Bl,Bl=n,null!==t&&au(t)),e}function au(e){null===Bl?Bl=e:Bl.push.apply(Bl,e)}function ou(e,t){for(t&=~Pl,t&=~Ll,e.suspendedLanes|=t,e.pingedLanes&=~t,e=e.expirationTimes;0<t;){var n=31-at(t),s=1<<n;e[n]=-1,t&=~s}}function lu(e){if(0!==(6&_l))throw Error(i(327));ku();var t=dt(e,0);if(0===(1&t))return su(e,Qe()),null;var n=mu(e,t);if(0!==e.tag&&2===n){var s=ft(e);0!==s&&(t=s,n=iu(e,s))}if(1===n)throw n=Ml,du(e,0),ou(e,t),su(e,Qe()),n;if(6===n)throw Error(i(345));return e.finishedWork=e.current.alternate,e.finishedLanes=t,wu(e,Bl,Ul),su(e,Qe()),null}function uu(e,t){var n=_l;_l|=1;try{return e(t)}finally{0===(_l=n)&&(Vl=Qe()+500,zr&&Vr())}}function cu(e){null!==Xl&&0===Xl.tag&&0===(6&_l)&&ku();var t=_l;_l|=1;var n=Tl.transition,s=yt;try{if(Tl.transition=null,yt=1,e)return e()}finally{yt=s,Tl.transition=n,0===(6&(_l=t))&&Vr()}}function hu(){Al=Dl.current,Cr(Dl)}function du(e,t){e.finishedWork=null,e.finishedLanes=0;var n=e.timeoutHandle;if(-1!==n&&(e.timeoutHandle=-1,rr(n)),null!==$l)for(n=$l.return;null!==n;){var s=n;switch(ti(s),s.tag){case 1:null!==(s=s.type.childContextTypes)&&void 0!==s&&Dr();break;case 3:Yi(),Cr(Er),Cr(_r),na();break;case 5:Zi(s);break;case 4:Yi();break;case 13:case 19:Cr(Ji);break;case 10:Ti(s.type._context);break;case 22:case 23:hu()}n=n.return}if(El=e,$l=e=Du(e.current,null),Rl=Al=t,Fl=0,Ml=null,Pl=Ll=Ol=0,Bl=zl=null,null!==Ri){for(t=0;t<Ri.length;t++)if(null!==(s=(n=Ri[t]).interleaved)){n.interleaved=null;var r=s.next,i=n.pending;if(null!==i){var a=i.next;i.next=r,s.next=a}n.pending=s}Ri=null}return e}function pu(e,t){for(;;){var n=$l;try{if(Ni(),sa.current=Qa,ua){for(var s=aa.memoizedState;null!==s;){var r=s.queue;null!==r&&(r.pending=null),s=s.next}ua=!1}if(ia=0,la=oa=aa=null,ca=!1,ha=0,Nl.current=null,null===n||null===n.return){Fl=1,Ml=t,$l=null;break}e:{var a=e,o=n.return,l=n,u=t;if(t=Rl,l.flags|=32768,null!==u&&"object"===typeof u&&"function"===typeof u.then){var c=u,h=l,d=h.tag;if(0===(1&h.mode)&&(0===d||11===d||15===d)){var p=h.alternate;p?(h.updateQueue=p.updateQueue,h.memoizedState=p.memoizedState,h.lanes=p.lanes):(h.updateQueue=null,h.memoizedState=null)}var f=mo(o);if(null!==f){f.flags&=-257,bo(f,o,l,0,t),1&f.mode&&go(a,c,t),u=c;var g=(t=f).updateQueue;if(null===g){var m=new Set;m.add(u),t.updateQueue=m}else g.add(u);break e}if(0===(1&t)){go(a,c,t),gu();break e}u=Error(i(426))}else if(ri&&1&l.mode){var b=mo(o);if(null!==b){0===(65536&b.flags)&&(b.flags|=256),bo(b,o,l,0,t),fi(lo(u,l));break e}}a=u=lo(u,l),4!==Fl&&(Fl=2),null===zl?zl=[a]:zl.push(a),a=o;do{switch(a.tag){case 3:a.flags|=65536,t&=-t,a.lanes|=t,Wi(a,po(0,u,t));break e;case 1:l=u;var x=a.type,y=a.stateNode;if(0===(128&a.flags)&&("function"===typeof x.getDerivedStateFromError||null!==y&&"function"===typeof y.componentDidCatch&&(null===jl||!jl.has(y)))){a.flags|=65536,t&=-t,a.lanes|=t,Wi(a,fo(a,l,t));break e}}a=a.return}while(null!==a)}vu(n)}catch(v){t=v,$l===n&&null!==n&&($l=n=n.return);continue}break}}function fu(){var e=Cl.current;return Cl.current=Qa,null===e?Qa:e}function gu(){0!==Fl&&3!==Fl&&2!==Fl||(Fl=4),null===El||0===(268435455&Ol)&&0===(268435455&Ll)||ou(El,Rl)}function mu(e,t){var n=_l;_l|=2;var s=fu();for(El===e&&Rl===t||(Ul=null,du(e,t));;)try{bu();break}catch(r){pu(e,r)}if(Ni(),_l=n,Cl.current=s,null!==$l)throw Error(i(261));return El=null,Rl=0,Fl}function bu(){for(;null!==$l;)yu($l)}function xu(){for(;null!==$l&&!qe();)yu($l)}function yu(e){var t=Sl(e.alternate,e,Al);e.memoizedProps=e.pendingProps,null===t?vu(e):$l=t,Nl.current=null}function vu(e){var t=e;do{var n=t.alternate;if(e=t.return,0===(32768&t.flags)){if(null!==(n=Ko(n,t,Al)))return void($l=n)}else{if(null!==(n=Xo(n,t)))return n.flags&=32767,void($l=n);if(null===e)return Fl=6,void($l=null);e.flags|=32768,e.subtreeFlags=0,e.deletions=null}if(null!==(t=t.sibling))return void($l=t);$l=t=e}while(null!==t);0===Fl&&(Fl=5)}function wu(e,t,n){var s=yt,r=Tl.transition;try{Tl.transition=null,yt=1,function(e,t,n,s){do{ku()}while(null!==Xl);if(0!==(6&_l))throw Error(i(327));n=e.finishedWork;var r=e.finishedLanes;if(null===n)return null;if(e.finishedWork=null,e.finishedLanes=0,n===e.current)throw Error(i(177));e.callbackNode=null,e.callbackPriority=0;var a=n.lanes|n.childLanes;if(function(e,t){var n=e.pendingLanes&~t;e.pendingLanes=t,e.suspendedLanes=0,e.pingedLanes=0,e.expiredLanes&=t,e.mutableReadLanes&=t,e.entangledLanes&=t,t=e.entanglements;var s=e.eventTimes;for(e=e.expirationTimes;0<n;){var r=31-at(n),i=1<<r;t[r]=0,s[r]=-1,e[r]=-1,n&=~i}}(e,a),e===El&&($l=El=null,Rl=0),0===(2064&n.subtreeFlags)&&0===(2064&n.flags)||Kl||(Kl=!0,Eu(tt,(function(){return ku(),null}))),a=0!==(15990&n.flags),0!==(15990&n.subtreeFlags)||a){a=Tl.transition,Tl.transition=null;var o=yt;yt=1;var l=_l;_l|=4,Nl.current=null,function(e,t){if(er=Gt,ps(e=ds())){if("selectionStart"in e)var n={start:e.selectionStart,end:e.selectionEnd};else e:{var s=(n=(n=e.ownerDocument)&&n.defaultView||window).getSelection&&n.getSelection();if(s&&0!==s.rangeCount){n=s.anchorNode;var r=s.anchorOffset,a=s.focusNode;s=s.focusOffset;try{n.nodeType,a.nodeType}catch(w){n=null;break e}var o=0,l=-1,u=-1,c=0,h=0,d=e,p=null;t:for(;;){for(var f;d!==n||0!==r&&3!==d.nodeType||(l=o+r),d!==a||0!==s&&3!==d.nodeType||(u=o+s),3===d.nodeType&&(o+=d.nodeValue.length),null!==(f=d.firstChild);)p=d,d=f;for(;;){if(d===e)break t;if(p===n&&++c===r&&(l=o),p===a&&++h===s&&(u=o),null!==(f=d.nextSibling))break;p=(d=p).parentNode}d=f}n=-1===l||-1===u?null:{start:l,end:u}}else n=null}n=n||{start:0,end:0}}else n=null;for(tr={focusedElem:e,selectionRange:n},Gt=!1,Zo=t;null!==Zo;)if(e=(t=Zo).child,0!==(1028&t.subtreeFlags)&&null!==e)e.return=t,Zo=e;else for(;null!==Zo;){t=Zo;try{var g=t.alternate;if(0!==(1024&t.flags))switch(t.tag){case 0:case 11:case 15:case 5:case 6:case 4:case 17:break;case 1:if(null!==g){var m=g.memoizedProps,b=g.memoizedState,x=t.stateNode,y=x.getSnapshotBeforeUpdate(t.elementType===t.type?m:to(t.type,m),b);x.__reactInternalSnapshotBeforeUpdate=y}break;case 3:var v=t.stateNode.containerInfo;1===v.nodeType?v.textContent="":9===v.nodeType&&v.documentElement&&v.removeChild(v.documentElement);break;default:throw Error(i(163))}}catch(w){Iu(t,t.return,w)}if(null!==(e=t.sibling)){e.return=t.return,Zo=e;break}Zo=t.return}g=tl,tl=!1}(e,n),ml(n,e),fs(tr),Gt=!!er,tr=er=null,e.current=n,xl(n,e,r),Ye(),_l=l,yt=o,Tl.transition=a}else e.current=n;if(Kl&&(Kl=!1,Xl=e,ql=r),a=e.pendingLanes,0===a&&(jl=null),function(e){if(it&&"function"===typeof it.onCommitFiberRoot)try{it.onCommitFiberRoot(rt,e,void 0,128===(128&e.current.flags))}catch(t){}}(n.stateNode),su(e,Qe()),null!==t)for(s=e.onRecoverableError,n=0;n<t.length;n++)r=t[n],s(r.value,{componentStack:r.stack,digest:r.digest});if(Gl)throw Gl=!1,e=Hl,Hl=null,e;0!==(1&ql)&&0!==e.tag&&ku(),a=e.pendingLanes,0!==(1&a)?e===Ql?Yl++:(Yl=0,Ql=e):Yl=0,Vr()}(e,t,n,s)}finally{Tl.transition=r,yt=s}return null}function ku(){if(null!==Xl){var e=vt(ql),t=Tl.transition,n=yt;try{if(Tl.transition=null,yt=16>e?16:e,null===Xl)var s=!1;else{if(e=Xl,Xl=null,ql=0,0!==(6&_l))throw Error(i(331));var r=_l;for(_l|=4,Zo=e.current;null!==Zo;){var a=Zo,o=a.child;if(0!==(16&Zo.flags)){var l=a.deletions;if(null!==l){for(var u=0;u<l.length;u++){var c=l[u];for(Zo=c;null!==Zo;){var h=Zo;switch(h.tag){case 0:case 11:case 15:nl(8,h,a)}var d=h.child;if(null!==d)d.return=h,Zo=d;else for(;null!==Zo;){var p=(h=Zo).sibling,f=h.return;if(il(h),h===c){Zo=null;break}if(null!==p){p.return=f,Zo=p;break}Zo=f}}}var g=a.alternate;if(null!==g){var m=g.child;if(null!==m){g.child=null;do{var b=m.sibling;m.sibling=null,m=b}while(null!==m)}}Zo=a}}if(0!==(2064&a.subtreeFlags)&&null!==o)o.return=a,Zo=o;else e:for(;null!==Zo;){if(0!==(2048&(a=Zo).flags))switch(a.tag){case 0:case 11:case 15:nl(9,a,a.return)}var x=a.sibling;if(null!==x){x.return=a.return,Zo=x;break e}Zo=a.return}}var y=e.current;for(Zo=y;null!==Zo;){var v=(o=Zo).child;if(0!==(2064&o.subtreeFlags)&&null!==v)v.return=o,Zo=v;else e:for(o=y;null!==Zo;){if(0!==(2048&(l=Zo).flags))try{switch(l.tag){case 0:case 11:case 15:sl(9,l)}}catch(k){Iu(l,l.return,k)}if(l===o){Zo=null;break e}var w=l.sibling;if(null!==w){w.return=l.return,Zo=w;break e}Zo=l.return}}if(_l=r,Vr(),it&&"function"===typeof it.onPostCommitFiberRoot)try{it.onPostCommitFiberRoot(rt,e)}catch(k){}s=!0}return s}finally{yt=n,Tl.transition=t}}return!1}function Su(e,t,n){e=zi(e,t=po(0,t=lo(n,t),1),1),t=eu(),null!==e&&(bt(e,1,t),su(e,t))}function Iu(e,t,n){if(3===e.tag)Su(e,e,n);else for(;null!==t;){if(3===t.tag){Su(t,e,n);break}if(1===t.tag){var s=t.stateNode;if("function"===typeof t.type.getDerivedStateFromError||"function"===typeof s.componentDidCatch&&(null===jl||!jl.has(s))){t=zi(t,e=fo(t,e=lo(n,e),1),1),e=eu(),null!==t&&(bt(t,1,e),su(t,e));break}}t=t.return}}function Cu(e,t,n){var s=e.pingCache;null!==s&&s.delete(t),t=eu(),e.pingedLanes|=e.suspendedLanes&n,El===e&&(Rl&n)===n&&(4===Fl||3===Fl&&(130023424&Rl)===Rl&&500>Qe()-Wl?du(e,0):Pl|=n),su(e,t)}function Nu(e,t){0===t&&(0===(1&e.mode)?t=1:(t=ct,0===(130023424&(ct<<=1))&&(ct=4194304)));var n=eu();null!==(e=Fi(e,t))&&(bt(e,t,n),su(e,n))}function Tu(e){var t=e.memoizedState,n=0;null!==t&&(n=t.retryLane),Nu(e,n)}function _u(e,t){var n=0;switch(e.tag){case 13:var s=e.stateNode,r=e.memoizedState;null!==r&&(n=r.retryLane);break;case 19:s=e.stateNode;break;default:throw Error(i(314))}null!==s&&s.delete(t),Nu(e,n)}function Eu(e,t){return Ke(e,t)}function $u(e,t,n,s){this.tag=e,this.key=n,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=t,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=s,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function Ru(e,t,n,s){return new $u(e,t,n,s)}function Au(e){return!(!(e=e.prototype)||!e.isReactComponent)}function Du(e,t){var n=e.alternate;return null===n?((n=Ru(e.tag,t,e.key,e.mode)).elementType=e.elementType,n.type=e.type,n.stateNode=e.stateNode,n.alternate=e,e.alternate=n):(n.pendingProps=t,n.type=e.type,n.flags=0,n.subtreeFlags=0,n.deletions=null),n.flags=14680064&e.flags,n.childLanes=e.childLanes,n.lanes=e.lanes,n.child=e.child,n.memoizedProps=e.memoizedProps,n.memoizedState=e.memoizedState,n.updateQueue=e.updateQueue,t=e.dependencies,n.dependencies=null===t?null:{lanes:t.lanes,firstContext:t.firstContext},n.sibling=e.sibling,n.index=e.index,n.ref=e.ref,n}function Fu(e,t,n,s,r,a){var o=2;if(s=e,"function"===typeof e)Au(e)&&(o=1);else if("string"===typeof e)o=5;else e:switch(e){case S:return Mu(n.children,r,a,t);case I:o=8,r|=8;break;case C:return(e=Ru(12,n,t,2|r)).elementType=C,e.lanes=a,e;case E:return(e=Ru(13,n,t,r)).elementType=E,e.lanes=a,e;case $:return(e=Ru(19,n,t,r)).elementType=$,e.lanes=a,e;case D:return Ou(n,r,a,t);default:if("object"===typeof e&&null!==e)switch(e.$$typeof){case N:o=10;break e;case T:o=9;break e;case _:o=11;break e;case R:o=14;break e;case A:o=16,s=null;break e}throw Error(i(130,null==e?e:typeof e,""))}return(t=Ru(o,n,t,r)).elementType=e,t.type=s,t.lanes=a,t}function Mu(e,t,n,s){return(e=Ru(7,e,s,t)).lanes=n,e}function Ou(e,t,n,s){return(e=Ru(22,e,s,t)).elementType=D,e.lanes=n,e.stateNode={isHidden:!1},e}function Lu(e,t,n){return(e=Ru(6,e,null,t)).lanes=n,e}function Pu(e,t,n){return(t=Ru(4,null!==e.children?e.children:[],e.key,t)).lanes=n,t.stateNode={containerInfo:e.containerInfo,pendingChildren:null,implementation:e.implementation},t}function zu(e,t,n,s,r){this.tag=t,this.containerInfo=e,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=mt(0),this.expirationTimes=mt(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=mt(0),this.identifierPrefix=s,this.onRecoverableError=r,this.mutableSourceEagerHydrationData=null}function Bu(e,t,n,s,r,i,a,o,l){return e=new zu(e,t,n,o,l),1===t?(t=1,!0===i&&(t|=8)):t=0,i=Ru(3,null,null,t),e.current=i,i.stateNode=e,i.memoizedState={element:s,isDehydrated:n,cache:null,transitions:null,pendingSuspenseBoundaries:null},Oi(i),e}function Wu(e){if(!e)return Tr;e:{if(Ve(e=e._reactInternals)!==e||1!==e.tag)throw Error(i(170));var t=e;do{switch(t.tag){case 3:t=t.stateNode.context;break e;case 1:if(Ar(t.type)){t=t.stateNode.__reactInternalMemoizedMergedChildContext;break e}}t=t.return}while(null!==t);throw Error(i(171))}if(1===e.tag){var n=e.type;if(Ar(n))return Mr(e,n,t)}return t}function Vu(e,t,n,s,r,i,a,o,l){return(e=Bu(n,s,!0,e,0,i,0,o,l)).context=Wu(null),n=e.current,(i=Pi(s=eu(),r=tu(n))).callback=void 0!==t&&null!==t?t:null,zi(n,i,r),e.current.lanes=r,bt(e,r,s),su(e,s),e}function Uu(e,t,n,s){var r=t.current,i=eu(),a=tu(r);return n=Wu(n),null===t.context?t.context=n:t.pendingContext=n,(t=Pi(i,a)).payload={element:e},null!==(s=void 0===s?null:s)&&(t.callback=s),null!==(e=zi(r,t,a))&&(nu(e,r,a,i),Bi(e,r,a)),a}function Gu(e){return(e=e.current).child?(e.child.tag,e.child.stateNode):null}function Hu(e,t){if(null!==(e=e.memoizedState)&&null!==e.dehydrated){var n=e.retryLane;e.retryLane=0!==n&&n<t?n:t}}function ju(e,t){Hu(e,t),(e=e.alternate)&&Hu(e,t)}Sl=function(e,t,n){if(null!==e)if(e.memoizedProps!==t.pendingProps||Er.current)yo=!0;else{if(0===(e.lanes&n)&&0===(128&t.flags))return yo=!1,function(e,t,n){switch(t.tag){case 3:Eo(t),pi();break;case 5:Qi(t);break;case 1:Ar(t.type)&&Or(t);break;case 4:qi(t,t.stateNode.containerInfo);break;case 10:var s=t.type._context,r=t.memoizedProps.value;Nr(ki,s._currentValue),s._currentValue=r;break;case 13:if(null!==(s=t.memoizedState))return null!==s.dehydrated?(Nr(Ji,1&Ji.current),t.flags|=128,null):0!==(n&t.child.childLanes)?Lo(e,t,n):(Nr(Ji,1&Ji.current),null!==(e=Go(e,t,n))?e.sibling:null);Nr(Ji,1&Ji.current);break;case 19:if(s=0!==(n&t.childLanes),0!==(128&e.flags)){if(s)return Vo(e,t,n);t.flags|=128}if(null!==(r=t.memoizedState)&&(r.rendering=null,r.tail=null,r.lastEffect=null),Nr(Ji,Ji.current),s)break;return null;case 22:case 23:return t.lanes=0,Io(e,t,n)}return Go(e,t,n)}(e,t,n);yo=0!==(131072&e.flags)}else yo=!1,ri&&0!==(1048576&t.flags)&&Jr(t,jr,t.index);switch(t.lanes=0,t.tag){case 2:var s=t.type;Uo(e,t),e=t.pendingProps;var r=Rr(t,_r.current);Ei(t,n),r=ga(null,t,s,e,r,n);var a=ma();return t.flags|=1,"object"===typeof r&&null!==r&&"function"===typeof r.render&&void 0===r.$$typeof?(t.tag=1,t.memoizedState=null,t.updateQueue=null,Ar(s)?(a=!0,Or(t)):a=!1,t.memoizedState=null!==r.state&&void 0!==r.state?r.state:null,Oi(t),r.updater=so,t.stateNode=r,r._reactInternals=t,oo(t,s,e,n),t=_o(null,t,s,!0,a,n)):(t.tag=0,ri&&a&&ei(t),vo(null,t,r,n),t=t.child),t;case 16:s=t.elementType;e:{switch(Uo(e,t),e=t.pendingProps,s=(r=s._init)(s._payload),t.type=s,r=t.tag=function(e){if("function"===typeof e)return Au(e)?1:0;if(void 0!==e&&null!==e){if((e=e.$$typeof)===_)return 11;if(e===R)return 14}return 2}(s),e=to(s,e),r){case 0:t=No(null,t,s,e,n);break e;case 1:t=To(null,t,s,e,n);break e;case 11:t=wo(null,t,s,e,n);break e;case 14:t=ko(null,t,s,to(s.type,e),n);break e}throw Error(i(306,s,""))}return t;case 0:return s=t.type,r=t.pendingProps,No(e,t,s,r=t.elementType===s?r:to(s,r),n);case 1:return s=t.type,r=t.pendingProps,To(e,t,s,r=t.elementType===s?r:to(s,r),n);case 3:e:{if(Eo(t),null===e)throw Error(i(387));s=t.pendingProps,r=(a=t.memoizedState).element,Li(e,t),Vi(t,s,null,n);var o=t.memoizedState;if(s=o.element,a.isDehydrated){if(a={element:s,isDehydrated:!1,cache:o.cache,pendingSuspenseBoundaries:o.pendingSuspenseBoundaries,transitions:o.transitions},t.updateQueue.baseState=a,t.memoizedState=a,256&t.flags){t=$o(e,t,s,n,r=lo(Error(i(423)),t));break e}if(s!==r){t=$o(e,t,s,n,r=lo(Error(i(424)),t));break e}for(si=ur(t.stateNode.containerInfo.firstChild),ni=t,ri=!0,ii=null,n=wi(t,null,s,n),t.child=n;n;)n.flags=-3&n.flags|4096,n=n.sibling}else{if(pi(),s===r){t=Go(e,t,n);break e}vo(e,t,s,n)}t=t.child}return t;case 5:return Qi(t),null===e&&ui(t),s=t.type,r=t.pendingProps,a=null!==e?e.memoizedProps:null,o=r.children,nr(s,r)?o=null:null!==a&&nr(s,a)&&(t.flags|=32),Co(e,t),vo(e,t,o,n),t.child;case 6:return null===e&&ui(t),null;case 13:return Lo(e,t,n);case 4:return qi(t,t.stateNode.containerInfo),s=t.pendingProps,null===e?t.child=vi(t,null,s,n):vo(e,t,s,n),t.child;case 11:return s=t.type,r=t.pendingProps,wo(e,t,s,r=t.elementType===s?r:to(s,r),n);case 7:return vo(e,t,t.pendingProps,n),t.child;case 8:case 12:return vo(e,t,t.pendingProps.children,n),t.child;case 10:e:{if(s=t.type._context,r=t.pendingProps,a=t.memoizedProps,o=r.value,Nr(ki,s._currentValue),s._currentValue=o,null!==a)if(os(a.value,o)){if(a.children===r.children&&!Er.current){t=Go(e,t,n);break e}}else for(null!==(a=t.child)&&(a.return=t);null!==a;){var l=a.dependencies;if(null!==l){o=a.child;for(var u=l.firstContext;null!==u;){if(u.context===s){if(1===a.tag){(u=Pi(-1,n&-n)).tag=2;var c=a.updateQueue;if(null!==c){var h=(c=c.shared).pending;null===h?u.next=u:(u.next=h.next,h.next=u),c.pending=u}}a.lanes|=n,null!==(u=a.alternate)&&(u.lanes|=n),_i(a.return,n,t),l.lanes|=n;break}u=u.next}}else if(10===a.tag)o=a.type===t.type?null:a.child;else if(18===a.tag){if(null===(o=a.return))throw Error(i(341));o.lanes|=n,null!==(l=o.alternate)&&(l.lanes|=n),_i(o,n,t),o=a.sibling}else o=a.child;if(null!==o)o.return=a;else for(o=a;null!==o;){if(o===t){o=null;break}if(null!==(a=o.sibling)){a.return=o.return,o=a;break}o=o.return}a=o}vo(e,t,r.children,n),t=t.child}return t;case 9:return r=t.type,s=t.pendingProps.children,Ei(t,n),s=s(r=$i(r)),t.flags|=1,vo(e,t,s,n),t.child;case 14:return r=to(s=t.type,t.pendingProps),ko(e,t,s,r=to(s.type,r),n);case 15:return So(e,t,t.type,t.pendingProps,n);case 17:return s=t.type,r=t.pendingProps,r=t.elementType===s?r:to(s,r),Uo(e,t),t.tag=1,Ar(s)?(e=!0,Or(t)):e=!1,Ei(t,n),io(t,s,r),oo(t,s,r,n),_o(null,t,s,!0,e,n);case 19:return Vo(e,t,n);case 22:return Io(e,t,n)}throw Error(i(156,t.tag))};var Ku="function"===typeof reportError?reportError:function(e){console.error(e)};function Xu(e){this._internalRoot=e}function qu(e){this._internalRoot=e}function Yu(e){return!(!e||1!==e.nodeType&&9!==e.nodeType&&11!==e.nodeType)}function Qu(e){return!(!e||1!==e.nodeType&&9!==e.nodeType&&11!==e.nodeType&&(8!==e.nodeType||" react-mount-point-unstable "!==e.nodeValue))}function Zu(){}function Ju(e,t,n,s,r){var i=n._reactRootContainer;if(i){var a=i;if("function"===typeof r){var o=r;r=function(){var e=Gu(a);o.call(e)}}Uu(t,a,e,r)}else a=function(e,t,n,s,r){if(r){if("function"===typeof s){var i=s;s=function(){var e=Gu(a);i.call(e)}}var a=Vu(t,s,e,0,null,!1,0,"",Zu);return e._reactRootContainer=a,e[fr]=a.current,Vs(8===e.nodeType?e.parentNode:e),cu(),a}for(;r=e.lastChild;)e.removeChild(r);if("function"===typeof s){var o=s;s=function(){var e=Gu(l);o.call(e)}}var l=Bu(e,0,!1,null,0,!1,0,"",Zu);return e._reactRootContainer=l,e[fr]=l.current,Vs(8===e.nodeType?e.parentNode:e),cu((function(){Uu(t,l,n,s)})),l}(n,t,e,r,s);return Gu(a)}qu.prototype.render=Xu.prototype.render=function(e){var t=this._internalRoot;if(null===t)throw Error(i(409));Uu(e,t,null,null)},qu.prototype.unmount=Xu.prototype.unmount=function(){var e=this._internalRoot;if(null!==e){this._internalRoot=null;var t=e.containerInfo;cu((function(){Uu(null,e,null,null)})),t[fr]=null}},qu.prototype.unstable_scheduleHydration=function(e){if(e){var t=It();e={blockedOn:null,target:e,priority:t};for(var n=0;n<Dt.length&&0!==t&&t<Dt[n].priority;n++);Dt.splice(n,0,e),0===n&&Lt(e)}},wt=function(e){switch(e.tag){case 3:var t=e.stateNode;if(t.current.memoizedState.isDehydrated){var n=ht(t.pendingLanes);0!==n&&(xt(t,1|n),su(t,Qe()),0===(6&_l)&&(Vl=Qe()+500,Vr()))}break;case 13:cu((function(){var t=Fi(e,1);if(null!==t){var n=eu();nu(t,e,1,n)}})),ju(e,1)}},kt=function(e){if(13===e.tag){var t=Fi(e,134217728);if(null!==t)nu(t,e,134217728,eu());ju(e,134217728)}},St=function(e){if(13===e.tag){var t=tu(e),n=Fi(e,t);if(null!==n)nu(n,e,t,eu());ju(e,t)}},It=function(){return yt},Ct=function(e,t){var n=yt;try{return yt=e,t()}finally{yt=n}},ke=function(e,t,n){switch(t){case"input":if(Z(e,n),t=n.name,"radio"===n.type&&null!=t){for(n=e;n.parentNode;)n=n.parentNode;for(n=n.querySelectorAll("input[name="+JSON.stringify(""+t)+'][type="radio"]'),t=0;t<n.length;t++){var s=n[t];if(s!==e&&s.form===e.form){var r=wr(s);if(!r)throw Error(i(90));K(s),Z(s,r)}}}break;case"textarea":ie(e,n);break;case"select":null!=(t=n.value)&&ne(e,!!n.multiple,t,!1)}},_e=uu,Ee=cu;var ec={usingClientEntryPoint:!1,Events:[yr,vr,wr,Ne,Te,uu]},tc={findFiberByHostInstance:xr,bundleType:0,version:"18.3.1",rendererPackageName:"react-dom"},nc={bundleType:tc.bundleType,version:tc.version,rendererPackageName:tc.rendererPackageName,rendererConfig:tc.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:v.ReactCurrentDispatcher,findHostInstanceByFiber:function(e){return null===(e=He(e))?null:e.stateNode},findFiberByHostInstance:tc.findFiberByHostInstance||function(){return null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.3.1-next-f1338f8080-20240426"};if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__){var sc=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!sc.isDisabled&&sc.supportsFiber)try{rt=sc.inject(nc),it=sc}catch(ce){}}t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=ec,t.createPortal=function(e,t){var n=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!Yu(t))throw Error(i(200));return function(e,t,n){var s=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:k,key:null==s?null:""+s,children:e,containerInfo:t,implementation:n}}(e,t,null,n)},t.createRoot=function(e,t){if(!Yu(e))throw Error(i(299));var n=!1,s="",r=Ku;return null!==t&&void 0!==t&&(!0===t.unstable_strictMode&&(n=!0),void 0!==t.identifierPrefix&&(s=t.identifierPrefix),void 0!==t.onRecoverableError&&(r=t.onRecoverableError)),t=Bu(e,1,!1,null,0,n,0,s,r),e[fr]=t.current,Vs(8===e.nodeType?e.parentNode:e),new Xu(t)},t.findDOMNode=function(e){if(null==e)return null;if(1===e.nodeType)return e;var t=e._reactInternals;if(void 0===t){if("function"===typeof e.render)throw Error(i(188));throw e=Object.keys(e).join(","),Error(i(268,e))}return e=null===(e=He(t))?null:e.stateNode},t.flushSync=function(e){return cu(e)},t.hydrate=function(e,t,n){if(!Qu(t))throw Error(i(200));return Ju(null,e,t,!0,n)},t.hydrateRoot=function(e,t,n){if(!Yu(e))throw Error(i(405));var s=null!=n&&n.hydratedSources||null,r=!1,a="",o=Ku;if(null!==n&&void 0!==n&&(!0===n.unstable_strictMode&&(r=!0),void 0!==n.identifierPrefix&&(a=n.identifierPrefix),void 0!==n.onRecoverableError&&(o=n.onRecoverableError)),t=Vu(t,null,e,1,null!=n?n:null,r,0,a,o),e[fr]=t.current,Vs(e),s)for(e=0;e<s.length;e++)r=(r=(n=s[e])._getVersion)(n._source),null==t.mutableSourceEagerHydrationData?t.mutableSourceEagerHydrationData=[n,r]:t.mutableSourceEagerHydrationData.push(n,r);return new qu(t)},t.render=function(e,t,n){if(!Qu(t))throw Error(i(200));return Ju(null,e,t,!1,n)},t.unmountComponentAtNode=function(e){if(!Qu(e))throw Error(i(40));return!!e._reactRootContainer&&(cu((function(){Ju(null,null,e,!1,(function(){e._reactRootContainer=null,e[fr]=null}))})),!0)},t.unstable_batchedUpdates=uu,t.unstable_renderSubtreeIntoContainer=function(e,t,n,s){if(!Qu(n))throw Error(i(200));if(null==e||void 0===e._reactInternals)throw Error(i(38));return Ju(e,t,n,!1,s)},t.version="18.3.1-next-f1338f8080-20240426"},391:(e,t,n)=>{"use strict";var s=n(950);t.createRoot=s.createRoot,t.hydrateRoot=s.hydrateRoot},950:(e,t,n)=>{"use strict";!function e(){if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__&&"function"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE)try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)}catch(t){console.error(t)}}(),e.exports=n(730)},153:(e,t,n)=>{"use strict";var s=n(43),r=Symbol.for("react.element"),i=Symbol.for("react.fragment"),a=Object.prototype.hasOwnProperty,o=s.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,l={key:!0,ref:!0,__self:!0,__source:!0};function u(e,t,n){var s,i={},u=null,c=null;for(s in void 0!==n&&(u=""+n),void 0!==t.key&&(u=""+t.key),void 0!==t.ref&&(c=t.ref),t)a.call(t,s)&&!l.hasOwnProperty(s)&&(i[s]=t[s]);if(e&&e.defaultProps)for(s in t=e.defaultProps)void 0===i[s]&&(i[s]=t[s]);return{$$typeof:r,type:e,key:u,ref:c,props:i,_owner:o.current}}t.jsx=u,t.jsxs=u},202:(e,t)=>{"use strict";var n=Symbol.for("react.element"),s=Symbol.for("react.portal"),r=Symbol.for("react.fragment"),i=Symbol.for("react.strict_mode"),a=Symbol.for("react.profiler"),o=Symbol.for("react.provider"),l=Symbol.for("react.context"),u=Symbol.for("react.forward_ref"),c=Symbol.for("react.suspense"),h=Symbol.for("react.memo"),d=Symbol.for("react.lazy"),p=Symbol.iterator;var f={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},g=Object.assign,m={};function b(e,t,n){this.props=e,this.context=t,this.refs=m,this.updater=n||f}function x(){}function y(e,t,n){this.props=e,this.context=t,this.refs=m,this.updater=n||f}b.prototype.isReactComponent={},b.prototype.setState=function(e,t){if("object"!==typeof e&&"function"!==typeof e&&null!=e)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,e,t,"setState")},b.prototype.forceUpdate=function(e){this.updater.enqueueForceUpdate(this,e,"forceUpdate")},x.prototype=b.prototype;var v=y.prototype=new x;v.constructor=y,g(v,b.prototype),v.isPureReactComponent=!0;var w=Array.isArray,k=Object.prototype.hasOwnProperty,S={current:null},I={key:!0,ref:!0,__self:!0,__source:!0};function C(e,t,s){var r,i={},a=null,o=null;if(null!=t)for(r in void 0!==t.ref&&(o=t.ref),void 0!==t.key&&(a=""+t.key),t)k.call(t,r)&&!I.hasOwnProperty(r)&&(i[r]=t[r]);var l=arguments.length-2;if(1===l)i.children=s;else if(1<l){for(var u=Array(l),c=0;c<l;c++)u[c]=arguments[c+2];i.children=u}if(e&&e.defaultProps)for(r in l=e.defaultProps)void 0===i[r]&&(i[r]=l[r]);return{$$typeof:n,type:e,key:a,ref:o,props:i,_owner:S.current}}function N(e){return"object"===typeof e&&null!==e&&e.$$typeof===n}var T=/\/+/g;function _(e,t){return"object"===typeof e&&null!==e&&null!=e.key?function(e){var t={"=":"=0",":":"=2"};return"$"+e.replace(/[=:]/g,(function(e){return t[e]}))}(""+e.key):t.toString(36)}function E(e,t,r,i,a){var o=typeof e;"undefined"!==o&&"boolean"!==o||(e=null);var l=!1;if(null===e)l=!0;else switch(o){case"string":case"number":l=!0;break;case"object":switch(e.$$typeof){case n:case s:l=!0}}if(l)return a=a(l=e),e=""===i?"."+_(l,0):i,w(a)?(r="",null!=e&&(r=e.replace(T,"$&/")+"/"),E(a,t,r,"",(function(e){return e}))):null!=a&&(N(a)&&(a=function(e,t){return{$$typeof:n,type:e.type,key:t,ref:e.ref,props:e.props,_owner:e._owner}}(a,r+(!a.key||l&&l.key===a.key?"":(""+a.key).replace(T,"$&/")+"/")+e)),t.push(a)),1;if(l=0,i=""===i?".":i+":",w(e))for(var u=0;u<e.length;u++){var c=i+_(o=e[u],u);l+=E(o,t,r,c,a)}else if(c=function(e){return null===e||"object"!==typeof e?null:"function"===typeof(e=p&&e[p]||e["@@iterator"])?e:null}(e),"function"===typeof c)for(e=c.call(e),u=0;!(o=e.next()).done;)l+=E(o=o.value,t,r,c=i+_(o,u++),a);else if("object"===o)throw t=String(e),Error("Objects are not valid as a React child (found: "+("[object Object]"===t?"object with keys {"+Object.keys(e).join(", ")+"}":t)+"). If you meant to render a collection of children, use an array instead.");return l}function $(e,t,n){if(null==e)return e;var s=[],r=0;return E(e,s,"","",(function(e){return t.call(n,e,r++)})),s}function R(e){if(-1===e._status){var t=e._result;(t=t()).then((function(t){0!==e._status&&-1!==e._status||(e._status=1,e._result=t)}),(function(t){0!==e._status&&-1!==e._status||(e._status=2,e._result=t)})),-1===e._status&&(e._status=0,e._result=t)}if(1===e._status)return e._result.default;throw e._result}var A={current:null},D={transition:null},F={ReactCurrentDispatcher:A,ReactCurrentBatchConfig:D,ReactCurrentOwner:S};function M(){throw Error("act(...) is not supported in production builds of React.")}t.Children={map:$,forEach:function(e,t,n){$(e,(function(){t.apply(this,arguments)}),n)},count:function(e){var t=0;return $(e,(function(){t++})),t},toArray:function(e){return $(e,(function(e){return e}))||[]},only:function(e){if(!N(e))throw Error("React.Children.only expected to receive a single React element child.");return e}},t.Component=b,t.Fragment=r,t.Profiler=a,t.PureComponent=y,t.StrictMode=i,t.Suspense=c,t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=F,t.act=M,t.cloneElement=function(e,t,s){if(null===e||void 0===e)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+e+".");var r=g({},e.props),i=e.key,a=e.ref,o=e._owner;if(null!=t){if(void 0!==t.ref&&(a=t.ref,o=S.current),void 0!==t.key&&(i=""+t.key),e.type&&e.type.defaultProps)var l=e.type.defaultProps;for(u in t)k.call(t,u)&&!I.hasOwnProperty(u)&&(r[u]=void 0===t[u]&&void 0!==l?l[u]:t[u])}var u=arguments.length-2;if(1===u)r.children=s;else if(1<u){l=Array(u);for(var c=0;c<u;c++)l[c]=arguments[c+2];r.children=l}return{$$typeof:n,type:e.type,key:i,ref:a,props:r,_owner:o}},t.createContext=function(e){return(e={$$typeof:l,_currentValue:e,_currentValue2:e,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null}).Provider={$$typeof:o,_context:e},e.Consumer=e},t.createElement=C,t.createFactory=function(e){var t=C.bind(null,e);return t.type=e,t},t.createRef=function(){return{current:null}},t.forwardRef=function(e){return{$$typeof:u,render:e}},t.isValidElement=N,t.lazy=function(e){return{$$typeof:d,_payload:{_status:-1,_result:e},_init:R}},t.memo=function(e,t){return{$$typeof:h,type:e,compare:void 0===t?null:t}},t.startTransition=function(e){var t=D.transition;D.transition={};try{e()}finally{D.transition=t}},t.unstable_act=M,t.useCallback=function(e,t){return A.current.useCallback(e,t)},t.useContext=function(e){return A.current.useContext(e)},t.useDebugValue=function(){},t.useDeferredValue=function(e){return A.current.useDeferredValue(e)},t.useEffect=function(e,t){return A.current.useEffect(e,t)},t.useId=function(){return A.current.useId()},t.useImperativeHandle=function(e,t,n){return A.current.useImperativeHandle(e,t,n)},t.useInsertionEffect=function(e,t){return A.current.useInsertionEffect(e,t)},t.useLayoutEffect=function(e,t){return A.current.useLayoutEffect(e,t)},t.useMemo=function(e,t){return A.current.useMemo(e,t)},t.useReducer=function(e,t,n){return A.current.useReducer(e,t,n)},t.useRef=function(e){return A.current.useRef(e)},t.useState=function(e){return A.current.useState(e)},t.useSyncExternalStore=function(e,t,n){return A.current.useSyncExternalStore(e,t,n)},t.useTransition=function(){return A.current.useTransition()},t.version="18.3.1"},43:(e,t,n)=>{"use strict";e.exports=n(202)},579:(e,t,n)=>{"use strict";e.exports=n(153)},234:(e,t)=>{"use strict";function n(e,t){var n=e.length;e.push(t);e:for(;0<n;){var s=n-1>>>1,r=e[s];if(!(0<i(r,t)))break e;e[s]=t,e[n]=r,n=s}}function s(e){return 0===e.length?null:e[0]}function r(e){if(0===e.length)return null;var t=e[0],n=e.pop();if(n!==t){e[0]=n;e:for(var s=0,r=e.length,a=r>>>1;s<a;){var o=2*(s+1)-1,l=e[o],u=o+1,c=e[u];if(0>i(l,n))u<r&&0>i(c,l)?(e[s]=c,e[u]=n,s=u):(e[s]=l,e[o]=n,s=o);else{if(!(u<r&&0>i(c,n)))break e;e[s]=c,e[u]=n,s=u}}}return t}function i(e,t){var n=e.sortIndex-t.sortIndex;return 0!==n?n:e.id-t.id}if("object"===typeof performance&&"function"===typeof performance.now){var a=performance;t.unstable_now=function(){return a.now()}}else{var o=Date,l=o.now();t.unstable_now=function(){return o.now()-l}}var u=[],c=[],h=1,d=null,p=3,f=!1,g=!1,m=!1,b="function"===typeof setTimeout?setTimeout:null,x="function"===typeof clearTimeout?clearTimeout:null,y="undefined"!==typeof setImmediate?setImmediate:null;function v(e){for(var t=s(c);null!==t;){if(null===t.callback)r(c);else{if(!(t.startTime<=e))break;r(c),t.sortIndex=t.expirationTime,n(u,t)}t=s(c)}}function w(e){if(m=!1,v(e),!g)if(null!==s(u))g=!0,D(k);else{var t=s(c);null!==t&&F(w,t.startTime-e)}}function k(e,n){g=!1,m&&(m=!1,x(N),N=-1),f=!0;var i=p;try{for(v(n),d=s(u);null!==d&&(!(d.expirationTime>n)||e&&!E());){var a=d.callback;if("function"===typeof a){d.callback=null,p=d.priorityLevel;var o=a(d.expirationTime<=n);n=t.unstable_now(),"function"===typeof o?d.callback=o:d===s(u)&&r(u),v(n)}else r(u);d=s(u)}if(null!==d)var l=!0;else{var h=s(c);null!==h&&F(w,h.startTime-n),l=!1}return l}finally{d=null,p=i,f=!1}}"undefined"!==typeof navigator&&void 0!==navigator.scheduling&&void 0!==navigator.scheduling.isInputPending&&navigator.scheduling.isInputPending.bind(navigator.scheduling);var S,I=!1,C=null,N=-1,T=5,_=-1;function E(){return!(t.unstable_now()-_<T)}function $(){if(null!==C){var e=t.unstable_now();_=e;var n=!0;try{n=C(!0,e)}finally{n?S():(I=!1,C=null)}}else I=!1}if("function"===typeof y)S=function(){y($)};else if("undefined"!==typeof MessageChannel){var R=new MessageChannel,A=R.port2;R.port1.onmessage=$,S=function(){A.postMessage(null)}}else S=function(){b($,0)};function D(e){C=e,I||(I=!0,S())}function F(e,n){N=b((function(){e(t.unstable_now())}),n)}t.unstable_IdlePriority=5,t.unstable_ImmediatePriority=1,t.unstable_LowPriority=4,t.unstable_NormalPriority=3,t.unstable_Profiling=null,t.unstable_UserBlockingPriority=2,t.unstable_cancelCallback=function(e){e.callback=null},t.unstable_continueExecution=function(){g||f||(g=!0,D(k))},t.unstable_forceFrameRate=function(e){0>e||125<e?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):T=0<e?Math.floor(1e3/e):5},t.unstable_getCurrentPriorityLevel=function(){return p},t.unstable_getFirstCallbackNode=function(){return s(u)},t.unstable_next=function(e){switch(p){case 1:case 2:case 3:var t=3;break;default:t=p}var n=p;p=t;try{return e()}finally{p=n}},t.unstable_pauseExecution=function(){},t.unstable_requestPaint=function(){},t.unstable_runWithPriority=function(e,t){switch(e){case 1:case 2:case 3:case 4:case 5:break;default:e=3}var n=p;p=e;try{return t()}finally{p=n}},t.unstable_scheduleCallback=function(e,r,i){var a=t.unstable_now();switch("object"===typeof i&&null!==i?i="number"===typeof(i=i.delay)&&0<i?a+i:a:i=a,e){case 1:var o=-1;break;case 2:o=250;break;case 5:o=1073741823;break;case 4:o=1e4;break;default:o=5e3}return e={id:h++,callback:r,priorityLevel:e,startTime:i,expirationTime:o=i+o,sortIndex:-1},i>a?(e.sortIndex=i,n(c,e),null===s(u)&&e===s(c)&&(m?(x(N),N=-1):m=!0,F(w,i-a))):(e.sortIndex=o,n(u,e),g||f||(g=!0,D(k))),e},t.unstable_shouldYield=E,t.unstable_wrapCallback=function(e){var t=p;return function(){var n=p;p=t;try{return e.apply(this,arguments)}finally{p=n}}}},853:(e,t,n)=>{"use strict";e.exports=n(234)},334:(e,t,n)=>{var s=n(359),r=n(66),i=n(16),a=n(538),o=n(288),l=n(262),u=n(430);u.alea=s,u.xor128=r,u.xorwow=i,u.xorshift7=a,u.xor4096=o,u.tychei=l,e.exports=u},359:function(e,t,n){var s;!function(e,r){function i(e){var t=this,n=function(){var e=4022871197,t=function(t){t=String(t);for(var n=0;n<t.length;n++){var s=.02519603282416938*(e+=t.charCodeAt(n));s-=e=s>>>0,e=(s*=e)>>>0,e+=4294967296*(s-=e)}return 2.3283064365386963e-10*(e>>>0)};return t}();t.next=function(){var e=2091639*t.s0+2.3283064365386963e-10*t.c;return t.s0=t.s1,t.s1=t.s2,t.s2=e-(t.c=0|e)},t.c=1,t.s0=n(" "),t.s1=n(" "),t.s2=n(" "),t.s0-=n(e),t.s0<0&&(t.s0+=1),t.s1-=n(e),t.s1<0&&(t.s1+=1),t.s2-=n(e),t.s2<0&&(t.s2+=1),n=null}function a(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function o(e,t){var n=new i(e),s=t&&t.state,r=n.next;return r.int32=function(){return 4294967296*n.next()|0},r.double=function(){return r()+11102230246251565e-32*(2097152*r()|0)},r.quick=r,s&&("object"==typeof s&&a(s,n),r.state=function(){return a(n,{})}),r}r&&r.exports?r.exports=o:n.amdD&&n.amdO?void 0===(s=function(){return o}.call(t,n,t,r))||(r.exports=s):this.alea=o}(0,e=n.nmd(e),n.amdD)},262:function(e,t,n){var s;!function(e,r){function i(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,s=t.d,r=t.a;return e=e<<25^e>>>7^n,n=n-s|0,s=s<<24^s>>>8^r,r=r-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-s|0,t.d=s<<16^n>>>16^r,t.a=r-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var s=0;s<n.length+20;s++)t.b^=0|n.charCodeAt(s),t.next()}function a(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function o(e,t){var n=new i(e),s=t&&t.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},r.int32=n.next,r.quick=r,s&&("object"==typeof s&&a(s,n),r.state=function(){return a(n,{})}),r}r&&r.exports?r.exports=o:n.amdD&&n.amdO?void 0===(s=function(){return o}.call(t,n,t,r))||(r.exports=s):this.tychei=o}(0,e=n.nmd(e),n.amdD)},66:function(e,t,n){var s;!function(e,r){function i(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var s=0;s<n.length+64;s++)t.x^=0|n.charCodeAt(s),t.next()}function a(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function o(e,t){var n=new i(e),s=t&&t.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},r.int32=n.next,r.quick=r,s&&("object"==typeof s&&a(s,n),r.state=function(){return a(n,{})}),r}r&&r.exports?r.exports=o:n.amdD&&n.amdO?void 0===(s=function(){return o}.call(t,n,t,r))||(r.exports=s):this.xor128=o}(0,e=n.nmd(e),n.amdD)},288:function(e,t,n){var s;!function(e,r){function i(e){var t=this;t.next=function(){var e,n,s=t.w,r=t.X,i=t.i;return t.w=s=s+1640531527|0,n=r[i+34&127],e=r[i=i+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=r[i]=n^e,t.i=i,n+(s^s>>>16)|0},function(e,t){var n,s,r,i,a,o=[],l=128;for(t===(0|t)?(s=t,t=null):(t+="\0",s=0,l=Math.max(l,t.length)),r=0,i=-32;i<l;++i)t&&(s^=t.charCodeAt((i+32)%t.length)),0===i&&(a=s),s^=s<<10,s^=s>>>15,s^=s<<4,s^=s>>>13,i>=0&&(a=a+1640531527|0,r=0==(n=o[127&i]^=s+a)?r+1:0);for(r>=128&&(o[127&(t&&t.length||0)]=-1),r=127,i=512;i>0;--i)s=o[r+34&127],n=o[r=r+1&127],s^=s<<13,n^=n<<17,s^=s>>>15,n^=n>>>12,o[r]=s^n;e.w=a,e.X=o,e.i=r}(t,e)}function a(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function o(e,t){null==e&&(e=+new Date);var n=new i(e),s=t&&t.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},r.int32=n.next,r.quick=r,s&&(s.X&&a(s,n),r.state=function(){return a(n,{})}),r}r&&r.exports?r.exports=o:n.amdD&&n.amdO?void 0===(s=function(){return o}.call(t,n,t,r))||(r.exports=s):this.xor4096=o}(0,e=n.nmd(e),n.amdD)},538:function(e,t,n){var s;!function(e,r){function i(e){var t=this;t.next=function(){var e,n,s=t.x,r=t.i;return e=s[r],n=(e^=e>>>7)^e<<24,n^=(e=s[r+1&7])^e>>>10,n^=(e=s[r+3&7])^e>>>3,n^=(e=s[r+4&7])^e<<7,e=s[r+7&7],n^=(e^=e<<13)^e<<9,s[r]=n,t.i=r+1&7,n},function(e,t){var n,s=[];if(t===(0|t))s[0]=t;else for(t=""+t,n=0;n<t.length;++n)s[7&n]=s[7&n]<<15^t.charCodeAt(n)+s[n+1&7]<<13;for(;s.length<8;)s.push(0);for(n=0;n<8&&0===s[n];++n);for(8==n?s[7]=-1:s[n],e.x=s,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function a(e,t){return t.x=e.x.slice(),t.i=e.i,t}function o(e,t){null==e&&(e=+new Date);var n=new i(e),s=t&&t.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},r.int32=n.next,r.quick=r,s&&(s.x&&a(s,n),r.state=function(){return a(n,{})}),r}r&&r.exports?r.exports=o:n.amdD&&n.amdO?void 0===(s=function(){return o}.call(t,n,t,r))||(r.exports=s):this.xorshift7=o}(0,e=n.nmd(e),n.amdD)},16:function(e,t,n){var s;!function(e,r){function i(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var s=0;s<n.length+64;s++)t.x^=0|n.charCodeAt(s),s==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function a(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function o(e,t){var n=new i(e),s=t&&t.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},r.int32=n.next,r.quick=r,s&&("object"==typeof s&&a(s,n),r.state=function(){return a(n,{})}),r}r&&r.exports?r.exports=o:n.amdD&&n.amdO?void 0===(s=function(){return o}.call(t,n,t,r))||(r.exports=s):this.xorwow=o}(0,e=n.nmd(e),n.amdD)},430:function(e,t,n){var s;!function(r,i,a){var o,l=256,u=a.pow(l,6),c=a.pow(2,52),h=2*c,d=255;function p(e,t,n){var s=[],d=b(m((t=1==t?{entropy:!0}:t||{}).entropy?[e,x(i)]:null==e?function(){try{var e;return o&&(e=o.randomBytes)?e=e(l):(e=new Uint8Array(l),(r.crypto||r.msCrypto).getRandomValues(e)),x(e)}catch(s){var t=r.navigator,n=t&&t.plugins;return[+new Date,r,n,r.screen,x(i)]}}():e,3),s),p=new f(s),y=function(){for(var e=p.g(6),t=u,n=0;e<c;)e=(e+n)*l,t*=l,n=p.g(1);for(;e>=h;)e/=2,t/=2,n>>>=1;return(e+n)/t};return y.int32=function(){return 0|p.g(4)},y.quick=function(){return p.g(4)/4294967296},y.double=y,b(x(p.S),i),(t.pass||n||function(e,t,n,s){return s&&(s.S&&g(s,p),e.state=function(){return g(p,{})}),n?(a.random=e,t):e})(y,d,"global"in t?t.global:this==a,t.state)}function f(e){var t,n=e.length,s=this,r=0,i=s.i=s.j=0,a=s.S=[];for(n||(e=[n++]);r<l;)a[r]=r++;for(r=0;r<l;r++)a[r]=a[i=d&i+e[r%n]+(t=a[r])],a[i]=t;(s.g=function(e){for(var t,n=0,r=s.i,i=s.j,a=s.S;e--;)t=a[r=d&r+1],n=n*l+a[d&(a[r]=a[i=d&i+t])+(a[i]=t)];return s.i=r,s.j=i,n})(l)}function g(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function m(e,t){var n,s=[],r=typeof e;if(t&&"object"==r)for(n in e)try{s.push(m(e[n],t-1))}catch(i){}return s.length?s:"string"==r?e:e+"\0"}function b(e,t){for(var n,s=e+"",r=0;r<s.length;)t[d&r]=d&(n^=19*t[d&r])+s.charCodeAt(r++);return x(t)}function x(e){return String.fromCharCode.apply(0,e)}if(b(a.random(),i),e.exports){e.exports=p;try{o=n(996)}catch(y){}}else void 0===(s=function(){return p}.call(t,n,t,e))||(e.exports=s)}("undefined"!==typeof self?self:this,[],Math)},817:()=>{},590:()=>{},530:()=>{},108:()=>{},551:()=>{},996:()=>{}},t={};function n(s){var r=t[s];if(void 0!==r)return r.exports;var i=t[s]={id:s,loaded:!1,exports:{}};return e[s].call(i.exports,i,i.exports,n),i.loaded=!0,i.exports}n.amdD=function(){throw new Error("define cannot be used indirect")},n.amdO={},n.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return n.d(t,{a:t}),t},n.d=(e,t)=>{for(var s in t)n.o(t,s)&&!n.o(e,s)&&Object.defineProperty(e,s,{enumerable:!0,get:t[s]})},n.g=function(){if("object"===typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"===typeof window)return window}}(),n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),n.r=e=>{"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.nmd=e=>(e.paths=[],e.children||(e.children=[]),e),(()=>{"use strict";var e={};n.r(e),n.d(e,{assertParamsValid:()=>xf,computeFlatOffset:()=>Rf,computeOutShape:()=>vf,getNormalizedAxes:()=>If,isSliceContinous:()=>$f,maskToAxes:()=>yf,parseSliceParams:()=>Af,sliceInfo:()=>Df,startForAxis:()=>_f,startIndicesWithElidedDims:()=>Cf,stopForAxis:()=>Ef,stopIndicesWithElidedDims:()=>Nf,stridesForAxis:()=>Tf,stridesWithElidedDims:()=>wf});var t={};n.r(t),n.d(t,{collectGatherOpShapeInfo:()=>Qx,computeOutShape:()=>Yx,segOpComputeOptimalWindowSize:()=>qx});var s={};n.r(s),n.d(s,{ERF_A1:()=>px,ERF_A2:()=>fx,ERF_A3:()=>gx,ERF_A4:()=>mx,ERF_A5:()=>bx,ERF_P:()=>dx,PARALLELIZE_THRESHOLD:()=>Zb,RowPartitionType:()=>Kb,SELU_SCALE:()=>hx,SELU_SCALEALPHA:()=>cx,applyActivation:()=>Ym,assertAndGetBroadcastShape:()=>ef,assertAxesAreInnerMostDims:()=>Ug,assertParamsConsistent:()=>Hb,assignToTypedArray:()=>Sx,axesAreInnerMostDims:()=>zg,calculateShapes:()=>ux,checkEinsumDimSizes:()=>Ax,checkPadOnDimRoundingMode:()=>Zf,combineLocations:()=>Bg,combineRaggedTensorToTensorShapes:()=>Xb,complexWithEvenIndex:()=>vx,complexWithOddIndex:()=>wx,computeConv2DInfo:()=>Wf,computeConv3DInfo:()=>Vf,computeDefaultPad:()=>Uf,computeDilation2DInfo:()=>Pf,computeOptimalWindowSize:()=>Jb,computeOutAndReduceShapes:()=>Wg,computeOutShape:()=>jb,computePool2DInfo:()=>zf,computePool3DInfo:()=>Bf,convertConv2DDataFormat:()=>Qf,decodeEinsumEquation:()=>$x,eitherStridesOrDilationsAreOne:()=>qf,expandShapeToKeepDim:()=>Vg,exponent:()=>Cx,exponents:()=>Ix,fromStringArrayToUint8:()=>Jx,fromUint8ToStringArray:()=>Zx,getAxesPermutation:()=>Gg,getBroadcastDims:()=>Zp,getComplexWithIndex:()=>kx,getEinsumComputePath:()=>Dx,getEinsumPermutation:()=>Rx,getFusedBiasGradient:()=>qm,getFusedDyActivation:()=>Xm,getImageCenter:()=>ex,getInnerMostAxes:()=>jg,getPermuted:()=>nx,getRaggedRank:()=>Yb,getReductionAxes:()=>Jp,getReshaped:()=>tx,getReshapedPermuted:()=>sx,getRowPartitionTypesHelper:()=>qb,getSliceBeginCoords:()=>rx,getSliceSize:()=>ix,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>Lx,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>Px,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>zx,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>Vx,getSparseReshapeInputOutputMismatchErrorMessage:()=>Gx,getSparseReshapeInputOutputMultipleErrorMessage:()=>Ux,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>Bx,getSparseReshapeNegativeOutputDimErrorMessage:()=>Wx,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>Xx,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>Hx,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>jx,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>Kx,getUndoAxesPermutation:()=>Hg,isIdentityPermutation:()=>Fx,log:()=>dh,mergeRealAndImagArrays:()=>xx,prepareAndValidate:()=>ax,prepareSplitSize:()=>Ox,segment_util:()=>t,shouldFuse:()=>Qm,slice_util:()=>e,splitRealAndImagArrays:()=>yx,stridesOrDilationsArePositive:()=>Yf,tupleValuesAreOne:()=>Xf,upcastType:()=>cd,validateDefaultValueShape:()=>Qb,validateInput:()=>lx,validateUpdateShape:()=>ox,warn:()=>hh});var r={};n.r(r),n.d(r,{mx:()=>V_,XI:()=>FE,Nk:()=>ME,f6:()=>LE,ct:()=>L_,YG:()=>BE,hH:()=>jE,z3:()=>$$,sG:()=>W$,uM:()=>j$,vS:()=>uR,qB:()=>bR,GG:()=>yR,lg:()=>IR,rq:()=>wR,cu:()=>LR,WR:()=>FR,GE:()=>BR,px:()=>VR,jC:()=>sA,He:()=>aA,hE:()=>mA,BF:()=>k$,Dk:()=>NA,cl:()=>FA,_B:()=>KA,ub:()=>ZA,_f:()=>tD,Ku:()=>oD,qy:()=>uD,Zy:()=>wD,bu:()=>ID,zv:()=>__,dH:()=>Q_,HS:()=>$E,yH:()=>GD,l3:()=>jD,z9:()=>XD,x6:()=>JD,_m:()=>aF,eW:()=>hF,GK:()=>fF,SP:()=>bF,yr:()=>yF,dl:()=>Z$,Dw:()=>CF,xT:()=>EF,_X:()=>rE,wz:()=>OF});var i=n(43),a=n(391),o=n(579);const l=e=>{let{onAction:t}=e;return(0,o.jsxs)("div",{className:"controls-container",children:[(0,o.jsx)("h2",{children:"\u0423\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u0435 \u042d\u043a\u043e\u0441\u0438\u0441\u0442\u0435\u043c\u043e\u0439"}),[{name:"grass",label:"\u0422\u0440\u0430\u0432\u0430",addValue:20,removeValue:-20},{name:"bushes",label:"\u041a\u0443\u0441\u0442\u044b",addValue:10,removeValue:-10},{name:"trees",label:"\u0414\u0435\u0440\u0435\u0432\u044c\u044f",addValue:5,removeValue:-5},{name:"rabbits",label:"\u041a\u0440\u043e\u043b\u0438\u043a\u0438",addValue:10,removeValue:-10},{name:"wolves",label:"\u0412\u043e\u043b\u043a\u0438",addValue:5,removeValue:-5}].map((e=>(0,o.jsxs)("div",{className:"control-group",children:[(0,o.jsx)("h3",{children:e.label}),(0,o.jsx)("button",{onClick:()=>t(e.name,e.addValue),children:"\u0414\u043e\u0431\u0430\u0432\u0438\u0442\u044c"}),(0,o.jsx)("button",{onClick:()=>t(e.name,e.removeValue),children:"\u0423\u0434\u0430\u043b\u0438\u0442\u044c"})]},e.name)))]})},u=e=>e.charAt(0).toUpperCase()+e.slice(1),c=e=>{let{suggestions:t,onApply:n}=e;if(!t||0===t.length)return(0,o.jsx)("div",{children:"\u0417\u0430\u0433\u0440\u0443\u0437\u043a\u0430 \u043f\u0440\u0435\u0434\u043b\u043e\u0436\u0435\u043d\u0438\u0439 \u043d\u0435\u0439\u0440\u043e\u0441\u0435\u0442\u0438..."});const s=(e,t)=>t>0?`\u0414\u043e\u0431\u0430\u0432\u0438\u0442\u044c ${t}`:t<0?"\u0423\u0434\u0430\u043b\u0438\u0442\u044c "+-t:"\u041d\u0435\u0442 \u0438\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u0439";return(0,o.jsxs)("div",{className:"suggestions-container",children:[(0,o.jsx)("h2",{children:"\u041f\u0440\u0435\u0434\u043b\u043e\u0436\u0435\u043d\u0438\u044f \u041d\u0435\u0439\u0440\u043e\u0441\u0435\u0442\u0438"}),t.map(((e,t)=>(0,o.jsxs)("div",{className:"suggestion-option",children:[(0,o.jsx)("ul",{children:Object.entries(e).map((e=>{let[t,n]=e;return(0,o.jsxs)("li",{children:[u(t),": ",s(0,n)]},t)}))}),(0,o.jsx)("button",{onClick:()=>(e=>{n(e)})(e),children:"\u041f\u0440\u0438\u043c\u0435\u043d\u0438\u0442\u044c"})]},t)))]})};function h(e){return e+.5|0}const d=(e,t,n)=>Math.max(Math.min(e,n),t);function p(e){return d(h(2.55*e),0,255)}function f(e){return d(h(255*e),0,255)}function g(e){return d(h(e/2.55)/100,0,1)}function m(e){return d(h(100*e),0,100)}const b={0:0,1:1,2:2,3:3,4:4,5:5,6:6,7:7,8:8,9:9,A:10,B:11,C:12,D:13,E:14,F:15,a:10,b:11,c:12,d:13,e:14,f:15},x=[..."0123456789ABCDEF"],y=e=>x[15&e],v=e=>x[(240&e)>>4]+x[15&e],w=e=>(240&e)>>4===(15&e);function k(e){var t=(e=>w(e.r)&&w(e.g)&&w(e.b)&&w(e.a))(e)?y:v;return e?"#"+t(e.r)+t(e.g)+t(e.b)+((e,t)=>e<255?t(e):"")(e.a,t):void 0}const S=/^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;function I(e,t,n){const s=t*Math.min(n,1-n),r=function(t){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:(t+e/30)%12;return n-s*Math.max(Math.min(r-3,9-r,1),-1)};return[r(0),r(8),r(4)]}function C(e,t,n){const s=function(s){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:(s+e/60)%6;return n-n*t*Math.max(Math.min(r,4-r,1),0)};return[s(5),s(3),s(1)]}function N(e,t,n){const s=I(e,1,.5);let r;for(t+n>1&&(r=1/(t+n),t*=r,n*=r),r=0;r<3;r++)s[r]*=1-t-n,s[r]+=t;return s}function T(e){const t=e.r/255,n=e.g/255,s=e.b/255,r=Math.max(t,n,s),i=Math.min(t,n,s),a=(r+i)/2;let o,l,u;return r!==i&&(u=r-i,l=a>.5?u/(2-r-i):u/(r+i),o=function(e,t,n,s,r){return e===r?(t-n)/s+(t<n?6:0):t===r?(n-e)/s+2:(e-t)/s+4}(t,n,s,u,r),o=60*o+.5),[0|o,l||0,a]}function _(e,t,n,s){return(Array.isArray(t)?e(t[0],t[1],t[2]):e(t,n,s)).map(f)}function E(e,t,n){return _(I,e,t,n)}function $(e){return(e%360+360)%360}function R(e){const t=S.exec(e);let n,s=255;if(!t)return;t[5]!==n&&(s=t[6]?p(+t[5]):f(+t[5]));const r=$(+t[2]),i=+t[3]/100,a=+t[4]/100;return n="hwb"===t[1]?function(e,t,n){return _(N,e,t,n)}(r,i,a):"hsv"===t[1]?function(e,t,n){return _(C,e,t,n)}(r,i,a):E(r,i,a),{r:n[0],g:n[1],b:n[2],a:s}}const A={x:"dark",Z:"light",Y:"re",X:"blu",W:"gr",V:"medium",U:"slate",A:"ee",T:"ol",S:"or",B:"ra",C:"lateg",D:"ights",R:"in",Q:"turquois",E:"hi",P:"ro",O:"al",N:"le",M:"de",L:"yello",F:"en",K:"ch",G:"arks",H:"ea",I:"ightg",J:"wh"},D={OiceXe:"f0f8ff",antiquewEte:"faebd7",aqua:"ffff",aquamarRe:"7fffd4",azuY:"f0ffff",beige:"f5f5dc",bisque:"ffe4c4",black:"0",blanKedOmond:"ffebcd",Xe:"ff",XeviTet:"8a2be2",bPwn:"a52a2a",burlywood:"deb887",caMtXe:"5f9ea0",KartYuse:"7fff00",KocTate:"d2691e",cSO:"ff7f50",cSnflowerXe:"6495ed",cSnsilk:"fff8dc",crimson:"dc143c",cyan:"ffff",xXe:"8b",xcyan:"8b8b",xgTMnPd:"b8860b",xWay:"a9a9a9",xgYF:"6400",xgYy:"a9a9a9",xkhaki:"bdb76b",xmagFta:"8b008b",xTivegYF:"556b2f",xSange:"ff8c00",xScEd:"9932cc",xYd:"8b0000",xsOmon:"e9967a",xsHgYF:"8fbc8f",xUXe:"483d8b",xUWay:"2f4f4f",xUgYy:"2f4f4f",xQe:"ced1",xviTet:"9400d3",dAppRk:"ff1493",dApskyXe:"bfff",dimWay:"696969",dimgYy:"696969",dodgerXe:"1e90ff",fiYbrick:"b22222",flSOwEte:"fffaf0",foYstWAn:"228b22",fuKsia:"ff00ff",gaRsbSo:"dcdcdc",ghostwEte:"f8f8ff",gTd:"ffd700",gTMnPd:"daa520",Way:"808080",gYF:"8000",gYFLw:"adff2f",gYy:"808080",honeyMw:"f0fff0",hotpRk:"ff69b4",RdianYd:"cd5c5c",Rdigo:"4b0082",ivSy:"fffff0",khaki:"f0e68c",lavFMr:"e6e6fa",lavFMrXsh:"fff0f5",lawngYF:"7cfc00",NmoncEffon:"fffacd",ZXe:"add8e6",ZcSO:"f08080",Zcyan:"e0ffff",ZgTMnPdLw:"fafad2",ZWay:"d3d3d3",ZgYF:"90ee90",ZgYy:"d3d3d3",ZpRk:"ffb6c1",ZsOmon:"ffa07a",ZsHgYF:"20b2aa",ZskyXe:"87cefa",ZUWay:"778899",ZUgYy:"778899",ZstAlXe:"b0c4de",ZLw:"ffffe0",lime:"ff00",limegYF:"32cd32",lRF:"faf0e6",magFta:"ff00ff",maPon:"800000",VaquamarRe:"66cdaa",VXe:"cd",VScEd:"ba55d3",VpurpN:"9370db",VsHgYF:"3cb371",VUXe:"7b68ee",VsprRggYF:"fa9a",VQe:"48d1cc",VviTetYd:"c71585",midnightXe:"191970",mRtcYam:"f5fffa",mistyPse:"ffe4e1",moccasR:"ffe4b5",navajowEte:"ffdead",navy:"80",Tdlace:"fdf5e6",Tive:"808000",TivedBb:"6b8e23",Sange:"ffa500",SangeYd:"ff4500",ScEd:"da70d6",pOegTMnPd:"eee8aa",pOegYF:"98fb98",pOeQe:"afeeee",pOeviTetYd:"db7093",papayawEp:"ffefd5",pHKpuff:"ffdab9",peru:"cd853f",pRk:"ffc0cb",plum:"dda0dd",powMrXe:"b0e0e6",purpN:"800080",YbeccapurpN:"663399",Yd:"ff0000",Psybrown:"bc8f8f",PyOXe:"4169e1",saddNbPwn:"8b4513",sOmon:"fa8072",sandybPwn:"f4a460",sHgYF:"2e8b57",sHshell:"fff5ee",siFna:"a0522d",silver:"c0c0c0",skyXe:"87ceeb",UXe:"6a5acd",UWay:"708090",UgYy:"708090",snow:"fffafa",sprRggYF:"ff7f",stAlXe:"4682b4",tan:"d2b48c",teO:"8080",tEstN:"d8bfd8",tomato:"ff6347",Qe:"40e0d0",viTet:"ee82ee",JHt:"f5deb3",wEte:"ffffff",wEtesmoke:"f5f5f5",Lw:"ffff00",LwgYF:"9acd32"};let F;function M(e){F||(F=function(){const e={},t=Object.keys(D),n=Object.keys(A);let s,r,i,a,o;for(s=0;s<t.length;s++){for(a=o=t[s],r=0;r<n.length;r++)i=n[r],o=o.replace(i,A[i]);i=parseInt(D[a],16),e[o]=[i>>16&255,i>>8&255,255&i]}return e}(),F.transparent=[0,0,0,0]);const t=F[e.toLowerCase()];return t&&{r:t[0],g:t[1],b:t[2],a:4===t.length?t[3]:255}}const O=/^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;const L=e=>e<=.0031308?12.92*e:1.055*Math.pow(e,1/2.4)-.055,P=e=>e<=.04045?e/12.92:Math.pow((e+.055)/1.055,2.4);function z(e,t,n){if(e){let s=T(e);s[t]=Math.max(0,Math.min(s[t]+s[t]*n,0===t?360:1)),s=E(s),e.r=s[0],e.g=s[1],e.b=s[2]}}function B(e,t){return e?Object.assign(t||{},e):e}function W(e){var t={r:0,g:0,b:0,a:255};return Array.isArray(e)?e.length>=3&&(t={r:e[0],g:e[1],b:e[2],a:255},e.length>3&&(t.a=f(e[3]))):(t=B(e,{r:0,g:0,b:0,a:1})).a=f(t.a),t}function V(e){return"r"===e.charAt(0)?function(e){const t=O.exec(e);let n,s,r,i=255;if(t){if(t[7]!==n){const e=+t[7];i=t[8]?p(e):d(255*e,0,255)}return n=+t[1],s=+t[3],r=+t[5],n=255&(t[2]?p(n):d(n,0,255)),s=255&(t[4]?p(s):d(s,0,255)),r=255&(t[6]?p(r):d(r,0,255)),{r:n,g:s,b:r,a:i}}}(e):R(e)}class U{constructor(e){if(e instanceof U)return e;const t=typeof e;let n;"object"===t?n=W(e):"string"===t&&(n=function(e){var t,n=e.length;return"#"===e[0]&&(4===n||5===n?t={r:255&17*b[e[1]],g:255&17*b[e[2]],b:255&17*b[e[3]],a:5===n?17*b[e[4]]:255}:7!==n&&9!==n||(t={r:b[e[1]]<<4|b[e[2]],g:b[e[3]]<<4|b[e[4]],b:b[e[5]]<<4|b[e[6]],a:9===n?b[e[7]]<<4|b[e[8]]:255})),t}(e)||M(e)||V(e)),this._rgb=n,this._valid=!!n}get valid(){return this._valid}get rgb(){var e=B(this._rgb);return e&&(e.a=g(e.a)),e}set rgb(e){this._rgb=W(e)}rgbString(){return this._valid?(e=this._rgb)&&(e.a<255?`rgba(${e.r}, ${e.g}, ${e.b}, ${g(e.a)})`:`rgb(${e.r}, ${e.g}, ${e.b})`):void 0;var e}hexString(){return this._valid?k(this._rgb):void 0}hslString(){return this._valid?function(e){if(!e)return;const t=T(e),n=t[0],s=m(t[1]),r=m(t[2]);return e.a<255?`hsla(${n}, ${s}%, ${r}%, ${g(e.a)})`:`hsl(${n}, ${s}%, ${r}%)`}(this._rgb):void 0}mix(e,t){if(e){const n=this.rgb,s=e.rgb;let r;const i=t===r?.5:t,a=2*i-1,o=n.a-s.a,l=((a*o===-1?a:(a+o)/(1+a*o))+1)/2;r=1-l,n.r=255&l*n.r+r*s.r+.5,n.g=255&l*n.g+r*s.g+.5,n.b=255&l*n.b+r*s.b+.5,n.a=i*n.a+(1-i)*s.a,this.rgb=n}return this}interpolate(e,t){return e&&(this._rgb=function(e,t,n){const s=P(g(e.r)),r=P(g(e.g)),i=P(g(e.b));return{r:f(L(s+n*(P(g(t.r))-s))),g:f(L(r+n*(P(g(t.g))-r))),b:f(L(i+n*(P(g(t.b))-i))),a:e.a+n*(t.a-e.a)}}(this._rgb,e._rgb,t)),this}clone(){return new U(this.rgb)}alpha(e){return this._rgb.a=f(e),this}clearer(e){return this._rgb.a*=1-e,this}greyscale(){const e=this._rgb,t=h(.3*e.r+.59*e.g+.11*e.b);return e.r=e.g=e.b=t,this}opaquer(e){return this._rgb.a*=1+e,this}negate(){const e=this._rgb;return e.r=255-e.r,e.g=255-e.g,e.b=255-e.b,this}lighten(e){return z(this._rgb,2,e),this}darken(e){return z(this._rgb,2,-e),this}saturate(e){return z(this._rgb,1,e),this}desaturate(e){return z(this._rgb,1,-e),this}rotate(e){return function(e,t){var n=T(e);n[0]=$(n[0]+t),n=E(n),e.r=n[0],e.g=n[1],e.b=n[2]}(this._rgb,e),this}}function G(){}const H=(()=>{let e=0;return()=>e++})();function j(e){return null===e||"undefined"===typeof e}function K(e){if(Array.isArray&&Array.isArray(e))return!0;const t=Object.prototype.toString.call(e);return"[object"===t.slice(0,7)&&"Array]"===t.slice(-6)}function X(e){return null!==e&&"[object Object]"===Object.prototype.toString.call(e)}function q(e){return("number"===typeof e||e instanceof Number)&&isFinite(+e)}function Y(e,t){return q(e)?e:t}function Q(e,t){return"undefined"===typeof e?t:e}const Z=(e,t)=>"string"===typeof e&&e.endsWith("%")?parseFloat(e)/100*t:+e;function J(e,t,n){if(e&&"function"===typeof e.call)return e.apply(n,t)}function ee(e,t,n,s){let r,i,a;if(K(e))if(i=e.length,s)for(r=i-1;r>=0;r--)t.call(n,e[r],r);else for(r=0;r<i;r++)t.call(n,e[r],r);else if(X(e))for(a=Object.keys(e),i=a.length,r=0;r<i;r++)t.call(n,e[a[r]],a[r])}function te(e,t){let n,s,r,i;if(!e||!t||e.length!==t.length)return!1;for(n=0,s=e.length;n<s;++n)if(r=e[n],i=t[n],r.datasetIndex!==i.datasetIndex||r.index!==i.index)return!1;return!0}function ne(e){if(K(e))return e.map(ne);if(X(e)){const t=Object.create(null),n=Object.keys(e),s=n.length;let r=0;for(;r<s;++r)t[n[r]]=ne(e[n[r]]);return t}return e}function se(e){return-1===["__proto__","prototype","constructor"].indexOf(e)}function re(e,t,n,s){if(!se(e))return;const r=t[e],i=n[e];X(r)&&X(i)?ie(r,i,s):t[e]=ne(i)}function ie(e,t,n){const s=K(t)?t:[t],r=s.length;if(!X(e))return e;const i=(n=n||{}).merger||re;let a;for(let o=0;o<r;++o){if(a=s[o],!X(a))continue;const t=Object.keys(a);for(let s=0,r=t.length;s<r;++s)i(t[s],e,a,n)}return e}function ae(e,t){return ie(e,t,{merger:oe})}function oe(e,t,n){if(!se(e))return;const s=t[e],r=n[e];X(s)&&X(r)?ae(s,r):Object.prototype.hasOwnProperty.call(t,e)||(t[e]=ne(r))}const le={"":e=>e,x:e=>e.x,y:e=>e.y};function ue(e,t){const n=le[t]||(le[t]=function(e){const t=function(e){const t=e.split("."),n=[];let s="";for(const r of t)s+=r,s.endsWith("\\")?s=s.slice(0,-1)+".":(n.push(s),s="");return n}(e);return e=>{for(const n of t){if(""===n)break;e=e&&e[n]}return e}}(t));return n(e)}function ce(e){return e.charAt(0).toUpperCase()+e.slice(1)}const he=e=>"undefined"!==typeof e,de=e=>"function"===typeof e,pe=(e,t)=>{if(e.size!==t.size)return!1;for(const n of e)if(!t.has(n))return!1;return!0};const fe=Math.PI,ge=2*fe,me=ge+fe,be=Number.POSITIVE_INFINITY,xe=fe/180,ye=fe/2,ve=fe/4,we=2*fe/3,ke=Math.log10,Se=Math.sign;function Ie(e,t,n){return Math.abs(e-t)<n}function Ce(e){const t=Math.round(e);e=Ie(e,t,e/1e3)?t:e;const n=Math.pow(10,Math.floor(ke(e))),s=e/n;return(s<=1?1:s<=2?2:s<=5?5:10)*n}function Ne(e){return!isNaN(parseFloat(e))&&isFinite(e)}function Te(e,t,n){let s,r,i;for(s=0,r=e.length;s<r;s++)i=e[s][n],isNaN(i)||(t.min=Math.min(t.min,i),t.max=Math.max(t.max,i))}function _e(e){return e*(fe/180)}function Ee(e){return e*(180/fe)}function $e(e){if(!q(e))return;let t=1,n=0;for(;Math.round(e*t)/t!==e;)t*=10,n++;return n}function Re(e,t){const n=t.x-e.x,s=t.y-e.y,r=Math.sqrt(n*n+s*s);let i=Math.atan2(s,n);return i<-.5*fe&&(i+=ge),{angle:i,distance:r}}function Ae(e,t){return Math.sqrt(Math.pow(t.x-e.x,2)+Math.pow(t.y-e.y,2))}function De(e,t){return(e-t+me)%ge-fe}function Fe(e){return(e%ge+ge)%ge}function Me(e,t,n,s){const r=Fe(e),i=Fe(t),a=Fe(n),o=Fe(i-r),l=Fe(a-r),u=Fe(r-i),c=Fe(r-a);return r===i||r===a||s&&i===a||o>l&&u<c}function Oe(e,t,n){return Math.max(t,Math.min(n,e))}function Le(e,t,n){let s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1e-6;return e>=Math.min(t,n)-s&&e<=Math.max(t,n)+s}function Pe(e,t,n){n=n||(n=>e[n]<t);let s,r=e.length-1,i=0;for(;r-i>1;)s=i+r>>1,n(s)?i=s:r=s;return{lo:i,hi:r}}const ze=(e,t,n,s)=>Pe(e,n,s?s=>{const r=e[s][t];return r<n||r===n&&e[s+1][t]===n}:s=>e[s][t]<n),Be=(e,t,n)=>Pe(e,n,(s=>e[s][t]>=n));const We=["push","pop","shift","splice","unshift"];function Ve(e,t){const n=e._chartjs;if(!n)return;const s=n.listeners,r=s.indexOf(t);-1!==r&&s.splice(r,1),s.length>0||(We.forEach((t=>{delete e[t]})),delete e._chartjs)}function Ue(e){const t=new Set(e);return t.size===e.length?e:Array.from(t)}const Ge="undefined"===typeof window?function(e){return e()}:window.requestAnimationFrame;function He(e,t){let n=[],s=!1;return function(){for(var r=arguments.length,i=new Array(r),a=0;a<r;a++)i[a]=arguments[a];n=i,s||(s=!0,Ge.call(window,(()=>{s=!1,e.apply(t,n)})))}}const je=e=>"start"===e?"left":"end"===e?"right":"center",Ke=(e,t,n)=>"start"===e?t:"end"===e?n:(t+n)/2;function Xe(e,t,n){const s=t.length;let r=0,i=s;if(e._sorted){const{iScale:a,_parsed:o}=e,l=a.axis,{min:u,max:c,minDefined:h,maxDefined:d}=a.getUserBounds();h&&(r=Oe(Math.min(ze(o,l,u).lo,n?s:ze(t,l,a.getPixelForValue(u)).lo),0,s-1)),i=d?Oe(Math.max(ze(o,a.axis,c,!0).hi+1,n?0:ze(t,l,a.getPixelForValue(c),!0).hi+1),r,s)-r:s-r}return{start:r,count:i}}function qe(e){const{xScale:t,yScale:n,_scaleRanges:s}=e,r={xmin:t.min,xmax:t.max,ymin:n.min,ymax:n.max};if(!s)return e._scaleRanges=r,!0;const i=s.xmin!==t.min||s.xmax!==t.max||s.ymin!==n.min||s.ymax!==n.max;return Object.assign(s,r),i}const Ye=e=>0===e||1===e,Qe=(e,t,n)=>-Math.pow(2,10*(e-=1))*Math.sin((e-t)*ge/n),Ze=(e,t,n)=>Math.pow(2,-10*e)*Math.sin((e-t)*ge/n)+1,Je={linear:e=>e,easeInQuad:e=>e*e,easeOutQuad:e=>-e*(e-2),easeInOutQuad:e=>(e/=.5)<1?.5*e*e:-.5*(--e*(e-2)-1),easeInCubic:e=>e*e*e,easeOutCubic:e=>(e-=1)*e*e+1,easeInOutCubic:e=>(e/=.5)<1?.5*e*e*e:.5*((e-=2)*e*e+2),easeInQuart:e=>e*e*e*e,easeOutQuart:e=>-((e-=1)*e*e*e-1),easeInOutQuart:e=>(e/=.5)<1?.5*e*e*e*e:-.5*((e-=2)*e*e*e-2),easeInQuint:e=>e*e*e*e*e,easeOutQuint:e=>(e-=1)*e*e*e*e+1,easeInOutQuint:e=>(e/=.5)<1?.5*e*e*e*e*e:.5*((e-=2)*e*e*e*e+2),easeInSine:e=>1-Math.cos(e*ye),easeOutSine:e=>Math.sin(e*ye),easeInOutSine:e=>-.5*(Math.cos(fe*e)-1),easeInExpo:e=>0===e?0:Math.pow(2,10*(e-1)),easeOutExpo:e=>1===e?1:1-Math.pow(2,-10*e),easeInOutExpo:e=>Ye(e)?e:e<.5?.5*Math.pow(2,10*(2*e-1)):.5*(2-Math.pow(2,-10*(2*e-1))),easeInCirc:e=>e>=1?e:-(Math.sqrt(1-e*e)-1),easeOutCirc:e=>Math.sqrt(1-(e-=1)*e),easeInOutCirc:e=>(e/=.5)<1?-.5*(Math.sqrt(1-e*e)-1):.5*(Math.sqrt(1-(e-=2)*e)+1),easeInElastic:e=>Ye(e)?e:Qe(e,.075,.3),easeOutElastic:e=>Ye(e)?e:Ze(e,.075,.3),easeInOutElastic(e){const t=.1125;return Ye(e)?e:e<.5?.5*Qe(2*e,t,.45):.5+.5*Ze(2*e-1,t,.45)},easeInBack(e){const t=1.70158;return e*e*((t+1)*e-t)},easeOutBack(e){const t=1.70158;return(e-=1)*e*((t+1)*e+t)+1},easeInOutBack(e){let t=1.70158;return(e/=.5)<1?e*e*((1+(t*=1.525))*e-t)*.5:.5*((e-=2)*e*((1+(t*=1.525))*e+t)+2)},easeInBounce:e=>1-Je.easeOutBounce(1-e),easeOutBounce(e){const t=7.5625,n=2.75;return e<1/n?t*e*e:e<2/n?t*(e-=1.5/n)*e+.75:e<2.5/n?t*(e-=2.25/n)*e+.9375:t*(e-=2.625/n)*e+.984375},easeInOutBounce:e=>e<.5?.5*Je.easeInBounce(2*e):.5*Je.easeOutBounce(2*e-1)+.5};function et(e){if(e&&"object"===typeof e){const t=e.toString();return"[object CanvasPattern]"===t||"[object CanvasGradient]"===t}return!1}function tt(e){return et(e)?e:new U(e)}function nt(e){return et(e)?e:new U(e).saturate(.5).darken(.1).hexString()}const st=["x","y","borderWidth","radius","tension"],rt=["color","borderColor","backgroundColor"];const it=new Map;function at(e,t,n){return function(e,t){t=t||{};const n=e+JSON.stringify(t);let s=it.get(n);return s||(s=new Intl.NumberFormat(e,t),it.set(n,s)),s}(t,n).format(e)}const ot={values:e=>K(e)?e:""+e,numeric(e,t,n){if(0===e)return"0";const s=this.chart.options.locale;let r,i=e;if(n.length>1){const t=Math.max(Math.abs(n[0].value),Math.abs(n[n.length-1].value));(t<1e-4||t>1e15)&&(r="scientific"),i=function(e,t){let n=t.length>3?t[2].value-t[1].value:t[1].value-t[0].value;Math.abs(n)>=1&&e!==Math.floor(e)&&(n=e-Math.floor(e));return n}(e,n)}const a=ke(Math.abs(i)),o=isNaN(a)?1:Math.max(Math.min(-1*Math.floor(a),20),0),l={notation:r,minimumFractionDigits:o,maximumFractionDigits:o};return Object.assign(l,this.options.ticks.format),at(e,s,l)},logarithmic(e,t,n){if(0===e)return"0";const s=n[t].significand||e/Math.pow(10,Math.floor(ke(e)));return[1,2,3,5,10,15].includes(s)||t>.8*n.length?ot.numeric.call(this,e,t,n):""}};var lt={formatters:ot};const ut=Object.create(null),ct=Object.create(null);function ht(e,t){if(!t)return e;const n=t.split(".");for(let s=0,r=n.length;s<r;++s){const t=n[s];e=e[t]||(e[t]=Object.create(null))}return e}function dt(e,t,n){return"string"===typeof t?ie(ht(e,t),n):ie(ht(e,""),t)}class pt{constructor(e,t){this.animation=void 0,this.backgroundColor="rgba(0,0,0,0.1)",this.borderColor="rgba(0,0,0,0.1)",this.color="#666",this.datasets={},this.devicePixelRatio=e=>e.chart.platform.getDevicePixelRatio(),this.elements={},this.events=["mousemove","mouseout","click","touchstart","touchmove"],this.font={family:"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",size:12,style:"normal",lineHeight:1.2,weight:null},this.hover={},this.hoverBackgroundColor=(e,t)=>nt(t.backgroundColor),this.hoverBorderColor=(e,t)=>nt(t.borderColor),this.hoverColor=(e,t)=>nt(t.color),this.indexAxis="x",this.interaction={mode:"nearest",intersect:!0,includeInvisible:!1},this.maintainAspectRatio=!0,this.onHover=null,this.onClick=null,this.parsing=!0,this.plugins={},this.responsive=!0,this.scale=void 0,this.scales={},this.showLine=!0,this.drawActiveElementsOnTop=!0,this.describe(e),this.apply(t)}set(e,t){return dt(this,e,t)}get(e){return ht(this,e)}describe(e,t){return dt(ct,e,t)}override(e,t){return dt(ut,e,t)}route(e,t,n,s){const r=ht(this,e),i=ht(this,n),a="_"+t;Object.defineProperties(r,{[a]:{value:r[t],writable:!0},[t]:{enumerable:!0,get(){const e=this[a],t=i[s];return X(e)?Object.assign({},t,e):Q(e,t)},set(e){this[a]=e}}})}apply(e){e.forEach((e=>e(this)))}}var ft=new pt({_scriptable:e=>!e.startsWith("on"),_indexable:e=>"events"!==e,hover:{_fallback:"interaction"},interaction:{_scriptable:!1,_indexable:!1}},[function(e){e.set("animation",{delay:void 0,duration:1e3,easing:"easeOutQuart",fn:void 0,from:void 0,loop:void 0,to:void 0,type:void 0}),e.describe("animation",{_fallback:!1,_indexable:!1,_scriptable:e=>"onProgress"!==e&&"onComplete"!==e&&"fn"!==e}),e.set("animations",{colors:{type:"color",properties:rt},numbers:{type:"number",properties:st}}),e.describe("animations",{_fallback:"animation"}),e.set("transitions",{active:{animation:{duration:400}},resize:{animation:{duration:0}},show:{animations:{colors:{from:"transparent"},visible:{type:"boolean",duration:0}}},hide:{animations:{colors:{to:"transparent"},visible:{type:"boolean",easing:"linear",fn:e=>0|e}}}})},function(e){e.set("layout",{autoPadding:!0,padding:{top:0,right:0,bottom:0,left:0}})},function(e){e.set("scale",{display:!0,offset:!1,reverse:!1,beginAtZero:!1,bounds:"ticks",clip:!0,grace:0,grid:{display:!0,lineWidth:1,drawOnChartArea:!0,drawTicks:!0,tickLength:8,tickWidth:(e,t)=>t.lineWidth,tickColor:(e,t)=>t.color,offset:!1},border:{display:!0,dash:[],dashOffset:0,width:1},title:{display:!1,text:"",padding:{top:4,bottom:4}},ticks:{minRotation:0,maxRotation:50,mirror:!1,textStrokeWidth:0,textStrokeColor:"",padding:3,display:!0,autoSkip:!0,autoSkipPadding:3,labelOffset:0,callback:lt.formatters.values,minor:{},major:{},align:"center",crossAlign:"near",showLabelBackdrop:!1,backdropColor:"rgba(255, 255, 255, 0.75)",backdropPadding:2}}),e.route("scale.ticks","color","","color"),e.route("scale.grid","color","","borderColor"),e.route("scale.border","color","","borderColor"),e.route("scale.title","color","","color"),e.describe("scale",{_fallback:!1,_scriptable:e=>!e.startsWith("before")&&!e.startsWith("after")&&"callback"!==e&&"parser"!==e,_indexable:e=>"borderDash"!==e&&"tickBorderDash"!==e&&"dash"!==e}),e.describe("scales",{_fallback:"scale"}),e.describe("scale.ticks",{_scriptable:e=>"backdropPadding"!==e&&"callback"!==e,_indexable:e=>"backdropPadding"!==e})}]);function gt(e,t,n,s,r){let i=t[r];return i||(i=t[r]=e.measureText(r).width,n.push(r)),i>s&&(s=i),s}function mt(e,t,n,s){let r=(s=s||{}).data=s.data||{},i=s.garbageCollect=s.garbageCollect||[];s.font!==t&&(r=s.data={},i=s.garbageCollect=[],s.font=t),e.save(),e.font=t;let a=0;const o=n.length;let l,u,c,h,d;for(l=0;l<o;l++)if(h=n[l],void 0===h||null===h||K(h)){if(K(h))for(u=0,c=h.length;u<c;u++)d=h[u],void 0===d||null===d||K(d)||(a=gt(e,r,i,a,d))}else a=gt(e,r,i,a,h);e.restore();const p=i.length/2;if(p>n.length){for(l=0;l<p;l++)delete r[i[l]];i.splice(0,p)}return a}function bt(e,t,n){const s=e.currentDevicePixelRatio,r=0!==n?Math.max(n/2,.5):0;return Math.round((t-r)*s)/s+r}function xt(e,t){(t||e)&&((t=t||e.getContext("2d")).save(),t.resetTransform(),t.clearRect(0,0,e.width,e.height),t.restore())}function yt(e,t,n,s){vt(e,t,n,s,null)}function vt(e,t,n,s,r){let i,a,o,l,u,c,h,d;const p=t.pointStyle,f=t.rotation,g=t.radius;let m=(f||0)*xe;if(p&&"object"===typeof p&&(i=p.toString(),"[object HTMLImageElement]"===i||"[object HTMLCanvasElement]"===i))return e.save(),e.translate(n,s),e.rotate(m),e.drawImage(p,-p.width/2,-p.height/2,p.width,p.height),void e.restore();if(!(isNaN(g)||g<=0)){switch(e.beginPath(),p){default:r?e.ellipse(n,s,r/2,g,0,0,ge):e.arc(n,s,g,0,ge),e.closePath();break;case"triangle":c=r?r/2:g,e.moveTo(n+Math.sin(m)*c,s-Math.cos(m)*g),m+=we,e.lineTo(n+Math.sin(m)*c,s-Math.cos(m)*g),m+=we,e.lineTo(n+Math.sin(m)*c,s-Math.cos(m)*g),e.closePath();break;case"rectRounded":u=.516*g,l=g-u,a=Math.cos(m+ve)*l,h=Math.cos(m+ve)*(r?r/2-u:l),o=Math.sin(m+ve)*l,d=Math.sin(m+ve)*(r?r/2-u:l),e.arc(n-h,s-o,u,m-fe,m-ye),e.arc(n+d,s-a,u,m-ye,m),e.arc(n+h,s+o,u,m,m+ye),e.arc(n-d,s+a,u,m+ye,m+fe),e.closePath();break;case"rect":if(!f){l=Math.SQRT1_2*g,c=r?r/2:l,e.rect(n-c,s-l,2*c,2*l);break}m+=ve;case"rectRot":h=Math.cos(m)*(r?r/2:g),a=Math.cos(m)*g,o=Math.sin(m)*g,d=Math.sin(m)*(r?r/2:g),e.moveTo(n-h,s-o),e.lineTo(n+d,s-a),e.lineTo(n+h,s+o),e.lineTo(n-d,s+a),e.closePath();break;case"crossRot":m+=ve;case"cross":h=Math.cos(m)*(r?r/2:g),a=Math.cos(m)*g,o=Math.sin(m)*g,d=Math.sin(m)*(r?r/2:g),e.moveTo(n-h,s-o),e.lineTo(n+h,s+o),e.moveTo(n+d,s-a),e.lineTo(n-d,s+a);break;case"star":h=Math.cos(m)*(r?r/2:g),a=Math.cos(m)*g,o=Math.sin(m)*g,d=Math.sin(m)*(r?r/2:g),e.moveTo(n-h,s-o),e.lineTo(n+h,s+o),e.moveTo(n+d,s-a),e.lineTo(n-d,s+a),m+=ve,h=Math.cos(m)*(r?r/2:g),a=Math.cos(m)*g,o=Math.sin(m)*g,d=Math.sin(m)*(r?r/2:g),e.moveTo(n-h,s-o),e.lineTo(n+h,s+o),e.moveTo(n+d,s-a),e.lineTo(n-d,s+a);break;case"line":a=r?r/2:Math.cos(m)*g,o=Math.sin(m)*g,e.moveTo(n-a,s-o),e.lineTo(n+a,s+o);break;case"dash":e.moveTo(n,s),e.lineTo(n+Math.cos(m)*(r?r/2:g),s+Math.sin(m)*g);break;case!1:e.closePath()}e.fill(),t.borderWidth>0&&e.stroke()}}function wt(e,t,n){return n=n||.5,!t||e&&e.x>t.left-n&&e.x<t.right+n&&e.y>t.top-n&&e.y<t.bottom+n}function kt(e,t){e.save(),e.beginPath(),e.rect(t.left,t.top,t.right-t.left,t.bottom-t.top),e.clip()}function St(e){e.restore()}function It(e,t,n,s,r){if(!t)return e.lineTo(n.x,n.y);if("middle"===r){const s=(t.x+n.x)/2;e.lineTo(s,t.y),e.lineTo(s,n.y)}else"after"===r!==!!s?e.lineTo(t.x,n.y):e.lineTo(n.x,t.y);e.lineTo(n.x,n.y)}function Ct(e,t,n,s){if(!t)return e.lineTo(n.x,n.y);e.bezierCurveTo(s?t.cp1x:t.cp2x,s?t.cp1y:t.cp2y,s?n.cp2x:n.cp1x,s?n.cp2y:n.cp1y,n.x,n.y)}function Nt(e,t,n,s,r){if(r.strikethrough||r.underline){const i=e.measureText(s),a=t-i.actualBoundingBoxLeft,o=t+i.actualBoundingBoxRight,l=n-i.actualBoundingBoxAscent,u=n+i.actualBoundingBoxDescent,c=r.strikethrough?(l+u)/2:u;e.strokeStyle=e.fillStyle,e.beginPath(),e.lineWidth=r.decorationWidth||2,e.moveTo(a,c),e.lineTo(o,c),e.stroke()}}function Tt(e,t){const n=e.fillStyle;e.fillStyle=t.color,e.fillRect(t.left,t.top,t.width,t.height),e.fillStyle=n}function _t(e,t,n,s,r){let i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:{};const a=K(t)?t:[t],o=i.strokeWidth>0&&""!==i.strokeColor;let l,u;for(e.save(),e.font=r.string,function(e,t){t.translation&&e.translate(t.translation[0],t.translation[1]),j(t.rotation)||e.rotate(t.rotation),t.color&&(e.fillStyle=t.color),t.textAlign&&(e.textAlign=t.textAlign),t.textBaseline&&(e.textBaseline=t.textBaseline)}(e,i),l=0;l<a.length;++l)u=a[l],i.backdrop&&Tt(e,i.backdrop),o&&(i.strokeColor&&(e.strokeStyle=i.strokeColor),j(i.strokeWidth)||(e.lineWidth=i.strokeWidth),e.strokeText(u,n,s,i.maxWidth)),e.fillText(u,n,s,i.maxWidth),Nt(e,n,s,u,i),s+=Number(r.lineHeight);e.restore()}function Et(e,t){const{x:n,y:s,w:r,h:i,radius:a}=t;e.arc(n+a.topLeft,s+a.topLeft,a.topLeft,1.5*fe,fe,!0),e.lineTo(n,s+i-a.bottomLeft),e.arc(n+a.bottomLeft,s+i-a.bottomLeft,a.bottomLeft,fe,ye,!0),e.lineTo(n+r-a.bottomRight,s+i),e.arc(n+r-a.bottomRight,s+i-a.bottomRight,a.bottomRight,ye,0,!0),e.lineTo(n+r,s+a.topRight),e.arc(n+r-a.topRight,s+a.topRight,a.topRight,0,-ye,!0),e.lineTo(n+a.topLeft,s)}const $t=/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/,Rt=/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;function At(e,t){const n=(""+e).match($t);if(!n||"normal"===n[1])return 1.2*t;switch(e=+n[2],n[3]){case"px":return e;case"%":e/=100}return t*e}function Dt(e,t){const n={},s=X(t),r=s?Object.keys(t):t,i=X(e)?s?n=>Q(e[n],e[t[n]]):t=>e[t]:()=>e;for(const a of r)n[a]=+i(a)||0;return n}function Ft(e){return Dt(e,{top:"y",right:"x",bottom:"y",left:"x"})}function Mt(e){return Dt(e,["topLeft","topRight","bottomLeft","bottomRight"])}function Ot(e){const t=Ft(e);return t.width=t.left+t.right,t.height=t.top+t.bottom,t}function Lt(e,t){e=e||{},t=t||ft.font;let n=Q(e.size,t.size);"string"===typeof n&&(n=parseInt(n,10));let s=Q(e.style,t.style);s&&!(""+s).match(Rt)&&(console.warn('Invalid font style specified: "'+s+'"'),s=void 0);const r={family:Q(e.family,t.family),lineHeight:At(Q(e.lineHeight,t.lineHeight),n),size:n,style:s,weight:Q(e.weight,t.weight),string:""};return r.string=function(e){return!e||j(e.size)||j(e.family)?null:(e.style?e.style+" ":"")+(e.weight?e.weight+" ":"")+e.size+"px "+e.family}(r),r}function Pt(e,t,n,s){let r,i,a,o=!0;for(r=0,i=e.length;r<i;++r)if(a=e[r],void 0!==a&&(void 0!==t&&"function"===typeof a&&(a=a(t),o=!1),void 0!==n&&K(a)&&(a=a[n%a.length],o=!1),void 0!==a))return s&&!o&&(s.cacheable=!1),a}function zt(e,t){return Object.assign(Object.create(e),t)}function Bt(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[""],n=arguments.length>3?arguments[3]:void 0,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:()=>e[0];const r=(arguments.length>2?arguments[2]:void 0)||e;"undefined"===typeof n&&(n=Qt("_fallback",e));const i={[Symbol.toStringTag]:"Object",_cacheable:!0,_scopes:e,_rootScopes:r,_fallback:n,_getTarget:s,override:s=>Bt([s,...e],t,r,n)};return new Proxy(i,{deleteProperty:(t,n)=>(delete t[n],delete t._keys,delete e[0][n],!0),get:(n,s)=>Ht(n,s,(()=>function(e,t,n,s){let r;for(const i of t)if(r=Qt(Ut(i,e),n),"undefined"!==typeof r)return Gt(e,r)?qt(n,s,e,r):r}(s,t,e,n))),getOwnPropertyDescriptor:(e,t)=>Reflect.getOwnPropertyDescriptor(e._scopes[0],t),getPrototypeOf:()=>Reflect.getPrototypeOf(e[0]),has:(e,t)=>Zt(e).includes(t),ownKeys:e=>Zt(e),set(e,t,n){const r=e._storage||(e._storage=s());return e[t]=r[t]=n,delete e._keys,!0}})}function Wt(e,t,n,s){const r={_cacheable:!1,_proxy:e,_context:t,_subProxy:n,_stack:new Set,_descriptors:Vt(e,s),setContext:t=>Wt(e,t,n,s),override:r=>Wt(e.override(r),t,n,s)};return new Proxy(r,{deleteProperty:(t,n)=>(delete t[n],delete e[n],!0),get:(e,t,n)=>Ht(e,t,(()=>function(e,t,n){const{_proxy:s,_context:r,_subProxy:i,_descriptors:a}=e;let o=s[t];de(o)&&a.isScriptable(t)&&(o=function(e,t,n,s){const{_proxy:r,_context:i,_subProxy:a,_stack:o}=n;if(o.has(e))throw new Error("Recursion detected: "+Array.from(o).join("->")+"->"+e);o.add(e);let l=t(i,a||s);o.delete(e),Gt(e,l)&&(l=qt(r._scopes,r,e,l));return l}(t,o,e,n));K(o)&&o.length&&(o=function(e,t,n,s){const{_proxy:r,_context:i,_subProxy:a,_descriptors:o}=n;if("undefined"!==typeof i.index&&s(e))return t[i.index%t.length];if(X(t[0])){const n=t,s=r._scopes.filter((e=>e!==n));t=[];for(const l of n){const n=qt(s,r,e,l);t.push(Wt(n,i,a&&a[e],o))}}return t}(t,o,e,a.isIndexable));Gt(t,o)&&(o=Wt(o,r,i&&i[t],a));return o}(e,t,n))),getOwnPropertyDescriptor:(t,n)=>t._descriptors.allKeys?Reflect.has(e,n)?{enumerable:!0,configurable:!0}:void 0:Reflect.getOwnPropertyDescriptor(e,n),getPrototypeOf:()=>Reflect.getPrototypeOf(e),has:(t,n)=>Reflect.has(e,n),ownKeys:()=>Reflect.ownKeys(e),set:(t,n,s)=>(e[n]=s,delete t[n],!0)})}function Vt(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{scriptable:!0,indexable:!0};const{_scriptable:n=t.scriptable,_indexable:s=t.indexable,_allKeys:r=t.allKeys}=e;return{allKeys:r,scriptable:n,indexable:s,isScriptable:de(n)?n:()=>n,isIndexable:de(s)?s:()=>s}}const Ut=(e,t)=>e?e+ce(t):t,Gt=(e,t)=>X(t)&&"adapters"!==e&&(null===Object.getPrototypeOf(t)||t.constructor===Object);function Ht(e,t,n){if(Object.prototype.hasOwnProperty.call(e,t)||"constructor"===t)return e[t];const s=n();return e[t]=s,s}function jt(e,t,n){return de(e)?e(t,n):e}const Kt=(e,t)=>!0===e?t:"string"===typeof e?ue(t,e):void 0;function Xt(e,t,n,s,r){for(const i of t){const t=Kt(n,i);if(t){e.add(t);const i=jt(t._fallback,n,r);if("undefined"!==typeof i&&i!==n&&i!==s)return i}else if(!1===t&&"undefined"!==typeof s&&n!==s)return null}return!1}function qt(e,t,n,s){const r=t._rootScopes,i=jt(t._fallback,n,s),a=[...e,...r],o=new Set;o.add(s);let l=Yt(o,a,n,i||n,s);return null!==l&&(("undefined"===typeof i||i===n||(l=Yt(o,a,i,l,s),null!==l))&&Bt(Array.from(o),[""],r,i,(()=>function(e,t,n){const s=e._getTarget();t in s||(s[t]={});const r=s[t];if(K(r)&&X(n))return n;return r||{}}(t,n,s))))}function Yt(e,t,n,s,r){for(;n;)n=Xt(e,t,n,s,r);return n}function Qt(e,t){for(const n of t){if(!n)continue;const t=n[e];if("undefined"!==typeof t)return t}}function Zt(e){let t=e._keys;return t||(t=e._keys=function(e){const t=new Set;for(const n of e)for(const e of Object.keys(n).filter((e=>!e.startsWith("_"))))t.add(e);return Array.from(t)}(e._scopes)),t}function Jt(e,t,n,s){const{iScale:r}=e,{key:i="r"}=this._parsing,a=new Array(s);let o,l,u,c;for(o=0,l=s;o<l;++o)u=o+n,c=t[u],a[o]={r:r.parse(ue(c,i),u)};return a}const en=Number.EPSILON||1e-14,tn=(e,t)=>t<e.length&&!e[t].skip&&e[t],nn=e=>"x"===e?"y":"x";function sn(e,t,n,s){const r=e.skip?t:e,i=t,a=n.skip?t:n,o=Ae(i,r),l=Ae(a,i);let u=o/(o+l),c=l/(o+l);u=isNaN(u)?0:u,c=isNaN(c)?0:c;const h=s*u,d=s*c;return{previous:{x:i.x-h*(a.x-r.x),y:i.y-h*(a.y-r.y)},next:{x:i.x+d*(a.x-r.x),y:i.y+d*(a.y-r.y)}}}function rn(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"x";const n=nn(t),s=e.length,r=Array(s).fill(0),i=Array(s);let a,o,l,u=tn(e,0);for(a=0;a<s;++a)if(o=l,l=u,u=tn(e,a+1),l){if(u){const e=u[t]-l[t];r[a]=0!==e?(u[n]-l[n])/e:0}i[a]=o?u?Se(r[a-1])!==Se(r[a])?0:(r[a-1]+r[a])/2:r[a-1]:r[a]}!function(e,t,n){const s=e.length;let r,i,a,o,l,u=tn(e,0);for(let c=0;c<s-1;++c)l=u,u=tn(e,c+1),l&&u&&(Ie(t[c],0,en)?n[c]=n[c+1]=0:(r=n[c]/t[c],i=n[c+1]/t[c],o=Math.pow(r,2)+Math.pow(i,2),o<=9||(a=3/Math.sqrt(o),n[c]=r*a*t[c],n[c+1]=i*a*t[c])))}(e,r,i),function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"x";const s=nn(n),r=e.length;let i,a,o,l=tn(e,0);for(let u=0;u<r;++u){if(a=o,o=l,l=tn(e,u+1),!o)continue;const r=o[n],c=o[s];a&&(i=(r-a[n])/3,o[`cp1${n}`]=r-i,o[`cp1${s}`]=c-i*t[u]),l&&(i=(l[n]-r)/3,o[`cp2${n}`]=r+i,o[`cp2${s}`]=c+i*t[u])}}(e,i,t)}function an(e,t,n){return Math.max(Math.min(e,n),t)}function on(e,t,n,s,r){let i,a,o,l;if(t.spanGaps&&(e=e.filter((e=>!e.skip))),"monotone"===t.cubicInterpolationMode)rn(e,r);else{let n=s?e[e.length-1]:e[0];for(i=0,a=e.length;i<a;++i)o=e[i],l=sn(n,o,e[Math.min(i+1,a-(s?0:1))%a],t.tension),o.cp1x=l.previous.x,o.cp1y=l.previous.y,o.cp2x=l.next.x,o.cp2y=l.next.y,n=o}t.capBezierPoints&&function(e,t){let n,s,r,i,a,o=wt(e[0],t);for(n=0,s=e.length;n<s;++n)a=i,i=o,o=n<s-1&&wt(e[n+1],t),i&&(r=e[n],a&&(r.cp1x=an(r.cp1x,t.left,t.right),r.cp1y=an(r.cp1y,t.top,t.bottom)),o&&(r.cp2x=an(r.cp2x,t.left,t.right),r.cp2y=an(r.cp2y,t.top,t.bottom)))}(e,n)}function ln(){return"undefined"!==typeof window&&"undefined"!==typeof document}function un(e){let t=e.parentNode;return t&&"[object ShadowRoot]"===t.toString()&&(t=t.host),t}function cn(e,t,n){let s;return"string"===typeof e?(s=parseInt(e,10),-1!==e.indexOf("%")&&(s=s/100*t.parentNode[n])):s=e,s}const hn=e=>e.ownerDocument.defaultView.getComputedStyle(e,null);const dn=["top","right","bottom","left"];function pn(e,t,n){const s={};n=n?"-"+n:"";for(let r=0;r<4;r++){const i=dn[r];s[i]=parseFloat(e[t+"-"+i+n])||0}return s.width=s.left+s.right,s.height=s.top+s.bottom,s}function fn(e,t){if("native"in e)return e;const{canvas:n,currentDevicePixelRatio:s}=t,r=hn(n),i="border-box"===r.boxSizing,a=pn(r,"padding"),o=pn(r,"border","width"),{x:l,y:u,box:c}=function(e,t){const n=e.touches,s=n&&n.length?n[0]:e,{offsetX:r,offsetY:i}=s;let a,o,l=!1;if(((e,t,n)=>(e>0||t>0)&&(!n||!n.shadowRoot))(r,i,e.target))a=r,o=i;else{const e=t.getBoundingClientRect();a=s.clientX-e.left,o=s.clientY-e.top,l=!0}return{x:a,y:o,box:l}}(e,n),h=a.left+(c&&o.left),d=a.top+(c&&o.top);let{width:p,height:f}=t;return i&&(p-=a.width+o.width,f-=a.height+o.height),{x:Math.round((l-h)/p*n.width/s),y:Math.round((u-d)/f*n.height/s)}}const gn=e=>Math.round(10*e)/10;function mn(e,t,n,s){const r=hn(e),i=pn(r,"margin"),a=cn(r.maxWidth,e,"clientWidth")||be,o=cn(r.maxHeight,e,"clientHeight")||be,l=function(e,t,n){let s,r;if(void 0===t||void 0===n){const i=e&&un(e);if(i){const e=i.getBoundingClientRect(),a=hn(i),o=pn(a,"border","width"),l=pn(a,"padding");t=e.width-l.width-o.width,n=e.height-l.height-o.height,s=cn(a.maxWidth,i,"clientWidth"),r=cn(a.maxHeight,i,"clientHeight")}else t=e.clientWidth,n=e.clientHeight}return{width:t,height:n,maxWidth:s||be,maxHeight:r||be}}(e,t,n);let{width:u,height:c}=l;if("content-box"===r.boxSizing){const e=pn(r,"border","width"),t=pn(r,"padding");u-=t.width+e.width,c-=t.height+e.height}u=Math.max(0,u-i.width),c=Math.max(0,s?u/s:c-i.height),u=gn(Math.min(u,a,l.maxWidth)),c=gn(Math.min(c,o,l.maxHeight)),u&&!c&&(c=gn(u/2));return(void 0!==t||void 0!==n)&&s&&l.height&&c>l.height&&(c=l.height,u=gn(Math.floor(c*s))),{width:u,height:c}}function bn(e,t,n){const s=t||1,r=Math.floor(e.height*s),i=Math.floor(e.width*s);e.height=Math.floor(e.height),e.width=Math.floor(e.width);const a=e.canvas;return a.style&&(n||!a.style.height&&!a.style.width)&&(a.style.height=`${e.height}px`,a.style.width=`${e.width}px`),(e.currentDevicePixelRatio!==s||a.height!==r||a.width!==i)&&(e.currentDevicePixelRatio=s,a.height=r,a.width=i,e.ctx.setTransform(s,0,0,s,0,0),!0)}const xn=function(){let e=!1;try{const t={get passive(){return e=!0,!1}};ln()&&(window.addEventListener("test",null,t),window.removeEventListener("test",null,t))}catch(t){}return e}();function yn(e,t){const n=function(e,t){return hn(e).getPropertyValue(t)}(e,t),s=n&&n.match(/^(\d+)(\.\d+)?px$/);return s?+s[1]:void 0}function vn(e,t,n,s){return{x:e.x+n*(t.x-e.x),y:e.y+n*(t.y-e.y)}}function wn(e,t,n,s){return{x:e.x+n*(t.x-e.x),y:"middle"===s?n<.5?e.y:t.y:"after"===s?n<1?e.y:t.y:n>0?t.y:e.y}}function kn(e,t,n,s){const r={x:e.cp2x,y:e.cp2y},i={x:t.cp1x,y:t.cp1y},a=vn(e,r,n),o=vn(r,i,n),l=vn(i,t,n),u=vn(a,o,n),c=vn(o,l,n);return vn(u,c,n)}function Sn(e,t,n){return e?function(e,t){return{x:n=>e+e+t-n,setWidth(e){t=e},textAlign:e=>"center"===e?e:"right"===e?"left":"right",xPlus:(e,t)=>e-t,leftForLtr:(e,t)=>e-t}}(t,n):{x:e=>e,setWidth(e){},textAlign:e=>e,xPlus:(e,t)=>e+t,leftForLtr:(e,t)=>e}}function In(e,t){let n,s;"ltr"!==t&&"rtl"!==t||(n=e.canvas.style,s=[n.getPropertyValue("direction"),n.getPropertyPriority("direction")],n.setProperty("direction",t,"important"),e.prevTextDirection=s)}function Cn(e,t){void 0!==t&&(delete e.prevTextDirection,e.canvas.style.setProperty("direction",t[0],t[1]))}function Nn(e){return"angle"===e?{between:Me,compare:De,normalize:Fe}:{between:Le,compare:(e,t)=>e-t,normalize:e=>e}}function Tn(e){let{start:t,end:n,count:s,loop:r,style:i}=e;return{start:t%s,end:n%s,loop:r&&(n-t+1)%s===0,style:i}}function _n(e,t,n){if(!n)return[e];const{property:s,start:r,end:i}=n,a=t.length,{compare:o,between:l,normalize:u}=Nn(s),{start:c,end:h,loop:d,style:p}=function(e,t,n){const{property:s,start:r,end:i}=n,{between:a,normalize:o}=Nn(s),l=t.length;let u,c,{start:h,end:d,loop:p}=e;if(p){for(h+=l,d+=l,u=0,c=l;u<c&&a(o(t[h%l][s]),r,i);++u)h--,d--;h%=l,d%=l}return d<h&&(d+=l),{start:h,end:d,loop:p,style:e.style}}(e,t,n),f=[];let g,m,b,x=!1,y=null;const v=()=>x||l(r,b,g)&&0!==o(r,b),w=()=>!x||0===o(i,g)||l(i,b,g);for(let k=c,S=c;k<=h;++k)m=t[k%a],m.skip||(g=u(m[s]),g!==b&&(x=l(g,r,i),null===y&&v()&&(y=0===o(g,r)?k:S),null!==y&&w()&&(f.push(Tn({start:y,end:k,loop:d,count:a,style:p})),y=null),S=k,b=g));return null!==y&&f.push(Tn({start:y,end:h,loop:d,count:a,style:p})),f}function En(e,t){const n=[],s=e.segments;for(let r=0;r<s.length;r++){const i=_n(s[r],e.points,t);i.length&&n.push(...i)}return n}function $n(e,t,n,s){return s&&s.setContext&&n?function(e,t,n,s){const r=e._chart.getContext(),i=Rn(e.options),{_datasetIndex:a,options:{spanGaps:o}}=e,l=n.length,u=[];let c=i,h=t[0].start,d=h;function p(e,t,s,r){const i=o?-1:1;if(e!==t){for(e+=l;n[e%l].skip;)e-=i;for(;n[t%l].skip;)t+=i;e%l!==t%l&&(u.push({start:e%l,end:t%l,loop:s,style:r}),c=r,h=t%l)}}for(const f of t){h=o?h:f.start;let e,t=n[h%l];for(d=h+1;d<=f.end;d++){const i=n[d%l];e=Rn(s.setContext(zt(r,{type:"segment",p0:t,p1:i,p0DataIndex:(d-1)%l,p1DataIndex:d%l,datasetIndex:a}))),An(e,c)&&p(h,d-1,f.loop,c),t=i,c=e}h<d-1&&p(h,d-1,f.loop,c)}return u}(e,t,n,s):t}function Rn(e){return{backgroundColor:e.backgroundColor,borderCapStyle:e.borderCapStyle,borderDash:e.borderDash,borderDashOffset:e.borderDashOffset,borderJoinStyle:e.borderJoinStyle,borderWidth:e.borderWidth,borderColor:e.borderColor}}function An(e,t){if(!t)return!1;const n=[],s=function(e,t){return et(t)?(n.includes(t)||n.push(t),n.indexOf(t)):t};return JSON.stringify(e,s)!==JSON.stringify(t,s)}class Dn{constructor(){this._request=null,this._charts=new Map,this._running=!1,this._lastDate=void 0}_notify(e,t,n,s){const r=t.listeners[s],i=t.duration;r.forEach((s=>s({chart:e,initial:t.initial,numSteps:i,currentStep:Math.min(n-t.start,i)})))}_refresh(){this._request||(this._running=!0,this._request=Ge.call(window,(()=>{this._update(),this._request=null,this._running&&this._refresh()})))}_update(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Date.now(),t=0;this._charts.forEach(((n,s)=>{if(!n.running||!n.items.length)return;const r=n.items;let i,a=r.length-1,o=!1;for(;a>=0;--a)i=r[a],i._active?(i._total>n.duration&&(n.duration=i._total),i.tick(e),o=!0):(r[a]=r[r.length-1],r.pop());o&&(s.draw(),this._notify(s,n,e,"progress")),r.length||(n.running=!1,this._notify(s,n,e,"complete"),n.initial=!1),t+=r.length})),this._lastDate=e,0===t&&(this._running=!1)}_getAnims(e){const t=this._charts;let n=t.get(e);return n||(n={running:!1,initial:!0,items:[],listeners:{complete:[],progress:[]}},t.set(e,n)),n}listen(e,t,n){this._getAnims(e).listeners[t].push(n)}add(e,t){t&&t.length&&this._getAnims(e).items.push(...t)}has(e){return this._getAnims(e).items.length>0}start(e){const t=this._charts.get(e);t&&(t.running=!0,t.start=Date.now(),t.duration=t.items.reduce(((e,t)=>Math.max(e,t._duration)),0),this._refresh())}running(e){if(!this._running)return!1;const t=this._charts.get(e);return!!(t&&t.running&&t.items.length)}stop(e){const t=this._charts.get(e);if(!t||!t.items.length)return;const n=t.items;let s=n.length-1;for(;s>=0;--s)n[s].cancel();t.items=[],this._notify(e,t,Date.now(),"complete")}remove(e){return this._charts.delete(e)}}var Fn=new Dn;const Mn="transparent",On={boolean:(e,t,n)=>n>.5?t:e,color(e,t,n){const s=tt(e||Mn),r=s.valid&&tt(t||Mn);return r&&r.valid?r.mix(s,n).hexString():t},number:(e,t,n)=>e+(t-e)*n};class Ln{constructor(e,t,n,s){const r=t[n];s=Pt([e.to,s,r,e.from]);const i=Pt([e.from,r,s]);this._active=!0,this._fn=e.fn||On[e.type||typeof i],this._easing=Je[e.easing]||Je.linear,this._start=Math.floor(Date.now()+(e.delay||0)),this._duration=this._total=Math.floor(e.duration),this._loop=!!e.loop,this._target=t,this._prop=n,this._from=i,this._to=s,this._promises=void 0}active(){return this._active}update(e,t,n){if(this._active){this._notify(!1);const s=this._target[this._prop],r=n-this._start,i=this._duration-r;this._start=n,this._duration=Math.floor(Math.max(i,e.duration)),this._total+=r,this._loop=!!e.loop,this._to=Pt([e.to,t,s,e.from]),this._from=Pt([e.from,s,t])}}cancel(){this._active&&(this.tick(Date.now()),this._active=!1,this._notify(!1))}tick(e){const t=e-this._start,n=this._duration,s=this._prop,r=this._from,i=this._loop,a=this._to;let o;if(this._active=r!==a&&(i||t<n),!this._active)return this._target[s]=a,void this._notify(!0);t<0?this._target[s]=r:(o=t/n%2,o=i&&o>1?2-o:o,o=this._easing(Math.min(1,Math.max(0,o))),this._target[s]=this._fn(r,a,o))}wait(){const e=this._promises||(this._promises=[]);return new Promise(((t,n)=>{e.push({res:t,rej:n})}))}_notify(e){const t=e?"res":"rej",n=this._promises||[];for(let s=0;s<n.length;s++)n[s][t]()}}class Pn{constructor(e,t){this._chart=e,this._properties=new Map,this.configure(t)}configure(e){if(!X(e))return;const t=Object.keys(ft.animation),n=this._properties;Object.getOwnPropertyNames(e).forEach((s=>{const r=e[s];if(!X(r))return;const i={};for(const e of t)i[e]=r[e];(K(r.properties)&&r.properties||[s]).forEach((e=>{e!==s&&n.has(e)||n.set(e,i)}))}))}_animateOptions(e,t){const n=t.options,s=function(e,t){if(!t)return;let n=e.options;if(!n)return void(e.options=t);n.$shared&&(e.options=n=Object.assign({},n,{$shared:!1,$animations:{}}));return n}(e,n);if(!s)return[];const r=this._createAnimations(s,n);return n.$shared&&function(e,t){const n=[],s=Object.keys(t);for(let r=0;r<s.length;r++){const t=e[s[r]];t&&t.active()&&n.push(t.wait())}return Promise.all(n)}(e.options.$animations,n).then((()=>{e.options=n}),(()=>{})),r}_createAnimations(e,t){const n=this._properties,s=[],r=e.$animations||(e.$animations={}),i=Object.keys(t),a=Date.now();let o;for(o=i.length-1;o>=0;--o){const l=i[o];if("$"===l.charAt(0))continue;if("options"===l){s.push(...this._animateOptions(e,t));continue}const u=t[l];let c=r[l];const h=n.get(l);if(c){if(h&&c.active()){c.update(h,u,a);continue}c.cancel()}h&&h.duration?(r[l]=c=new Ln(h,e,l,u),s.push(c)):e[l]=u}return s}update(e,t){if(0===this._properties.size)return void Object.assign(e,t);const n=this._createAnimations(e,t);return n.length?(Fn.add(this._chart,n),!0):void 0}}function zn(e,t){const n=e&&e.options||{},s=n.reverse,r=void 0===n.min?t:0,i=void 0===n.max?t:0;return{start:s?i:r,end:s?r:i}}function Bn(e,t){const n=[],s=e._getSortedDatasetMetas(t);let r,i;for(r=0,i=s.length;r<i;++r)n.push(s[r].index);return n}function Wn(e,t,n){let s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};const r=e.keys,i="single"===s.mode;let a,o,l,u;if(null!==t){for(a=0,o=r.length;a<o;++a){if(l=+r[a],l===n){if(s.all)continue;break}u=e.values[l],q(u)&&(i||0===t||Se(t)===Se(u))&&(t+=u)}return t}}function Vn(e,t){const n=e&&e.options.stacked;return n||void 0===n&&void 0!==t.stack}function Un(e,t,n){const s=e[t]||(e[t]={});return s[n]||(s[n]={})}function Gn(e,t,n,s){for(const r of t.getMatchingVisibleMetas(s).reverse()){const t=e[r.index];if(n&&t>0||!n&&t<0)return r.index}return null}function Hn(e,t){const{chart:n,_cachedMeta:s}=e,r=n._stacks||(n._stacks={}),{iScale:i,vScale:a,index:o}=s,l=i.axis,u=a.axis,c=function(e,t,n){return`${e.id}.${t.id}.${n.stack||n.type}`}(i,a,s),h=t.length;let d;for(let p=0;p<h;++p){const e=t[p],{[l]:n,[u]:i}=e;d=(e._stacks||(e._stacks={}))[u]=Un(r,c,n),d[o]=i,d._top=Gn(d,a,!0,s.type),d._bottom=Gn(d,a,!1,s.type);(d._visualValues||(d._visualValues={}))[o]=i}}function jn(e,t){const n=e.scales;return Object.keys(n).filter((e=>n[e].axis===t)).shift()}function Kn(e,t){const n=e.controller.index,s=e.vScale&&e.vScale.axis;if(s){t=t||e._parsed;for(const e of t){const t=e._stacks;if(!t||void 0===t[s]||void 0===t[s][n])return;delete t[s][n],void 0!==t[s]._visualValues&&void 0!==t[s]._visualValues[n]&&delete t[s]._visualValues[n]}}}const Xn=e=>"reset"===e||"none"===e,qn=(e,t)=>t?e:Object.assign({},e);class Yn{static defaults={};static datasetElementType=null;static dataElementType=null;constructor(e,t){this.chart=e,this._ctx=e.ctx,this.index=t,this._cachedDataOpts={},this._cachedMeta=this.getMeta(),this._type=this._cachedMeta.type,this.options=void 0,this._parsing=!1,this._data=void 0,this._objectData=void 0,this._sharedOptions=void 0,this._drawStart=void 0,this._drawCount=void 0,this.enableOptionSharing=!1,this.supportsDecimation=!1,this.$context=void 0,this._syncList=[],this.datasetElementType=new.target.datasetElementType,this.dataElementType=new.target.dataElementType,this.initialize()}initialize(){const e=this._cachedMeta;this.configure(),this.linkScales(),e._stacked=Vn(e.vScale,e),this.addElements(),this.options.fill&&!this.chart.isPluginEnabled("filler")&&console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options")}updateIndex(e){this.index!==e&&Kn(this._cachedMeta),this.index=e}linkScales(){const e=this.chart,t=this._cachedMeta,n=this.getDataset(),s=(e,t,n,s)=>"x"===e?t:"r"===e?s:n,r=t.xAxisID=Q(n.xAxisID,jn(e,"x")),i=t.yAxisID=Q(n.yAxisID,jn(e,"y")),a=t.rAxisID=Q(n.rAxisID,jn(e,"r")),o=t.indexAxis,l=t.iAxisID=s(o,r,i,a),u=t.vAxisID=s(o,i,r,a);t.xScale=this.getScaleForId(r),t.yScale=this.getScaleForId(i),t.rScale=this.getScaleForId(a),t.iScale=this.getScaleForId(l),t.vScale=this.getScaleForId(u)}getDataset(){return this.chart.data.datasets[this.index]}getMeta(){return this.chart.getDatasetMeta(this.index)}getScaleForId(e){return this.chart.scales[e]}_getOtherScale(e){const t=this._cachedMeta;return e===t.iScale?t.vScale:t.iScale}reset(){this._update("reset")}_destroy(){const e=this._cachedMeta;this._data&&Ve(this._data,this),e._stacked&&Kn(e)}_dataCheck(){const e=this.getDataset(),t=e.data||(e.data=[]),n=this._data;if(X(t)){const e=this._cachedMeta;this._data=function(e,t){const{iScale:n,vScale:s}=t,r="x"===n.axis?"x":"y",i="x"===s.axis?"x":"y",a=Object.keys(e),o=new Array(a.length);let l,u,c;for(l=0,u=a.length;l<u;++l)c=a[l],o[l]={[r]:c,[i]:e[c]};return o}(t,e)}else if(n!==t){if(n){Ve(n,this);const e=this._cachedMeta;Kn(e),e._parsed=[]}t&&Object.isExtensible(t)&&function(e,t){e._chartjs?e._chartjs.listeners.push(t):(Object.defineProperty(e,"_chartjs",{configurable:!0,enumerable:!1,value:{listeners:[t]}}),We.forEach((t=>{const n="_onData"+ce(t),s=e[t];Object.defineProperty(e,t,{configurable:!0,enumerable:!1,value(){for(var t=arguments.length,r=new Array(t),i=0;i<t;i++)r[i]=arguments[i];const a=s.apply(this,r);return e._chartjs.listeners.forEach((e=>{"function"===typeof e[n]&&e[n](...r)})),a}})})))}(t,this),this._syncList=[],this._data=t}}addElements(){const e=this._cachedMeta;this._dataCheck(),this.datasetElementType&&(e.dataset=new this.datasetElementType)}buildOrUpdateElements(e){const t=this._cachedMeta,n=this.getDataset();let s=!1;this._dataCheck();const r=t._stacked;t._stacked=Vn(t.vScale,t),t.stack!==n.stack&&(s=!0,Kn(t),t.stack=n.stack),this._resyncElements(e),(s||r!==t._stacked)&&(Hn(this,t._parsed),t._stacked=Vn(t.vScale,t))}configure(){const e=this.chart.config,t=e.datasetScopeKeys(this._type),n=e.getOptionScopes(this.getDataset(),t,!0);this.options=e.createResolver(n,this.getContext()),this._parsing=this.options.parsing,this._cachedDataOpts={}}parse(e,t){const{_cachedMeta:n,_data:s}=this,{iScale:r,_stacked:i}=n,a=r.axis;let o,l,u,c=0===e&&t===s.length||n._sorted,h=e>0&&n._parsed[e-1];if(!1===this._parsing)n._parsed=s,n._sorted=!0,u=s;else{u=K(s[e])?this.parseArrayData(n,s,e,t):X(s[e])?this.parseObjectData(n,s,e,t):this.parsePrimitiveData(n,s,e,t);const r=()=>null===l[a]||h&&l[a]<h[a];for(o=0;o<t;++o)n._parsed[o+e]=l=u[o],c&&(r()&&(c=!1),h=l);n._sorted=c}i&&Hn(this,u)}parsePrimitiveData(e,t,n,s){const{iScale:r,vScale:i}=e,a=r.axis,o=i.axis,l=r.getLabels(),u=r===i,c=new Array(s);let h,d,p;for(h=0,d=s;h<d;++h)p=h+n,c[h]={[a]:u||r.parse(l[p],p),[o]:i.parse(t[p],p)};return c}parseArrayData(e,t,n,s){const{xScale:r,yScale:i}=e,a=new Array(s);let o,l,u,c;for(o=0,l=s;o<l;++o)u=o+n,c=t[u],a[o]={x:r.parse(c[0],u),y:i.parse(c[1],u)};return a}parseObjectData(e,t,n,s){const{xScale:r,yScale:i}=e,{xAxisKey:a="x",yAxisKey:o="y"}=this._parsing,l=new Array(s);let u,c,h,d;for(u=0,c=s;u<c;++u)h=u+n,d=t[h],l[u]={x:r.parse(ue(d,a),h),y:i.parse(ue(d,o),h)};return l}getParsed(e){return this._cachedMeta._parsed[e]}getDataElement(e){return this._cachedMeta.data[e]}applyStack(e,t,n){const s=this.chart,r=this._cachedMeta,i=t[e.axis];return Wn({keys:Bn(s,!0),values:t._stacks[e.axis]._visualValues},i,r.index,{mode:n})}updateRangeFromParsed(e,t,n,s){const r=n[t.axis];let i=null===r?NaN:r;const a=s&&n._stacks[t.axis];s&&a&&(s.values=a,i=Wn(s,r,this._cachedMeta.index)),e.min=Math.min(e.min,i),e.max=Math.max(e.max,i)}getMinMax(e,t){const n=this._cachedMeta,s=n._parsed,r=n._sorted&&e===n.iScale,i=s.length,a=this._getOtherScale(e),o=((e,t,n)=>e&&!t.hidden&&t._stacked&&{keys:Bn(n,!0),values:null})(t,n,this.chart),l={min:Number.POSITIVE_INFINITY,max:Number.NEGATIVE_INFINITY},{min:u,max:c}=function(e){const{min:t,max:n,minDefined:s,maxDefined:r}=e.getUserBounds();return{min:s?t:Number.NEGATIVE_INFINITY,max:r?n:Number.POSITIVE_INFINITY}}(a);let h,d;function p(){d=s[h];const t=d[a.axis];return!q(d[e.axis])||u>t||c<t}for(h=0;h<i&&(p()||(this.updateRangeFromParsed(l,e,d,o),!r));++h);if(r)for(h=i-1;h>=0;--h)if(!p()){this.updateRangeFromParsed(l,e,d,o);break}return l}getAllParsedValues(e){const t=this._cachedMeta._parsed,n=[];let s,r,i;for(s=0,r=t.length;s<r;++s)i=t[s][e.axis],q(i)&&n.push(i);return n}getMaxOverflow(){return!1}getLabelAndValue(e){const t=this._cachedMeta,n=t.iScale,s=t.vScale,r=this.getParsed(e);return{label:n?""+n.getLabelForValue(r[n.axis]):"",value:s?""+s.getLabelForValue(r[s.axis]):""}}_update(e){const t=this._cachedMeta;this.update(e||"default"),t._clip=function(e){let t,n,s,r;return X(e)?(t=e.top,n=e.right,s=e.bottom,r=e.left):t=n=s=r=e,{top:t,right:n,bottom:s,left:r,disabled:!1===e}}(Q(this.options.clip,function(e,t,n){if(!1===n)return!1;const s=zn(e,n),r=zn(t,n);return{top:r.end,right:s.end,bottom:r.start,left:s.start}}(t.xScale,t.yScale,this.getMaxOverflow())))}update(e){}draw(){const e=this._ctx,t=this.chart,n=this._cachedMeta,s=n.data||[],r=t.chartArea,i=[],a=this._drawStart||0,o=this._drawCount||s.length-a,l=this.options.drawActiveElementsOnTop;let u;for(n.dataset&&n.dataset.draw(e,r,a,o),u=a;u<a+o;++u){const t=s[u];t.hidden||(t.active&&l?i.push(t):t.draw(e,r))}for(u=0;u<i.length;++u)i[u].draw(e,r)}getStyle(e,t){const n=t?"active":"default";return void 0===e&&this._cachedMeta.dataset?this.resolveDatasetElementOptions(n):this.resolveDataElementOptions(e||0,n)}getContext(e,t,n){const s=this.getDataset();let r;if(e>=0&&e<this._cachedMeta.data.length){const t=this._cachedMeta.data[e];r=t.$context||(t.$context=function(e,t,n){return zt(e,{active:!1,dataIndex:t,parsed:void 0,raw:void 0,element:n,index:t,mode:"default",type:"data"})}(this.getContext(),e,t)),r.parsed=this.getParsed(e),r.raw=s.data[e],r.index=r.dataIndex=e}else r=this.$context||(this.$context=function(e,t){return zt(e,{active:!1,dataset:void 0,datasetIndex:t,index:t,mode:"default",type:"dataset"})}(this.chart.getContext(),this.index)),r.dataset=s,r.index=r.datasetIndex=this.index;return r.active=!!t,r.mode=n,r}resolveDatasetElementOptions(e){return this._resolveElementOptions(this.datasetElementType.id,e)}resolveDataElementOptions(e,t){return this._resolveElementOptions(this.dataElementType.id,t,e)}_resolveElementOptions(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"default",n=arguments.length>2?arguments[2]:void 0;const s="active"===t,r=this._cachedDataOpts,i=e+"-"+t,a=r[i],o=this.enableOptionSharing&&he(n);if(a)return qn(a,o);const l=this.chart.config,u=l.datasetElementScopeKeys(this._type,e),c=s?[`${e}Hover`,"hover",e,""]:[e,""],h=l.getOptionScopes(this.getDataset(),u),d=Object.keys(ft.elements[e]),p=l.resolveNamedOptions(h,d,(()=>this.getContext(n,s,t)),c);return p.$shared&&(p.$shared=o,r[i]=Object.freeze(qn(p,o))),p}_resolveAnimations(e,t,n){const s=this.chart,r=this._cachedDataOpts,i=`animation-${t}`,a=r[i];if(a)return a;let o;if(!1!==s.options.animation){const s=this.chart.config,r=s.datasetAnimationScopeKeys(this._type,t),i=s.getOptionScopes(this.getDataset(),r);o=s.createResolver(i,this.getContext(e,n,t))}const l=new Pn(s,o&&o.animations);return o&&o._cacheable&&(r[i]=Object.freeze(l)),l}getSharedOptions(e){if(e.$shared)return this._sharedOptions||(this._sharedOptions=Object.assign({},e))}includeOptions(e,t){return!t||Xn(e)||this.chart._animationsDisabled}_getSharedOptions(e,t){const n=this.resolveDataElementOptions(e,t),s=this._sharedOptions,r=this.getSharedOptions(n),i=this.includeOptions(t,r)||r!==s;return this.updateSharedOptions(r,t,n),{sharedOptions:r,includeOptions:i}}updateElement(e,t,n,s){Xn(s)?Object.assign(e,n):this._resolveAnimations(t,s).update(e,n)}updateSharedOptions(e,t,n){e&&!Xn(t)&&this._resolveAnimations(void 0,t).update(e,n)}_setStyle(e,t,n,s){e.active=s;const r=this.getStyle(t,s);this._resolveAnimations(t,n,s).update(e,{options:!s&&this.getSharedOptions(r)||r})}removeHoverStyle(e,t,n){this._setStyle(e,n,"active",!1)}setHoverStyle(e,t,n){this._setStyle(e,n,"active",!0)}_removeDatasetHoverStyle(){const e=this._cachedMeta.dataset;e&&this._setStyle(e,void 0,"active",!1)}_setDatasetHoverStyle(){const e=this._cachedMeta.dataset;e&&this._setStyle(e,void 0,"active",!0)}_resyncElements(e){const t=this._data,n=this._cachedMeta.data;for(const[a,o,l]of this._syncList)this[a](o,l);this._syncList=[];const s=n.length,r=t.length,i=Math.min(r,s);i&&this.parse(0,i),r>s?this._insertElements(s,r-s,e):r<s&&this._removeElements(r,s-r)}_insertElements(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];const s=this._cachedMeta,r=s.data,i=e+t;let a;const o=e=>{for(e.length+=t,a=e.length-1;a>=i;a--)e[a]=e[a-t]};for(o(r),a=e;a<i;++a)r[a]=new this.dataElementType;this._parsing&&o(s._parsed),this.parse(e,t),n&&this.updateElements(r,e,t,"reset")}updateElements(e,t,n,s){}_removeElements(e,t){const n=this._cachedMeta;if(this._parsing){const s=n._parsed.splice(e,t);n._stacked&&Kn(n,s)}n.data.splice(e,t)}_sync(e){if(this._parsing)this._syncList.push(e);else{const[t,n,s]=e;this[t](n,s)}this.chart._dataChanges.push([this.index,...e])}_onDataPush(){const e=arguments.length;this._sync(["_insertElements",this.getDataset().data.length-e,e])}_onDataPop(){this._sync(["_removeElements",this._cachedMeta.data.length-1,1])}_onDataShift(){this._sync(["_removeElements",0,1])}_onDataSplice(e,t){t&&this._sync(["_removeElements",e,t]);const n=arguments.length-2;n&&this._sync(["_insertElements",e,n])}_onDataUnshift(){this._sync(["_insertElements",0,arguments.length])}}function Qn(e){const t=e.iScale,n=function(e,t){if(!e._cache.$bar){const n=e.getMatchingVisibleMetas(t);let s=[];for(let t=0,r=n.length;t<r;t++)s=s.concat(n[t].controller.getAllParsedValues(e));e._cache.$bar=Ue(s.sort(((e,t)=>e-t)))}return e._cache.$bar}(t,e.type);let s,r,i,a,o=t._length;const l=()=>{32767!==i&&-32768!==i&&(he(a)&&(o=Math.min(o,Math.abs(i-a)||o)),a=i)};for(s=0,r=n.length;s<r;++s)i=t.getPixelForValue(n[s]),l();for(a=void 0,s=0,r=t.ticks.length;s<r;++s)i=t.getPixelForTick(s),l();return o}function Zn(e,t,n,s){return K(e)?function(e,t,n,s){const r=n.parse(e[0],s),i=n.parse(e[1],s),a=Math.min(r,i),o=Math.max(r,i);let l=a,u=o;Math.abs(a)>Math.abs(o)&&(l=o,u=a),t[n.axis]=u,t._custom={barStart:l,barEnd:u,start:r,end:i,min:a,max:o}}(e,t,n,s):t[n.axis]=n.parse(e,s),t}function Jn(e,t,n,s){const r=e.iScale,i=e.vScale,a=r.getLabels(),o=r===i,l=[];let u,c,h,d;for(u=n,c=n+s;u<c;++u)d=t[u],h={},h[r.axis]=o||r.parse(a[u],u),l.push(Zn(d,h,i,u));return l}function es(e){return e&&void 0!==e.barStart&&void 0!==e.barEnd}function ts(e,t,n,s){let r=t.borderSkipped;const i={};if(!r)return void(e.borderSkipped=i);if(!0===r)return void(e.borderSkipped={top:!0,right:!0,bottom:!0,left:!0});const{start:a,end:o,reverse:l,top:u,bottom:c}=function(e){let t,n,s,r,i;return e.horizontal?(t=e.base>e.x,n="left",s="right"):(t=e.base<e.y,n="bottom",s="top"),t?(r="end",i="start"):(r="start",i="end"),{start:n,end:s,reverse:t,top:r,bottom:i}}(e);"middle"===r&&n&&(e.enableBorderRadius=!0,(n._top||0)===s?r=u:(n._bottom||0)===s?r=c:(i[ns(c,a,o,l)]=!0,r=u)),i[ns(r,a,o,l)]=!0,e.borderSkipped=i}function ns(e,t,n,s){var r,i,a;return s?(a=n,e=ss(e=(r=e)===(i=t)?a:r===a?i:r,n,t)):e=ss(e,t,n),e}function ss(e,t,n){return"start"===e?t:"end"===e?n:e}function rs(e,t,n){let{inflateAmount:s}=t;e.inflateAmount="auto"===s?1===n?.33:0:s}class is extends Yn{static id="doughnut";static defaults={datasetElementType:!1,dataElementType:"arc",animation:{animateRotate:!0,animateScale:!1},animations:{numbers:{type:"number",properties:["circumference","endAngle","innerRadius","outerRadius","startAngle","x","y","offset","borderWidth","spacing"]}},cutout:"50%",rotation:0,circumference:360,radius:"100%",spacing:0,indexAxis:"r"};static descriptors={_scriptable:e=>"spacing"!==e,_indexable:e=>"spacing"!==e&&!e.startsWith("borderDash")&&!e.startsWith("hoverBorderDash")};static overrides={aspectRatio:1,plugins:{legend:{labels:{generateLabels(e){const t=e.data;if(t.labels.length&&t.datasets.length){const{labels:{pointStyle:n,color:s}}=e.legend.options;return t.labels.map(((t,r)=>{const i=e.getDatasetMeta(0).controller.getStyle(r);return{text:t,fillStyle:i.backgroundColor,strokeStyle:i.borderColor,fontColor:s,lineWidth:i.borderWidth,pointStyle:n,hidden:!e.getDataVisibility(r),index:r}}))}return[]}},onClick(e,t,n){n.chart.toggleDataVisibility(t.index),n.chart.update()}}}};constructor(e,t){super(e,t),this.enableOptionSharing=!0,this.innerRadius=void 0,this.outerRadius=void 0,this.offsetX=void 0,this.offsetY=void 0}linkScales(){}parse(e,t){const n=this.getDataset().data,s=this._cachedMeta;if(!1===this._parsing)s._parsed=n;else{let r,i,a=e=>+n[e];if(X(n[e])){const{key:e="value"}=this._parsing;a=t=>+ue(n[t],e)}for(r=e,i=e+t;r<i;++r)s._parsed[r]=a(r)}}_getRotation(){return _e(this.options.rotation-90)}_getCircumference(){return _e(this.options.circumference)}_getRotationExtents(){let e=ge,t=-ge;for(let n=0;n<this.chart.data.datasets.length;++n)if(this.chart.isDatasetVisible(n)&&this.chart.getDatasetMeta(n).type===this._type){const s=this.chart.getDatasetMeta(n).controller,r=s._getRotation(),i=s._getCircumference();e=Math.min(e,r),t=Math.max(t,r+i)}return{rotation:e,circumference:t-e}}update(e){const t=this.chart,{chartArea:n}=t,s=this._cachedMeta,r=s.data,i=this.getMaxBorderWidth()+this.getMaxOffset(r)+this.options.spacing,a=Math.max((Math.min(n.width,n.height)-i)/2,0),o=Math.min((l=this.options.cutout,u=a,"string"===typeof l&&l.endsWith("%")?parseFloat(l)/100:+l/u),1);var l,u;const c=this._getRingWeight(this.index),{circumference:h,rotation:d}=this._getRotationExtents(),{ratioX:p,ratioY:f,offsetX:g,offsetY:m}=function(e,t,n){let s=1,r=1,i=0,a=0;if(t<ge){const o=e,l=o+t,u=Math.cos(o),c=Math.sin(o),h=Math.cos(l),d=Math.sin(l),p=(e,t,s)=>Me(e,o,l,!0)?1:Math.max(t,t*n,s,s*n),f=(e,t,s)=>Me(e,o,l,!0)?-1:Math.min(t,t*n,s,s*n),g=p(0,u,h),m=p(ye,c,d),b=f(fe,u,h),x=f(fe+ye,c,d);s=(g-b)/2,r=(m-x)/2,i=-(g+b)/2,a=-(m+x)/2}return{ratioX:s,ratioY:r,offsetX:i,offsetY:a}}(d,h,o),b=(n.width-i)/p,x=(n.height-i)/f,y=Math.max(Math.min(b,x)/2,0),v=Z(this.options.radius,y),w=(v-Math.max(v*o,0))/this._getVisibleDatasetWeightTotal();this.offsetX=g*v,this.offsetY=m*v,s.total=this.calculateTotal(),this.outerRadius=v-w*this._getRingWeightOffset(this.index),this.innerRadius=Math.max(this.outerRadius-w*c,0),this.updateElements(r,0,r.length,e)}_circumference(e,t){const n=this.options,s=this._cachedMeta,r=this._getCircumference();return t&&n.animation.animateRotate||!this.chart.getDataVisibility(e)||null===s._parsed[e]||s.data[e].hidden?0:this.calculateCircumference(s._parsed[e]*r/ge)}updateElements(e,t,n,s){const r="reset"===s,i=this.chart,a=i.chartArea,o=i.options.animation,l=(a.left+a.right)/2,u=(a.top+a.bottom)/2,c=r&&o.animateScale,h=c?0:this.innerRadius,d=c?0:this.outerRadius,{sharedOptions:p,includeOptions:f}=this._getSharedOptions(t,s);let g,m=this._getRotation();for(g=0;g<t;++g)m+=this._circumference(g,r);for(g=t;g<t+n;++g){const t=this._circumference(g,r),n=e[g],i={x:l+this.offsetX,y:u+this.offsetY,startAngle:m,endAngle:m+t,circumference:t,outerRadius:d,innerRadius:h};f&&(i.options=p||this.resolveDataElementOptions(g,n.active?"active":s)),m+=t,this.updateElement(n,g,i,s)}}calculateTotal(){const e=this._cachedMeta,t=e.data;let n,s=0;for(n=0;n<t.length;n++){const r=e._parsed[n];null===r||isNaN(r)||!this.chart.getDataVisibility(n)||t[n].hidden||(s+=Math.abs(r))}return s}calculateCircumference(e){const t=this._cachedMeta.total;return t>0&&!isNaN(e)?ge*(Math.abs(e)/t):0}getLabelAndValue(e){const t=this._cachedMeta,n=this.chart,s=n.data.labels||[],r=at(t._parsed[e],n.options.locale);return{label:s[e]||"",value:r}}getMaxBorderWidth(e){let t=0;const n=this.chart;let s,r,i,a,o;if(!e)for(s=0,r=n.data.datasets.length;s<r;++s)if(n.isDatasetVisible(s)){i=n.getDatasetMeta(s),e=i.data,a=i.controller;break}if(!e)return 0;for(s=0,r=e.length;s<r;++s)o=a.resolveDataElementOptions(s),"inner"!==o.borderAlign&&(t=Math.max(t,o.borderWidth||0,o.hoverBorderWidth||0));return t}getMaxOffset(e){let t=0;for(let n=0,s=e.length;n<s;++n){const e=this.resolveDataElementOptions(n);t=Math.max(t,e.offset||0,e.hoverOffset||0)}return t}_getRingWeightOffset(e){let t=0;for(let n=0;n<e;++n)this.chart.isDatasetVisible(n)&&(t+=this._getRingWeight(n));return t}_getRingWeight(e){return Math.max(Q(this.chart.data.datasets[e].weight,1),0)}_getVisibleDatasetWeightTotal(){return this._getRingWeightOffset(this.chart.data.datasets.length)||1}}class as extends Yn{static id="line";static defaults={datasetElementType:"line",dataElementType:"point",showLine:!0,spanGaps:!1};static overrides={scales:{_index_:{type:"category"},_value_:{type:"linear"}}};initialize(){this.enableOptionSharing=!0,this.supportsDecimation=!0,super.initialize()}update(e){const t=this._cachedMeta,{dataset:n,data:s=[],_dataset:r}=t,i=this.chart._animationsDisabled;let{start:a,count:o}=Xe(t,s,i);this._drawStart=a,this._drawCount=o,qe(t)&&(a=0,o=s.length),n._chart=this.chart,n._datasetIndex=this.index,n._decimated=!!r._decimated,n.points=s;const l=this.resolveDatasetElementOptions(e);this.options.showLine||(l.borderWidth=0),l.segment=this.options.segment,this.updateElement(n,void 0,{animated:!i,options:l},e),this.updateElements(s,a,o,e)}updateElements(e,t,n,s){const r="reset"===s,{iScale:i,vScale:a,_stacked:o,_dataset:l}=this._cachedMeta,{sharedOptions:u,includeOptions:c}=this._getSharedOptions(t,s),h=i.axis,d=a.axis,{spanGaps:p,segment:f}=this.options,g=Ne(p)?p:Number.POSITIVE_INFINITY,m=this.chart._animationsDisabled||r||"none"===s,b=t+n,x=e.length;let y=t>0&&this.getParsed(t-1);for(let v=0;v<x;++v){const n=e[v],p=m?n:{};if(v<t||v>=b){p.skip=!0;continue}const x=this.getParsed(v),w=j(x[d]),k=p[h]=i.getPixelForValue(x[h],v),S=p[d]=r||w?a.getBasePixel():a.getPixelForValue(o?this.applyStack(a,x,o):x[d],v);p.skip=isNaN(k)||isNaN(S)||w,p.stop=v>0&&Math.abs(x[h]-y[h])>g,f&&(p.parsed=x,p.raw=l.data[v]),c&&(p.options=u||this.resolveDataElementOptions(v,n.active?"active":s)),m||this.updateElement(n,v,p,s),y=x}}getMaxOverflow(){const e=this._cachedMeta,t=e.dataset,n=t.options&&t.options.borderWidth||0,s=e.data||[];if(!s.length)return n;const r=s[0].size(this.resolveDataElementOptions(0)),i=s[s.length-1].size(this.resolveDataElementOptions(s.length-1));return Math.max(n,r,i)/2}draw(){const e=this._cachedMeta;e.dataset.updateControlPoints(this.chart.chartArea,e.iScale.axis),super.draw()}}class os extends Yn{static id="polarArea";static defaults={dataElementType:"arc",animation:{animateRotate:!0,animateScale:!0},animations:{numbers:{type:"number",properties:["x","y","startAngle","endAngle","innerRadius","outerRadius"]}},indexAxis:"r",startAngle:0};static overrides={aspectRatio:1,plugins:{legend:{labels:{generateLabels(e){const t=e.data;if(t.labels.length&&t.datasets.length){const{labels:{pointStyle:n,color:s}}=e.legend.options;return t.labels.map(((t,r)=>{const i=e.getDatasetMeta(0).controller.getStyle(r);return{text:t,fillStyle:i.backgroundColor,strokeStyle:i.borderColor,fontColor:s,lineWidth:i.borderWidth,pointStyle:n,hidden:!e.getDataVisibility(r),index:r}}))}return[]}},onClick(e,t,n){n.chart.toggleDataVisibility(t.index),n.chart.update()}}},scales:{r:{type:"radialLinear",angleLines:{display:!1},beginAtZero:!0,grid:{circular:!0},pointLabels:{display:!1},startAngle:0}}};constructor(e,t){super(e,t),this.innerRadius=void 0,this.outerRadius=void 0}getLabelAndValue(e){const t=this._cachedMeta,n=this.chart,s=n.data.labels||[],r=at(t._parsed[e].r,n.options.locale);return{label:s[e]||"",value:r}}parseObjectData(e,t,n,s){return Jt.bind(this)(e,t,n,s)}update(e){const t=this._cachedMeta.data;this._updateRadius(),this.updateElements(t,0,t.length,e)}getMinMax(){const e=this._cachedMeta,t={min:Number.POSITIVE_INFINITY,max:Number.NEGATIVE_INFINITY};return e.data.forEach(((e,n)=>{const s=this.getParsed(n).r;!isNaN(s)&&this.chart.getDataVisibility(n)&&(s<t.min&&(t.min=s),s>t.max&&(t.max=s))})),t}_updateRadius(){const e=this.chart,t=e.chartArea,n=e.options,s=Math.min(t.right-t.left,t.bottom-t.top),r=Math.max(s/2,0),i=(r-Math.max(n.cutoutPercentage?r/100*n.cutoutPercentage:1,0))/e.getVisibleDatasetCount();this.outerRadius=r-i*this.index,this.innerRadius=this.outerRadius-i}updateElements(e,t,n,s){const r="reset"===s,i=this.chart,a=i.options.animation,o=this._cachedMeta.rScale,l=o.xCenter,u=o.yCenter,c=o.getIndexAngle(0)-.5*fe;let h,d=c;const p=360/this.countVisibleElements();for(h=0;h<t;++h)d+=this._computeAngle(h,s,p);for(h=t;h<t+n;h++){const t=e[h];let n=d,f=d+this._computeAngle(h,s,p),g=i.getDataVisibility(h)?o.getDistanceFromCenterForValue(this.getParsed(h).r):0;d=f,r&&(a.animateScale&&(g=0),a.animateRotate&&(n=f=c));const m={x:l,y:u,innerRadius:0,outerRadius:g,startAngle:n,endAngle:f,options:this.resolveDataElementOptions(h,t.active?"active":s)};this.updateElement(t,h,m,s)}}countVisibleElements(){const e=this._cachedMeta;let t=0;return e.data.forEach(((e,n)=>{!isNaN(this.getParsed(n).r)&&this.chart.getDataVisibility(n)&&t++})),t}_computeAngle(e,t,n){return this.chart.getDataVisibility(e)?_e(this.resolveDataElementOptions(e,t).angle||n):0}}var ls=Object.freeze({__proto__:null,BarController:class extends Yn{static id="bar";static defaults={datasetElementType:!1,dataElementType:"bar",categoryPercentage:.8,barPercentage:.9,grouped:!0,animations:{numbers:{type:"number",properties:["x","y","base","width","height"]}}};static overrides={scales:{_index_:{type:"category",offset:!0,grid:{offset:!0}},_value_:{type:"linear",beginAtZero:!0}}};parsePrimitiveData(e,t,n,s){return Jn(e,t,n,s)}parseArrayData(e,t,n,s){return Jn(e,t,n,s)}parseObjectData(e,t,n,s){const{iScale:r,vScale:i}=e,{xAxisKey:a="x",yAxisKey:o="y"}=this._parsing,l="x"===r.axis?a:o,u="x"===i.axis?a:o,c=[];let h,d,p,f;for(h=n,d=n+s;h<d;++h)f=t[h],p={},p[r.axis]=r.parse(ue(f,l),h),c.push(Zn(ue(f,u),p,i,h));return c}updateRangeFromParsed(e,t,n,s){super.updateRangeFromParsed(e,t,n,s);const r=n._custom;r&&t===this._cachedMeta.vScale&&(e.min=Math.min(e.min,r.min),e.max=Math.max(e.max,r.max))}getMaxOverflow(){return 0}getLabelAndValue(e){const t=this._cachedMeta,{iScale:n,vScale:s}=t,r=this.getParsed(e),i=r._custom,a=es(i)?"["+i.start+", "+i.end+"]":""+s.getLabelForValue(r[s.axis]);return{label:""+n.getLabelForValue(r[n.axis]),value:a}}initialize(){this.enableOptionSharing=!0,super.initialize();this._cachedMeta.stack=this.getDataset().stack}update(e){const t=this._cachedMeta;this.updateElements(t.data,0,t.data.length,e)}updateElements(e,t,n,s){const r="reset"===s,{index:i,_cachedMeta:{vScale:a}}=this,o=a.getBasePixel(),l=a.isHorizontal(),u=this._getRuler(),{sharedOptions:c,includeOptions:h}=this._getSharedOptions(t,s);for(let d=t;d<t+n;d++){const t=this.getParsed(d),n=r||j(t[a.axis])?{base:o,head:o}:this._calculateBarValuePixels(d),p=this._calculateBarIndexPixels(d,u),f=(t._stacks||{})[a.axis],g={horizontal:l,base:n.base,enableBorderRadius:!f||es(t._custom)||i===f._top||i===f._bottom,x:l?n.head:p.center,y:l?p.center:n.head,height:l?p.size:Math.abs(n.size),width:l?Math.abs(n.size):p.size};h&&(g.options=c||this.resolveDataElementOptions(d,e[d].active?"active":s));const m=g.options||e[d].options;ts(g,m,f,i),rs(g,m,u.ratio),this.updateElement(e[d],d,g,s)}}_getStacks(e,t){const{iScale:n}=this._cachedMeta,s=n.getMatchingVisibleMetas(this._type).filter((e=>e.controller.options.grouped)),r=n.options.stacked,i=[],a=this._cachedMeta.controller.getParsed(t),o=a&&a[n.axis],l=e=>{const t=e._parsed.find((e=>e[n.axis]===o)),s=t&&t[e.vScale.axis];if(j(s)||isNaN(s))return!0};for(const u of s)if((void 0===t||!l(u))&&((!1===r||-1===i.indexOf(u.stack)||void 0===r&&void 0===u.stack)&&i.push(u.stack),u.index===e))break;return i.length||i.push(void 0),i}_getStackCount(e){return this._getStacks(void 0,e).length}_getStackIndex(e,t,n){const s=this._getStacks(e,n),r=void 0!==t?s.indexOf(t):-1;return-1===r?s.length-1:r}_getRuler(){const e=this.options,t=this._cachedMeta,n=t.iScale,s=[];let r,i;for(r=0,i=t.data.length;r<i;++r)s.push(n.getPixelForValue(this.getParsed(r)[n.axis],r));const a=e.barThickness;return{min:a||Qn(t),pixels:s,start:n._startPixel,end:n._endPixel,stackCount:this._getStackCount(),scale:n,grouped:e.grouped,ratio:a?1:e.categoryPercentage*e.barPercentage}}_calculateBarValuePixels(e){const{_cachedMeta:{vScale:t,_stacked:n,index:s},options:{base:r,minBarLength:i}}=this,a=r||0,o=this.getParsed(e),l=o._custom,u=es(l);let c,h,d=o[t.axis],p=0,f=n?this.applyStack(t,o,n):d;f!==d&&(p=f-d,f=d),u&&(d=l.barStart,f=l.barEnd-l.barStart,0!==d&&Se(d)!==Se(l.barEnd)&&(p=0),p+=d);const g=j(r)||u?p:r;let m=t.getPixelForValue(g);if(c=this.chart.getDataVisibility(e)?t.getPixelForValue(p+f):m,h=c-m,Math.abs(h)<i){h=function(e,t,n){return 0!==e?Se(e):(t.isHorizontal()?1:-1)*(t.min>=n?1:-1)}(h,t,a)*i,d===a&&(m-=h/2);const e=t.getPixelForDecimal(0),r=t.getPixelForDecimal(1),l=Math.min(e,r),p=Math.max(e,r);m=Math.max(Math.min(m,p),l),c=m+h,n&&!u&&(o._stacks[t.axis]._visualValues[s]=t.getValueForPixel(c)-t.getValueForPixel(m))}if(m===t.getPixelForValue(a)){const e=Se(h)*t.getLineWidthForValue(a)/2;m+=e,h-=e}return{size:h,base:m,head:c,center:c+h/2}}_calculateBarIndexPixels(e,t){const n=t.scale,s=this.options,r=s.skipNull,i=Q(s.maxBarThickness,1/0);let a,o;if(t.grouped){const n=r?this._getStackCount(e):t.stackCount,l="flex"===s.barThickness?function(e,t,n,s){const r=t.pixels,i=r[e];let a=e>0?r[e-1]:null,o=e<r.length-1?r[e+1]:null;const l=n.categoryPercentage;null===a&&(a=i-(null===o?t.end-t.start:o-i)),null===o&&(o=i+i-a);const u=i-(i-Math.min(a,o))/2*l;return{chunk:Math.abs(o-a)/2*l/s,ratio:n.barPercentage,start:u}}(e,t,s,n):function(e,t,n,s){const r=n.barThickness;let i,a;return j(r)?(i=t.min*n.categoryPercentage,a=n.barPercentage):(i=r*s,a=1),{chunk:i/s,ratio:a,start:t.pixels[e]-i/2}}(e,t,s,n),u=this._getStackIndex(this.index,this._cachedMeta.stack,r?e:void 0);a=l.start+l.chunk*u+l.chunk/2,o=Math.min(i,l.chunk*l.ratio)}else a=n.getPixelForValue(this.getParsed(e)[n.axis],e),o=Math.min(i,t.min*t.ratio);return{base:a-o/2,head:a+o/2,center:a,size:o}}draw(){const e=this._cachedMeta,t=e.vScale,n=e.data,s=n.length;let r=0;for(;r<s;++r)null===this.getParsed(r)[t.axis]||n[r].hidden||n[r].draw(this._ctx)}},BubbleController:class extends Yn{static id="bubble";static defaults={datasetElementType:!1,dataElementType:"point",animations:{numbers:{type:"number",properties:["x","y","borderWidth","radius"]}}};static overrides={scales:{x:{type:"linear"},y:{type:"linear"}}};initialize(){this.enableOptionSharing=!0,super.initialize()}parsePrimitiveData(e,t,n,s){const r=super.parsePrimitiveData(e,t,n,s);for(let i=0;i<r.length;i++)r[i]._custom=this.resolveDataElementOptions(i+n).radius;return r}parseArrayData(e,t,n,s){const r=super.parseArrayData(e,t,n,s);for(let i=0;i<r.length;i++){const e=t[n+i];r[i]._custom=Q(e[2],this.resolveDataElementOptions(i+n).radius)}return r}parseObjectData(e,t,n,s){const r=super.parseObjectData(e,t,n,s);for(let i=0;i<r.length;i++){const e=t[n+i];r[i]._custom=Q(e&&e.r&&+e.r,this.resolveDataElementOptions(i+n).radius)}return r}getMaxOverflow(){const e=this._cachedMeta.data;let t=0;for(let n=e.length-1;n>=0;--n)t=Math.max(t,e[n].size(this.resolveDataElementOptions(n))/2);return t>0&&t}getLabelAndValue(e){const t=this._cachedMeta,n=this.chart.data.labels||[],{xScale:s,yScale:r}=t,i=this.getParsed(e),a=s.getLabelForValue(i.x),o=r.getLabelForValue(i.y),l=i._custom;return{label:n[e]||"",value:"("+a+", "+o+(l?", "+l:"")+")"}}update(e){const t=this._cachedMeta.data;this.updateElements(t,0,t.length,e)}updateElements(e,t,n,s){const r="reset"===s,{iScale:i,vScale:a}=this._cachedMeta,{sharedOptions:o,includeOptions:l}=this._getSharedOptions(t,s),u=i.axis,c=a.axis;for(let h=t;h<t+n;h++){const t=e[h],n=!r&&this.getParsed(h),d={},p=d[u]=r?i.getPixelForDecimal(.5):i.getPixelForValue(n[u]),f=d[c]=r?a.getBasePixel():a.getPixelForValue(n[c]);d.skip=isNaN(p)||isNaN(f),l&&(d.options=o||this.resolveDataElementOptions(h,t.active?"active":s),r&&(d.options.radius=0)),this.updateElement(t,h,d,s)}}resolveDataElementOptions(e,t){const n=this.getParsed(e);let s=super.resolveDataElementOptions(e,t);s.$shared&&(s=Object.assign({},s,{$shared:!1}));const r=s.radius;return"active"!==t&&(s.radius=0),s.radius+=Q(n&&n._custom,r),s}},DoughnutController:is,LineController:as,PieController:class extends is{static id="pie";static defaults={cutout:0,rotation:0,circumference:360,radius:"100%"}},PolarAreaController:os,RadarController:class extends Yn{static id="radar";static defaults={datasetElementType:"line",dataElementType:"point",indexAxis:"r",showLine:!0,elements:{line:{fill:"start"}}};static overrides={aspectRatio:1,scales:{r:{type:"radialLinear"}}};getLabelAndValue(e){const t=this._cachedMeta.vScale,n=this.getParsed(e);return{label:t.getLabels()[e],value:""+t.getLabelForValue(n[t.axis])}}parseObjectData(e,t,n,s){return Jt.bind(this)(e,t,n,s)}update(e){const t=this._cachedMeta,n=t.dataset,s=t.data||[],r=t.iScale.getLabels();if(n.points=s,"resize"!==e){const t=this.resolveDatasetElementOptions(e);this.options.showLine||(t.borderWidth=0);const i={_loop:!0,_fullLoop:r.length===s.length,options:t};this.updateElement(n,void 0,i,e)}this.updateElements(s,0,s.length,e)}updateElements(e,t,n,s){const r=this._cachedMeta.rScale,i="reset"===s;for(let a=t;a<t+n;a++){const t=e[a],n=this.resolveDataElementOptions(a,t.active?"active":s),o=r.getPointPositionForValue(a,this.getParsed(a).r),l=i?r.xCenter:o.x,u=i?r.yCenter:o.y,c={x:l,y:u,angle:o.angle,skip:isNaN(l)||isNaN(u),options:n};this.updateElement(t,a,c,s)}}},ScatterController:class extends Yn{static id="scatter";static defaults={datasetElementType:!1,dataElementType:"point",showLine:!1,fill:!1};static overrides={interaction:{mode:"point"},scales:{x:{type:"linear"},y:{type:"linear"}}};getLabelAndValue(e){const t=this._cachedMeta,n=this.chart.data.labels||[],{xScale:s,yScale:r}=t,i=this.getParsed(e),a=s.getLabelForValue(i.x),o=r.getLabelForValue(i.y);return{label:n[e]||"",value:"("+a+", "+o+")"}}update(e){const t=this._cachedMeta,{data:n=[]}=t,s=this.chart._animationsDisabled;let{start:r,count:i}=Xe(t,n,s);if(this._drawStart=r,this._drawCount=i,qe(t)&&(r=0,i=n.length),this.options.showLine){this.datasetElementType||this.addElements();const{dataset:r,_dataset:i}=t;r._chart=this.chart,r._datasetIndex=this.index,r._decimated=!!i._decimated,r.points=n;const a=this.resolveDatasetElementOptions(e);a.segment=this.options.segment,this.updateElement(r,void 0,{animated:!s,options:a},e)}else this.datasetElementType&&(delete t.dataset,this.datasetElementType=!1);this.updateElements(n,r,i,e)}addElements(){const{showLine:e}=this.options;!this.datasetElementType&&e&&(this.datasetElementType=this.chart.registry.getElement("line")),super.addElements()}updateElements(e,t,n,s){const r="reset"===s,{iScale:i,vScale:a,_stacked:o,_dataset:l}=this._cachedMeta,u=this.resolveDataElementOptions(t,s),c=this.getSharedOptions(u),h=this.includeOptions(s,c),d=i.axis,p=a.axis,{spanGaps:f,segment:g}=this.options,m=Ne(f)?f:Number.POSITIVE_INFINITY,b=this.chart._animationsDisabled||r||"none"===s;let x=t>0&&this.getParsed(t-1);for(let y=t;y<t+n;++y){const t=e[y],n=this.getParsed(y),u=b?t:{},f=j(n[p]),v=u[d]=i.getPixelForValue(n[d],y),w=u[p]=r||f?a.getBasePixel():a.getPixelForValue(o?this.applyStack(a,n,o):n[p],y);u.skip=isNaN(v)||isNaN(w)||f,u.stop=y>0&&Math.abs(n[d]-x[d])>m,g&&(u.parsed=n,u.raw=l.data[y]),h&&(u.options=c||this.resolveDataElementOptions(y,t.active?"active":s)),b||this.updateElement(t,y,u,s),x=n}this.updateSharedOptions(c,s,u)}getMaxOverflow(){const e=this._cachedMeta,t=e.data||[];if(!this.options.showLine){let e=0;for(let n=t.length-1;n>=0;--n)e=Math.max(e,t[n].size(this.resolveDataElementOptions(n))/2);return e>0&&e}const n=e.dataset,s=n.options&&n.options.borderWidth||0;if(!t.length)return s;const r=t[0].size(this.resolveDataElementOptions(0)),i=t[t.length-1].size(this.resolveDataElementOptions(t.length-1));return Math.max(s,r,i)/2}}});function us(){throw new Error("This method is not implemented: Check that a complete date adapter is provided.")}class cs{static override(e){Object.assign(cs.prototype,e)}options;constructor(e){this.options=e||{}}init(){}formats(){return us()}parse(){return us()}format(){return us()}add(){return us()}diff(){return us()}startOf(){return us()}endOf(){return us()}}var hs=cs;function ds(e,t,n,s){const{controller:r,data:i,_sorted:a}=e,o=r._cachedMeta.iScale;if(o&&t===o.axis&&"r"!==t&&a&&i.length){const e=o._reversePixels?Be:ze;if(!s)return e(i,t,n);if(r._sharedOptions){const s=i[0],r="function"===typeof s.getRange&&s.getRange(t);if(r){const s=e(i,t,n-r),a=e(i,t,n+r);return{lo:s.lo,hi:a.hi}}}}return{lo:0,hi:i.length-1}}function ps(e,t,n,s,r){const i=e.getSortedVisibleDatasetMetas(),a=n[t];for(let o=0,l=i.length;o<l;++o){const{index:e,data:n}=i[o],{lo:l,hi:u}=ds(i[o],t,a,r);for(let t=l;t<=u;++t){const r=n[t];r.skip||s(r,e,t)}}}function fs(e,t,n,s,r){const i=[];if(!r&&!e.isPointInArea(t))return i;return ps(e,n,t,(function(n,a,o){(r||wt(n,e.chartArea,0))&&n.inRange(t.x,t.y,s)&&i.push({element:n,datasetIndex:a,index:o})}),!0),i}function gs(e,t,n,s,r,i){let a=[];const o=function(e){const t=-1!==e.indexOf("x"),n=-1!==e.indexOf("y");return function(e,s){const r=t?Math.abs(e.x-s.x):0,i=n?Math.abs(e.y-s.y):0;return Math.sqrt(Math.pow(r,2)+Math.pow(i,2))}}(n);let l=Number.POSITIVE_INFINITY;return ps(e,n,t,(function(n,u,c){const h=n.inRange(t.x,t.y,r);if(s&&!h)return;const d=n.getCenterPoint(r);if(!(!!i||e.isPointInArea(d))&&!h)return;const p=o(t,d);p<l?(a=[{element:n,datasetIndex:u,index:c}],l=p):p===l&&a.push({element:n,datasetIndex:u,index:c})})),a}function ms(e,t,n,s,r,i){return i||e.isPointInArea(t)?"r"!==n||s?gs(e,t,n,s,r,i):function(e,t,n,s){let r=[];return ps(e,n,t,(function(e,n,i){const{startAngle:a,endAngle:o}=e.getProps(["startAngle","endAngle"],s),{angle:l}=Re(e,{x:t.x,y:t.y});Me(l,a,o)&&r.push({element:e,datasetIndex:n,index:i})})),r}(e,t,n,r):[]}function bs(e,t,n,s,r){const i=[],a="x"===n?"inXRange":"inYRange";let o=!1;return ps(e,n,t,((e,s,l)=>{e[a]&&e[a](t[n],r)&&(i.push({element:e,datasetIndex:s,index:l}),o=o||e.inRange(t.x,t.y,r))})),s&&!o?[]:i}var xs={evaluateInteractionItems:ps,modes:{index(e,t,n,s){const r=fn(t,e),i=n.axis||"x",a=n.includeInvisible||!1,o=n.intersect?fs(e,r,i,s,a):ms(e,r,i,!1,s,a),l=[];return o.length?(e.getSortedVisibleDatasetMetas().forEach((e=>{const t=o[0].index,n=e.data[t];n&&!n.skip&&l.push({element:n,datasetIndex:e.index,index:t})})),l):[]},dataset(e,t,n,s){const r=fn(t,e),i=n.axis||"xy",a=n.includeInvisible||!1;let o=n.intersect?fs(e,r,i,s,a):ms(e,r,i,!1,s,a);if(o.length>0){const t=o[0].datasetIndex,n=e.getDatasetMeta(t).data;o=[];for(let e=0;e<n.length;++e)o.push({element:n[e],datasetIndex:t,index:e})}return o},point:(e,t,n,s)=>fs(e,fn(t,e),n.axis||"xy",s,n.includeInvisible||!1),nearest(e,t,n,s){const r=fn(t,e),i=n.axis||"xy",a=n.includeInvisible||!1;return ms(e,r,i,n.intersect,s,a)},x:(e,t,n,s)=>bs(e,fn(t,e),"x",n.intersect,s),y:(e,t,n,s)=>bs(e,fn(t,e),"y",n.intersect,s)}};const ys=["left","top","right","bottom"];function vs(e,t){return e.filter((e=>e.pos===t))}function ws(e,t){return e.filter((e=>-1===ys.indexOf(e.pos)&&e.box.axis===t))}function ks(e,t){return e.sort(((e,n)=>{const s=t?n:e,r=t?e:n;return s.weight===r.weight?s.index-r.index:s.weight-r.weight}))}function Ss(e,t){const n=function(e){const t={};for(const n of e){const{stack:e,pos:s,stackWeight:r}=n;if(!e||!ys.includes(s))continue;const i=t[e]||(t[e]={count:0,placed:0,weight:0,size:0});i.count++,i.weight+=r}return t}(e),{vBoxMaxWidth:s,hBoxMaxHeight:r}=t;let i,a,o;for(i=0,a=e.length;i<a;++i){o=e[i];const{fullSize:a}=o.box,l=n[o.stack],u=l&&o.stackWeight/l.weight;o.horizontal?(o.width=u?u*s:a&&t.availableWidth,o.height=r):(o.width=s,o.height=u?u*r:a&&t.availableHeight)}return n}function Is(e,t,n,s){return Math.max(e[n],t[n])+Math.max(e[s],t[s])}function Cs(e,t){e.top=Math.max(e.top,t.top),e.left=Math.max(e.left,t.left),e.bottom=Math.max(e.bottom,t.bottom),e.right=Math.max(e.right,t.right)}function Ns(e,t,n,s){const{pos:r,box:i}=n,a=e.maxPadding;if(!X(r)){n.size&&(e[r]-=n.size);const t=s[n.stack]||{size:0,count:1};t.size=Math.max(t.size,n.horizontal?i.height:i.width),n.size=t.size/t.count,e[r]+=n.size}i.getPadding&&Cs(a,i.getPadding());const o=Math.max(0,t.outerWidth-Is(a,e,"left","right")),l=Math.max(0,t.outerHeight-Is(a,e,"top","bottom")),u=o!==e.w,c=l!==e.h;return e.w=o,e.h=l,n.horizontal?{same:u,other:c}:{same:c,other:u}}function Ts(e,t){const n=t.maxPadding;function s(e){const s={left:0,top:0,right:0,bottom:0};return e.forEach((e=>{s[e]=Math.max(t[e],n[e])})),s}return s(e?["left","right"]:["top","bottom"])}function _s(e,t,n,s){const r=[];let i,a,o,l,u,c;for(i=0,a=e.length,u=0;i<a;++i){o=e[i],l=o.box,l.update(o.width||t.w,o.height||t.h,Ts(o.horizontal,t));const{same:a,other:h}=Ns(t,n,o,s);u|=a&&r.length,c=c||h,l.fullSize||r.push(o)}return u&&_s(r,t,n,s)||c}function Es(e,t,n,s,r){e.top=n,e.left=t,e.right=t+s,e.bottom=n+r,e.width=s,e.height=r}function $s(e,t,n,s){const r=n.padding;let{x:i,y:a}=t;for(const o of e){const e=o.box,l=s[o.stack]||{count:1,placed:0,weight:1},u=o.stackWeight/l.weight||1;if(o.horizontal){const s=t.w*u,i=l.size||e.height;he(l.start)&&(a=l.start),e.fullSize?Es(e,r.left,a,n.outerWidth-r.right-r.left,i):Es(e,t.left+l.placed,a,s,i),l.start=a,l.placed+=s,a=e.bottom}else{const s=t.h*u,a=l.size||e.width;he(l.start)&&(i=l.start),e.fullSize?Es(e,i,r.top,a,n.outerHeight-r.bottom-r.top):Es(e,i,t.top+l.placed,a,s),l.start=i,l.placed+=s,i=e.right}}t.x=i,t.y=a}var Rs={addBox(e,t){e.boxes||(e.boxes=[]),t.fullSize=t.fullSize||!1,t.position=t.position||"top",t.weight=t.weight||0,t._layers=t._layers||function(){return[{z:0,draw(e){t.draw(e)}}]},e.boxes.push(t)},removeBox(e,t){const n=e.boxes?e.boxes.indexOf(t):-1;-1!==n&&e.boxes.splice(n,1)},configure(e,t,n){t.fullSize=n.fullSize,t.position=n.position,t.weight=n.weight},update(e,t,n,s){if(!e)return;const r=Ot(e.options.layout.padding),i=Math.max(t-r.width,0),a=Math.max(n-r.height,0),o=function(e){const t=function(e){const t=[];let n,s,r,i,a,o;for(n=0,s=(e||[]).length;n<s;++n)r=e[n],({position:i,options:{stack:a,stackWeight:o=1}}=r),t.push({index:n,box:r,pos:i,horizontal:r.isHorizontal(),weight:r.weight,stack:a&&i+a,stackWeight:o});return t}(e),n=ks(t.filter((e=>e.box.fullSize)),!0),s=ks(vs(t,"left"),!0),r=ks(vs(t,"right")),i=ks(vs(t,"top"),!0),a=ks(vs(t,"bottom")),o=ws(t,"x"),l=ws(t,"y");return{fullSize:n,leftAndTop:s.concat(i),rightAndBottom:r.concat(l).concat(a).concat(o),chartArea:vs(t,"chartArea"),vertical:s.concat(r).concat(l),horizontal:i.concat(a).concat(o)}}(e.boxes),l=o.vertical,u=o.horizontal;ee(e.boxes,(e=>{"function"===typeof e.beforeLayout&&e.beforeLayout()}));const c=l.reduce(((e,t)=>t.box.options&&!1===t.box.options.display?e:e+1),0)||1,h=Object.freeze({outerWidth:t,outerHeight:n,padding:r,availableWidth:i,availableHeight:a,vBoxMaxWidth:i/2/c,hBoxMaxHeight:a/2}),d=Object.assign({},r);Cs(d,Ot(s));const p=Object.assign({maxPadding:d,w:i,h:a,x:r.left,y:r.top},r),f=Ss(l.concat(u),h);_s(o.fullSize,p,h,f),_s(l,p,h,f),_s(u,p,h,f)&&_s(l,p,h,f),function(e){const t=e.maxPadding;function n(n){const s=Math.max(t[n]-e[n],0);return e[n]+=s,s}e.y+=n("top"),e.x+=n("left"),n("right"),n("bottom")}(p),$s(o.leftAndTop,p,h,f),p.x+=p.w,p.y+=p.h,$s(o.rightAndBottom,p,h,f),e.chartArea={left:p.left,top:p.top,right:p.left+p.w,bottom:p.top+p.h,height:p.h,width:p.w},ee(o.chartArea,(t=>{const n=t.box;Object.assign(n,e.chartArea),n.update(p.w,p.h,{left:0,top:0,right:0,bottom:0})}))}};class As{acquireContext(e,t){}releaseContext(e){return!1}addEventListener(e,t,n){}removeEventListener(e,t,n){}getDevicePixelRatio(){return 1}getMaximumSize(e,t,n,s){return t=Math.max(0,t||e.width),n=n||e.height,{width:t,height:Math.max(0,s?Math.floor(t/s):n)}}isAttached(e){return!0}updateConfig(e){}}class Ds extends As{acquireContext(e){return e&&e.getContext&&e.getContext("2d")||null}updateConfig(e){e.options.animation=!1}}const Fs="$chartjs",Ms={touchstart:"mousedown",touchmove:"mousemove",touchend:"mouseup",pointerenter:"mouseenter",pointerdown:"mousedown",pointermove:"mousemove",pointerup:"mouseup",pointerleave:"mouseout",pointerout:"mouseout"},Os=e=>null===e||""===e;const Ls=!!xn&&{passive:!0};function Ps(e,t,n){e&&e.canvas&&e.canvas.removeEventListener(t,n,Ls)}function zs(e,t){for(const n of e)if(n===t||n.contains(t))return!0}function Bs(e,t,n){const s=e.canvas,r=new MutationObserver((e=>{let t=!1;for(const n of e)t=t||zs(n.addedNodes,s),t=t&&!zs(n.removedNodes,s);t&&n()}));return r.observe(document,{childList:!0,subtree:!0}),r}function Ws(e,t,n){const s=e.canvas,r=new MutationObserver((e=>{let t=!1;for(const n of e)t=t||zs(n.removedNodes,s),t=t&&!zs(n.addedNodes,s);t&&n()}));return r.observe(document,{childList:!0,subtree:!0}),r}const Vs=new Map;let Us=0;function Gs(){const e=window.devicePixelRatio;e!==Us&&(Us=e,Vs.forEach(((t,n)=>{n.currentDevicePixelRatio!==e&&t()})))}function Hs(e,t,n){const s=e.canvas,r=s&&un(s);if(!r)return;const i=He(((e,t)=>{const s=r.clientWidth;n(e,t),s<r.clientWidth&&n()}),window),a=new ResizeObserver((e=>{const t=e[0],n=t.contentRect.width,s=t.contentRect.height;0===n&&0===s||i(n,s)}));return a.observe(r),function(e,t){Vs.size||window.addEventListener("resize",Gs),Vs.set(e,t)}(e,i),a}function js(e,t,n){n&&n.disconnect(),"resize"===t&&function(e){Vs.delete(e),Vs.size||window.removeEventListener("resize",Gs)}(e)}function Ks(e,t,n){const s=e.canvas,r=He((t=>{null!==e.ctx&&n(function(e,t){const n=Ms[e.type]||e.type,{x:s,y:r}=fn(e,t);return{type:n,chart:t,native:e,x:void 0!==s?s:null,y:void 0!==r?r:null}}(t,e))}),e);return function(e,t,n){e&&e.addEventListener(t,n,Ls)}(s,t,r),r}class Xs extends As{acquireContext(e,t){const n=e&&e.getContext&&e.getContext("2d");return n&&n.canvas===e?(function(e,t){const n=e.style,s=e.getAttribute("height"),r=e.getAttribute("width");if(e[Fs]={initial:{height:s,width:r,style:{display:n.display,height:n.height,width:n.width}}},n.display=n.display||"block",n.boxSizing=n.boxSizing||"border-box",Os(r)){const t=yn(e,"width");void 0!==t&&(e.width=t)}if(Os(s))if(""===e.style.height)e.height=e.width/(t||2);else{const t=yn(e,"height");void 0!==t&&(e.height=t)}}(e,t),n):null}releaseContext(e){const t=e.canvas;if(!t[Fs])return!1;const n=t[Fs].initial;["height","width"].forEach((e=>{const s=n[e];j(s)?t.removeAttribute(e):t.setAttribute(e,s)}));const s=n.style||{};return Object.keys(s).forEach((e=>{t.style[e]=s[e]})),t.width=t.width,delete t[Fs],!0}addEventListener(e,t,n){this.removeEventListener(e,t);const s=e.$proxies||(e.$proxies={}),r={attach:Bs,detach:Ws,resize:Hs}[t]||Ks;s[t]=r(e,t,n)}removeEventListener(e,t){const n=e.$proxies||(e.$proxies={}),s=n[t];if(!s)return;({attach:js,detach:js,resize:js}[t]||Ps)(e,t,s),n[t]=void 0}getDevicePixelRatio(){return window.devicePixelRatio}getMaximumSize(e,t,n,s){return mn(e,t,n,s)}isAttached(e){const t=e&&un(e);return!(!t||!t.isConnected)}}class qs{static defaults={};static defaultRoutes=void 0;x;y;active=!1;options;$animations;tooltipPosition(e){const{x:t,y:n}=this.getProps(["x","y"],e);return{x:t,y:n}}hasValue(){return Ne(this.x)&&Ne(this.y)}getProps(e,t){const n=this.$animations;if(!t||!n)return this;const s={};return e.forEach((e=>{s[e]=n[e]&&n[e].active()?n[e]._to:this[e]})),s}}function Ys(e,t){const n=e.options.ticks,s=function(e){const t=e.options.offset,n=e._tickSize(),s=e._length/n+(t?0:1),r=e._maxLength/n;return Math.floor(Math.min(s,r))}(e),r=Math.min(n.maxTicksLimit||s,s),i=n.major.enabled?function(e){const t=[];let n,s;for(n=0,s=e.length;n<s;n++)e[n].major&&t.push(n);return t}(t):[],a=i.length,o=i[0],l=i[a-1],u=[];if(a>r)return function(e,t,n,s){let r,i=0,a=n[0];for(s=Math.ceil(s),r=0;r<e.length;r++)r===a&&(t.push(e[r]),i++,a=n[i*s])}(t,u,i,a/r),u;const c=function(e,t,n){const s=function(e){const t=e.length;let n,s;if(t<2)return!1;for(s=e[0],n=1;n<t;++n)if(e[n]-e[n-1]!==s)return!1;return s}(e),r=t.length/n;if(!s)return Math.max(r,1);const i=function(e){const t=[],n=Math.sqrt(e);let s;for(s=1;s<n;s++)e%s===0&&(t.push(s),t.push(e/s));return n===(0|n)&&t.push(n),t.sort(((e,t)=>e-t)).pop(),t}(s);for(let a=0,o=i.length-1;a<o;a++){const e=i[a];if(e>r)return e}return Math.max(r,1)}(i,t,r);if(a>0){let e,n;const s=a>1?Math.round((l-o)/(a-1)):null;for(Qs(t,u,c,j(s)?0:o-s,o),e=0,n=a-1;e<n;e++)Qs(t,u,c,i[e],i[e+1]);return Qs(t,u,c,l,j(s)?t.length:l+s),u}return Qs(t,u,c),u}function Qs(e,t,n,s,r){const i=Q(s,0),a=Math.min(Q(r,e.length),e.length);let o,l,u,c=0;for(n=Math.ceil(n),r&&(o=r-s,n=o/Math.floor(o/n)),u=i;u<0;)c++,u=Math.round(i+c*n);for(l=Math.max(i,0);l<a;l++)l===u&&(t.push(e[l]),c++,u=Math.round(i+c*n))}const Zs=(e,t,n)=>"top"===t||"left"===t?e[t]+n:e[t]-n,Js=(e,t)=>Math.min(t||e,e);function er(e,t){const n=[],s=e.length/t,r=e.length;let i=0;for(;i<r;i+=s)n.push(e[Math.floor(i)]);return n}function tr(e,t,n){const s=e.ticks.length,r=Math.min(t,s-1),i=e._startPixel,a=e._endPixel,o=1e-6;let l,u=e.getPixelForTick(r);if(!(n&&(l=1===s?Math.max(u-i,a-u):0===t?(e.getPixelForTick(1)-u)/2:(u-e.getPixelForTick(r-1))/2,u+=r<t?l:-l,u<i-o||u>a+o)))return u}function nr(e){return e.drawTicks?e.tickLength:0}function sr(e,t){if(!e.display)return 0;const n=Lt(e.font,t),s=Ot(e.padding);return(K(e.text)?e.text.length:1)*n.lineHeight+s.height}function rr(e,t,n){let s=je(e);return(n&&"right"!==t||!n&&"right"===t)&&(s=(e=>"left"===e?"right":"right"===e?"left":e)(s)),s}class ir extends qs{constructor(e){super(),this.id=e.id,this.type=e.type,this.options=void 0,this.ctx=e.ctx,this.chart=e.chart,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.width=void 0,this.height=void 0,this._margins={left:0,right:0,top:0,bottom:0},this.maxWidth=void 0,this.maxHeight=void 0,this.paddingTop=void 0,this.paddingBottom=void 0,this.paddingLeft=void 0,this.paddingRight=void 0,this.axis=void 0,this.labelRotation=void 0,this.min=void 0,this.max=void 0,this._range=void 0,this.ticks=[],this._gridLineItems=null,this._labelItems=null,this._labelSizes=null,this._length=0,this._maxLength=0,this._longestTextCache={},this._startPixel=void 0,this._endPixel=void 0,this._reversePixels=!1,this._userMax=void 0,this._userMin=void 0,this._suggestedMax=void 0,this._suggestedMin=void 0,this._ticksLength=0,this._borderValue=0,this._cache={},this._dataLimitsCached=!1,this.$context=void 0}init(e){this.options=e.setContext(this.getContext()),this.axis=e.axis,this._userMin=this.parse(e.min),this._userMax=this.parse(e.max),this._suggestedMin=this.parse(e.suggestedMin),this._suggestedMax=this.parse(e.suggestedMax)}parse(e,t){return e}getUserBounds(){let{_userMin:e,_userMax:t,_suggestedMin:n,_suggestedMax:s}=this;return e=Y(e,Number.POSITIVE_INFINITY),t=Y(t,Number.NEGATIVE_INFINITY),n=Y(n,Number.POSITIVE_INFINITY),s=Y(s,Number.NEGATIVE_INFINITY),{min:Y(e,n),max:Y(t,s),minDefined:q(e),maxDefined:q(t)}}getMinMax(e){let t,{min:n,max:s,minDefined:r,maxDefined:i}=this.getUserBounds();if(r&&i)return{min:n,max:s};const a=this.getMatchingVisibleMetas();for(let o=0,l=a.length;o<l;++o)t=a[o].controller.getMinMax(this,e),r||(n=Math.min(n,t.min)),i||(s=Math.max(s,t.max));return n=i&&n>s?s:n,s=r&&n>s?n:s,{min:Y(n,Y(s,n)),max:Y(s,Y(n,s))}}getPadding(){return{left:this.paddingLeft||0,top:this.paddingTop||0,right:this.paddingRight||0,bottom:this.paddingBottom||0}}getTicks(){return this.ticks}getLabels(){const e=this.chart.data;return this.options.labels||(this.isHorizontal()?e.xLabels:e.yLabels)||e.labels||[]}getLabelItems(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.chart.chartArea;return this._labelItems||(this._labelItems=this._computeLabelItems(e))}beforeLayout(){this._cache={},this._dataLimitsCached=!1}beforeUpdate(){J(this.options.beforeUpdate,[this])}update(e,t,n){const{beginAtZero:s,grace:r,ticks:i}=this.options,a=i.sampleSize;this.beforeUpdate(),this.maxWidth=e,this.maxHeight=t,this._margins=n=Object.assign({left:0,right:0,top:0,bottom:0},n),this.ticks=null,this._labelSizes=null,this._gridLineItems=null,this._labelItems=null,this.beforeSetDimensions(),this.setDimensions(),this.afterSetDimensions(),this._maxLength=this.isHorizontal()?this.width+n.left+n.right:this.height+n.top+n.bottom,this._dataLimitsCached||(this.beforeDataLimits(),this.determineDataLimits(),this.afterDataLimits(),this._range=function(e,t,n){const{min:s,max:r}=e,i=Z(t,(r-s)/2),a=(e,t)=>n&&0===e?0:e+t;return{min:a(s,-Math.abs(i)),max:a(r,i)}}(this,r,s),this._dataLimitsCached=!0),this.beforeBuildTicks(),this.ticks=this.buildTicks()||[],this.afterBuildTicks();const o=a<this.ticks.length;this._convertTicksToLabels(o?er(this.ticks,a):this.ticks),this.configure(),this.beforeCalculateLabelRotation(),this.calculateLabelRotation(),this.afterCalculateLabelRotation(),i.display&&(i.autoSkip||"auto"===i.source)&&(this.ticks=Ys(this,this.ticks),this._labelSizes=null,this.afterAutoSkip()),o&&this._convertTicksToLabels(this.ticks),this.beforeFit(),this.fit(),this.afterFit(),this.afterUpdate()}configure(){let e,t,n=this.options.reverse;this.isHorizontal()?(e=this.left,t=this.right):(e=this.top,t=this.bottom,n=!n),this._startPixel=e,this._endPixel=t,this._reversePixels=n,this._length=t-e,this._alignToPixels=this.options.alignToPixels}afterUpdate(){J(this.options.afterUpdate,[this])}beforeSetDimensions(){J(this.options.beforeSetDimensions,[this])}setDimensions(){this.isHorizontal()?(this.width=this.maxWidth,this.left=0,this.right=this.width):(this.height=this.maxHeight,this.top=0,this.bottom=this.height),this.paddingLeft=0,this.paddingTop=0,this.paddingRight=0,this.paddingBottom=0}afterSetDimensions(){J(this.options.afterSetDimensions,[this])}_callHooks(e){this.chart.notifyPlugins(e,this.getContext()),J(this.options[e],[this])}beforeDataLimits(){this._callHooks("beforeDataLimits")}determineDataLimits(){}afterDataLimits(){this._callHooks("afterDataLimits")}beforeBuildTicks(){this._callHooks("beforeBuildTicks")}buildTicks(){return[]}afterBuildTicks(){this._callHooks("afterBuildTicks")}beforeTickToLabelConversion(){J(this.options.beforeTickToLabelConversion,[this])}generateTickLabels(e){const t=this.options.ticks;let n,s,r;for(n=0,s=e.length;n<s;n++)r=e[n],r.label=J(t.callback,[r.value,n,e],this)}afterTickToLabelConversion(){J(this.options.afterTickToLabelConversion,[this])}beforeCalculateLabelRotation(){J(this.options.beforeCalculateLabelRotation,[this])}calculateLabelRotation(){const e=this.options,t=e.ticks,n=Js(this.ticks.length,e.ticks.maxTicksLimit),s=t.minRotation||0,r=t.maxRotation;let i,a,o,l=s;if(!this._isVisible()||!t.display||s>=r||n<=1||!this.isHorizontal())return void(this.labelRotation=s);const u=this._getLabelSizes(),c=u.widest.width,h=u.highest.height,d=Oe(this.chart.width-c,0,this.maxWidth);i=e.offset?this.maxWidth/n:d/(n-1),c+6>i&&(i=d/(n-(e.offset?.5:1)),a=this.maxHeight-nr(e.grid)-t.padding-sr(e.title,this.chart.options.font),o=Math.sqrt(c*c+h*h),l=Ee(Math.min(Math.asin(Oe((u.highest.height+6)/i,-1,1)),Math.asin(Oe(a/o,-1,1))-Math.asin(Oe(h/o,-1,1)))),l=Math.max(s,Math.min(r,l))),this.labelRotation=l}afterCalculateLabelRotation(){J(this.options.afterCalculateLabelRotation,[this])}afterAutoSkip(){}beforeFit(){J(this.options.beforeFit,[this])}fit(){const e={width:0,height:0},{chart:t,options:{ticks:n,title:s,grid:r}}=this,i=this._isVisible(),a=this.isHorizontal();if(i){const i=sr(s,t.options.font);if(a?(e.width=this.maxWidth,e.height=nr(r)+i):(e.height=this.maxHeight,e.width=nr(r)+i),n.display&&this.ticks.length){const{first:t,last:s,widest:r,highest:i}=this._getLabelSizes(),o=2*n.padding,l=_e(this.labelRotation),u=Math.cos(l),c=Math.sin(l);if(a){const t=n.mirror?0:c*r.width+u*i.height;e.height=Math.min(this.maxHeight,e.height+t+o)}else{const t=n.mirror?0:u*r.width+c*i.height;e.width=Math.min(this.maxWidth,e.width+t+o)}this._calculatePadding(t,s,c,u)}}this._handleMargins(),a?(this.width=this._length=t.width-this._margins.left-this._margins.right,this.height=e.height):(this.width=e.width,this.height=this._length=t.height-this._margins.top-this._margins.bottom)}_calculatePadding(e,t,n,s){const{ticks:{align:r,padding:i},position:a}=this.options,o=0!==this.labelRotation,l="top"!==a&&"x"===this.axis;if(this.isHorizontal()){const a=this.getPixelForTick(0)-this.left,u=this.right-this.getPixelForTick(this.ticks.length-1);let c=0,h=0;o?l?(c=s*e.width,h=n*t.height):(c=n*e.height,h=s*t.width):"start"===r?h=t.width:"end"===r?c=e.width:"inner"!==r&&(c=e.width/2,h=t.width/2),this.paddingLeft=Math.max((c-a+i)*this.width/(this.width-a),0),this.paddingRight=Math.max((h-u+i)*this.width/(this.width-u),0)}else{let n=t.height/2,s=e.height/2;"start"===r?(n=0,s=e.height):"end"===r&&(n=t.height,s=0),this.paddingTop=n+i,this.paddingBottom=s+i}}_handleMargins(){this._margins&&(this._margins.left=Math.max(this.paddingLeft,this._margins.left),this._margins.top=Math.max(this.paddingTop,this._margins.top),this._margins.right=Math.max(this.paddingRight,this._margins.right),this._margins.bottom=Math.max(this.paddingBottom,this._margins.bottom))}afterFit(){J(this.options.afterFit,[this])}isHorizontal(){const{axis:e,position:t}=this.options;return"top"===t||"bottom"===t||"x"===e}isFullSize(){return this.options.fullSize}_convertTicksToLabels(e){let t,n;for(this.beforeTickToLabelConversion(),this.generateTickLabels(e),t=0,n=e.length;t<n;t++)j(e[t].label)&&(e.splice(t,1),n--,t--);this.afterTickToLabelConversion()}_getLabelSizes(){let e=this._labelSizes;if(!e){const t=this.options.ticks.sampleSize;let n=this.ticks;t<n.length&&(n=er(n,t)),this._labelSizes=e=this._computeLabelSizes(n,n.length,this.options.ticks.maxTicksLimit)}return e}_computeLabelSizes(e,t,n){const{ctx:s,_longestTextCache:r}=this,i=[],a=[],o=Math.floor(t/Js(t,n));let l,u,c,h,d,p,f,g,m,b,x,y=0,v=0;for(l=0;l<t;l+=o){if(h=e[l].label,d=this._resolveTickFontOptions(l),s.font=p=d.string,f=r[p]=r[p]||{data:{},gc:[]},g=d.lineHeight,m=b=0,j(h)||K(h)){if(K(h))for(u=0,c=h.length;u<c;++u)x=h[u],j(x)||K(x)||(m=gt(s,f.data,f.gc,m,x),b+=g)}else m=gt(s,f.data,f.gc,m,h),b=g;i.push(m),a.push(b),y=Math.max(m,y),v=Math.max(b,v)}!function(e,t){ee(e,(e=>{const n=e.gc,s=n.length/2;let r;if(s>t){for(r=0;r<s;++r)delete e.data[n[r]];n.splice(0,s)}}))}(r,t);const w=i.indexOf(y),k=a.indexOf(v),S=e=>({width:i[e]||0,height:a[e]||0});return{first:S(0),last:S(t-1),widest:S(w),highest:S(k),widths:i,heights:a}}getLabelForValue(e){return e}getPixelForValue(e,t){return NaN}getValueForPixel(e){}getPixelForTick(e){const t=this.ticks;return e<0||e>t.length-1?null:this.getPixelForValue(t[e].value)}getPixelForDecimal(e){this._reversePixels&&(e=1-e);const t=this._startPixel+e*this._length;return Oe(this._alignToPixels?bt(this.chart,t,0):t,-32768,32767)}getDecimalForPixel(e){const t=(e-this._startPixel)/this._length;return this._reversePixels?1-t:t}getBasePixel(){return this.getPixelForValue(this.getBaseValue())}getBaseValue(){const{min:e,max:t}=this;return e<0&&t<0?t:e>0&&t>0?e:0}getContext(e){const t=this.ticks||[];if(e>=0&&e<t.length){const n=t[e];return n.$context||(n.$context=function(e,t,n){return zt(e,{tick:n,index:t,type:"tick"})}(this.getContext(),e,n))}return this.$context||(this.$context=function(e,t){return zt(e,{scale:t,type:"scale"})}(this.chart.getContext(),this))}_tickSize(){const e=this.options.ticks,t=_e(this.labelRotation),n=Math.abs(Math.cos(t)),s=Math.abs(Math.sin(t)),r=this._getLabelSizes(),i=e.autoSkipPadding||0,a=r?r.widest.width+i:0,o=r?r.highest.height+i:0;return this.isHorizontal()?o*n>a*s?a/n:o/s:o*s<a*n?o/n:a/s}_isVisible(){const e=this.options.display;return"auto"!==e?!!e:this.getMatchingVisibleMetas().length>0}_computeGridLineItems(e){const t=this.axis,n=this.chart,s=this.options,{grid:r,position:i,border:a}=s,o=r.offset,l=this.isHorizontal(),u=this.ticks.length+(o?1:0),c=nr(r),h=[],d=a.setContext(this.getContext()),p=d.display?d.width:0,f=p/2,g=function(e){return bt(n,e,p)};let m,b,x,y,v,w,k,S,I,C,N,T;if("top"===i)m=g(this.bottom),w=this.bottom-c,S=m-f,C=g(e.top)+f,T=e.bottom;else if("bottom"===i)m=g(this.top),C=e.top,T=g(e.bottom)-f,w=m+f,S=this.top+c;else if("left"===i)m=g(this.right),v=this.right-c,k=m-f,I=g(e.left)+f,N=e.right;else if("right"===i)m=g(this.left),I=e.left,N=g(e.right)-f,v=m+f,k=this.left+c;else if("x"===t){if("center"===i)m=g((e.top+e.bottom)/2+.5);else if(X(i)){const e=Object.keys(i)[0],t=i[e];m=g(this.chart.scales[e].getPixelForValue(t))}C=e.top,T=e.bottom,w=m+f,S=w+c}else if("y"===t){if("center"===i)m=g((e.left+e.right)/2);else if(X(i)){const e=Object.keys(i)[0],t=i[e];m=g(this.chart.scales[e].getPixelForValue(t))}v=m-f,k=v-c,I=e.left,N=e.right}const _=Q(s.ticks.maxTicksLimit,u),E=Math.max(1,Math.ceil(u/_));for(b=0;b<u;b+=E){const e=this.getContext(b),t=r.setContext(e),s=a.setContext(e),i=t.lineWidth,u=t.color,c=s.dash||[],d=s.dashOffset,p=t.tickWidth,f=t.tickColor,g=t.tickBorderDash||[],m=t.tickBorderDashOffset;x=tr(this,b,o),void 0!==x&&(y=bt(n,x,i),l?v=k=I=N=y:w=S=C=T=y,h.push({tx1:v,ty1:w,tx2:k,ty2:S,x1:I,y1:C,x2:N,y2:T,width:i,color:u,borderDash:c,borderDashOffset:d,tickWidth:p,tickColor:f,tickBorderDash:g,tickBorderDashOffset:m}))}return this._ticksLength=u,this._borderValue=m,h}_computeLabelItems(e){const t=this.axis,n=this.options,{position:s,ticks:r}=n,i=this.isHorizontal(),a=this.ticks,{align:o,crossAlign:l,padding:u,mirror:c}=r,h=nr(n.grid),d=h+u,p=c?-u:d,f=-_e(this.labelRotation),g=[];let m,b,x,y,v,w,k,S,I,C,N,T,_="middle";if("top"===s)w=this.bottom-p,k=this._getXAxisLabelAlignment();else if("bottom"===s)w=this.top+p,k=this._getXAxisLabelAlignment();else if("left"===s){const e=this._getYAxisLabelAlignment(h);k=e.textAlign,v=e.x}else if("right"===s){const e=this._getYAxisLabelAlignment(h);k=e.textAlign,v=e.x}else if("x"===t){if("center"===s)w=(e.top+e.bottom)/2+d;else if(X(s)){const e=Object.keys(s)[0],t=s[e];w=this.chart.scales[e].getPixelForValue(t)+d}k=this._getXAxisLabelAlignment()}else if("y"===t){if("center"===s)v=(e.left+e.right)/2-d;else if(X(s)){const e=Object.keys(s)[0],t=s[e];v=this.chart.scales[e].getPixelForValue(t)}k=this._getYAxisLabelAlignment(h).textAlign}"y"===t&&("start"===o?_="top":"end"===o&&(_="bottom"));const E=this._getLabelSizes();for(m=0,b=a.length;m<b;++m){x=a[m],y=x.label;const e=r.setContext(this.getContext(m));S=this.getPixelForTick(m)+r.labelOffset,I=this._resolveTickFontOptions(m),C=I.lineHeight,N=K(y)?y.length:1;const t=N/2,n=e.color,o=e.textStrokeColor,u=e.textStrokeWidth;let h,d=k;if(i?(v=S,"inner"===k&&(d=m===b-1?this.options.reverse?"left":"right":0===m?this.options.reverse?"right":"left":"center"),T="top"===s?"near"===l||0!==f?-N*C+C/2:"center"===l?-E.highest.height/2-t*C+C:-E.highest.height+C/2:"near"===l||0!==f?C/2:"center"===l?E.highest.height/2-t*C:E.highest.height-N*C,c&&(T*=-1),0===f||e.showLabelBackdrop||(v+=C/2*Math.sin(f))):(w=S,T=(1-N)*C/2),e.showLabelBackdrop){const t=Ot(e.backdropPadding),n=E.heights[m],s=E.widths[m];let r=T-t.top,i=0-t.left;switch(_){case"middle":r-=n/2;break;case"bottom":r-=n}switch(k){case"center":i-=s/2;break;case"right":i-=s;break;case"inner":m===b-1?i-=s:m>0&&(i-=s/2)}h={left:i,top:r,width:s+t.width,height:n+t.height,color:e.backdropColor}}g.push({label:y,font:I,textOffset:T,options:{rotation:f,color:n,strokeColor:o,strokeWidth:u,textAlign:d,textBaseline:_,translation:[v,w],backdrop:h}})}return g}_getXAxisLabelAlignment(){const{position:e,ticks:t}=this.options;if(-_e(this.labelRotation))return"top"===e?"left":"right";let n="center";return"start"===t.align?n="left":"end"===t.align?n="right":"inner"===t.align&&(n="inner"),n}_getYAxisLabelAlignment(e){const{position:t,ticks:{crossAlign:n,mirror:s,padding:r}}=this.options,i=e+r,a=this._getLabelSizes().widest.width;let o,l;return"left"===t?s?(l=this.right+r,"near"===n?o="left":"center"===n?(o="center",l+=a/2):(o="right",l+=a)):(l=this.right-i,"near"===n?o="right":"center"===n?(o="center",l-=a/2):(o="left",l=this.left)):"right"===t?s?(l=this.left+r,"near"===n?o="right":"center"===n?(o="center",l-=a/2):(o="left",l-=a)):(l=this.left+i,"near"===n?o="left":"center"===n?(o="center",l+=a/2):(o="right",l=this.right)):o="right",{textAlign:o,x:l}}_computeLabelArea(){if(this.options.ticks.mirror)return;const e=this.chart,t=this.options.position;return"left"===t||"right"===t?{top:0,left:this.left,bottom:e.height,right:this.right}:"top"===t||"bottom"===t?{top:this.top,left:0,bottom:this.bottom,right:e.width}:void 0}drawBackground(){const{ctx:e,options:{backgroundColor:t},left:n,top:s,width:r,height:i}=this;t&&(e.save(),e.fillStyle=t,e.fillRect(n,s,r,i),e.restore())}getLineWidthForValue(e){const t=this.options.grid;if(!this._isVisible()||!t.display)return 0;const n=this.ticks.findIndex((t=>t.value===e));if(n>=0){return t.setContext(this.getContext(n)).lineWidth}return 0}drawGrid(e){const t=this.options.grid,n=this.ctx,s=this._gridLineItems||(this._gridLineItems=this._computeGridLineItems(e));let r,i;const a=(e,t,s)=>{s.width&&s.color&&(n.save(),n.lineWidth=s.width,n.strokeStyle=s.color,n.setLineDash(s.borderDash||[]),n.lineDashOffset=s.borderDashOffset,n.beginPath(),n.moveTo(e.x,e.y),n.lineTo(t.x,t.y),n.stroke(),n.restore())};if(t.display)for(r=0,i=s.length;r<i;++r){const e=s[r];t.drawOnChartArea&&a({x:e.x1,y:e.y1},{x:e.x2,y:e.y2},e),t.drawTicks&&a({x:e.tx1,y:e.ty1},{x:e.tx2,y:e.ty2},{color:e.tickColor,width:e.tickWidth,borderDash:e.tickBorderDash,borderDashOffset:e.tickBorderDashOffset})}}drawBorder(){const{chart:e,ctx:t,options:{border:n,grid:s}}=this,r=n.setContext(this.getContext()),i=n.display?r.width:0;if(!i)return;const a=s.setContext(this.getContext(0)).lineWidth,o=this._borderValue;let l,u,c,h;this.isHorizontal()?(l=bt(e,this.left,i)-i/2,u=bt(e,this.right,a)+a/2,c=h=o):(c=bt(e,this.top,i)-i/2,h=bt(e,this.bottom,a)+a/2,l=u=o),t.save(),t.lineWidth=r.width,t.strokeStyle=r.color,t.beginPath(),t.moveTo(l,c),t.lineTo(u,h),t.stroke(),t.restore()}drawLabels(e){if(!this.options.ticks.display)return;const t=this.ctx,n=this._computeLabelArea();n&&kt(t,n);const s=this.getLabelItems(e);for(const r of s){const e=r.options,n=r.font;_t(t,r.label,0,r.textOffset,n,e)}n&&St(t)}drawTitle(){const{ctx:e,options:{position:t,title:n,reverse:s}}=this;if(!n.display)return;const r=Lt(n.font),i=Ot(n.padding),a=n.align;let o=r.lineHeight/2;"bottom"===t||"center"===t||X(t)?(o+=i.bottom,K(n.text)&&(o+=r.lineHeight*(n.text.length-1))):o+=i.top;const{titleX:l,titleY:u,maxWidth:c,rotation:h}=function(e,t,n,s){const{top:r,left:i,bottom:a,right:o,chart:l}=e,{chartArea:u,scales:c}=l;let h,d,p,f=0;const g=a-r,m=o-i;if(e.isHorizontal()){if(d=Ke(s,i,o),X(n)){const e=Object.keys(n)[0],s=n[e];p=c[e].getPixelForValue(s)+g-t}else p="center"===n?(u.bottom+u.top)/2+g-t:Zs(e,n,t);h=o-i}else{if(X(n)){const e=Object.keys(n)[0],s=n[e];d=c[e].getPixelForValue(s)-m+t}else d="center"===n?(u.left+u.right)/2-m+t:Zs(e,n,t);p=Ke(s,a,r),f="left"===n?-ye:ye}return{titleX:d,titleY:p,maxWidth:h,rotation:f}}(this,o,t,a);_t(e,n.text,0,0,r,{color:n.color,maxWidth:c,rotation:h,textAlign:rr(a,t,s),textBaseline:"middle",translation:[l,u]})}draw(e){this._isVisible()&&(this.drawBackground(),this.drawGrid(e),this.drawBorder(),this.drawTitle(),this.drawLabels(e))}_layers(){const e=this.options,t=e.ticks&&e.ticks.z||0,n=Q(e.grid&&e.grid.z,-1),s=Q(e.border&&e.border.z,0);return this._isVisible()&&this.draw===ir.prototype.draw?[{z:n,draw:e=>{this.drawBackground(),this.drawGrid(e),this.drawTitle()}},{z:s,draw:()=>{this.drawBorder()}},{z:t,draw:e=>{this.drawLabels(e)}}]:[{z:t,draw:e=>{this.draw(e)}}]}getMatchingVisibleMetas(e){const t=this.chart.getSortedVisibleDatasetMetas(),n=this.axis+"AxisID",s=[];let r,i;for(r=0,i=t.length;r<i;++r){const i=t[r];i[n]!==this.id||e&&i.type!==e||s.push(i)}return s}_resolveTickFontOptions(e){return Lt(this.options.ticks.setContext(this.getContext(e)).font)}_maxDigits(){const e=this._resolveTickFontOptions(0).lineHeight;return(this.isHorizontal()?this.width:this.height)/e}}class ar{constructor(e,t,n){this.type=e,this.scope=t,this.override=n,this.items=Object.create(null)}isForType(e){return Object.prototype.isPrototypeOf.call(this.type.prototype,e.prototype)}register(e){const t=Object.getPrototypeOf(e);let n;(function(e){return"id"in e&&"defaults"in e})(t)&&(n=this.register(t));const s=this.items,r=e.id,i=this.scope+"."+r;if(!r)throw new Error("class does not have id: "+e);return r in s||(s[r]=e,function(e,t,n){const s=ie(Object.create(null),[n?ft.get(n):{},ft.get(t),e.defaults]);ft.set(t,s),e.defaultRoutes&&function(e,t){Object.keys(t).forEach((n=>{const s=n.split("."),r=s.pop(),i=[e].concat(s).join("."),a=t[n].split("."),o=a.pop(),l=a.join(".");ft.route(i,r,l,o)}))}(t,e.defaultRoutes);e.descriptors&&ft.describe(t,e.descriptors)}(e,i,n),this.override&&ft.override(e.id,e.overrides)),i}get(e){return this.items[e]}unregister(e){const t=this.items,n=e.id,s=this.scope;n in t&&delete t[n],s&&n in ft[s]&&(delete ft[s][n],this.override&&delete ut[n])}}class or{constructor(){this.controllers=new ar(Yn,"datasets",!0),this.elements=new ar(qs,"elements"),this.plugins=new ar(Object,"plugins"),this.scales=new ar(ir,"scales"),this._typedRegistries=[this.controllers,this.scales,this.elements]}add(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];this._each("register",t)}remove(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];this._each("unregister",t)}addControllers(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];this._each("register",t,this.controllers)}addElements(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];this._each("register",t,this.elements)}addPlugins(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];this._each("register",t,this.plugins)}addScales(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];this._each("register",t,this.scales)}getController(e){return this._get(e,this.controllers,"controller")}getElement(e){return this._get(e,this.elements,"element")}getPlugin(e){return this._get(e,this.plugins,"plugin")}getScale(e){return this._get(e,this.scales,"scale")}removeControllers(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];this._each("unregister",t,this.controllers)}removeElements(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];this._each("unregister",t,this.elements)}removePlugins(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];this._each("unregister",t,this.plugins)}removeScales(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];this._each("unregister",t,this.scales)}_each(e,t,n){[...t].forEach((t=>{const s=n||this._getRegistryForType(t);n||s.isForType(t)||s===this.plugins&&t.id?this._exec(e,s,t):ee(t,(t=>{const s=n||this._getRegistryForType(t);this._exec(e,s,t)}))}))}_exec(e,t,n){const s=ce(e);J(n["before"+s],[],n),t[e](n),J(n["after"+s],[],n)}_getRegistryForType(e){for(let t=0;t<this._typedRegistries.length;t++){const n=this._typedRegistries[t];if(n.isForType(e))return n}return this.plugins}_get(e,t,n){const s=t.get(e);if(void 0===s)throw new Error('"'+e+'" is not a registered '+n+".");return s}}var lr=new or;class ur{constructor(){this._init=[]}notify(e,t,n,s){"beforeInit"===t&&(this._init=this._createDescriptors(e,!0),this._notify(this._init,e,"install"));const r=s?this._descriptors(e).filter(s):this._descriptors(e),i=this._notify(r,e,t,n);return"afterDestroy"===t&&(this._notify(r,e,"stop"),this._notify(this._init,e,"uninstall")),i}_notify(e,t,n,s){s=s||{};for(const r of e){const e=r.plugin;if(!1===J(e[n],[t,s,r.options],e)&&s.cancelable)return!1}return!0}invalidate(){j(this._cache)||(this._oldCache=this._cache,this._cache=void 0)}_descriptors(e){if(this._cache)return this._cache;const t=this._cache=this._createDescriptors(e);return this._notifyStateChanges(e),t}_createDescriptors(e,t){const n=e&&e.config,s=Q(n.options&&n.options.plugins,{}),r=function(e){const t={},n=[],s=Object.keys(lr.plugins.items);for(let i=0;i<s.length;i++)n.push(lr.getPlugin(s[i]));const r=e.plugins||[];for(let i=0;i<r.length;i++){const e=r[i];-1===n.indexOf(e)&&(n.push(e),t[e.id]=!0)}return{plugins:n,localIds:t}}(n);return!1!==s||t?function(e,t,n,s){let{plugins:r,localIds:i}=t;const a=[],o=e.getContext();for(const l of r){const t=l.id,r=cr(n[t],s);null!==r&&a.push({plugin:l,options:hr(e.config,{plugin:l,local:i[t]},r,o)})}return a}(e,r,s,t):[]}_notifyStateChanges(e){const t=this._oldCache||[],n=this._cache,s=(e,t)=>e.filter((e=>!t.some((t=>e.plugin.id===t.plugin.id))));this._notify(s(t,n),e,"stop"),this._notify(s(n,t),e,"start")}}function cr(e,t){return t||!1!==e?!0===e?{}:e:null}function hr(e,t,n,s){let{plugin:r,local:i}=t;const a=e.pluginScopeKeys(r),o=e.getOptionScopes(n,a);return i&&r.defaults&&o.push(r.defaults),e.createResolver(o,s,[""],{scriptable:!1,indexable:!1,allKeys:!0})}function dr(e,t){const n=ft.datasets[e]||{};return((t.datasets||{})[e]||{}).indexAxis||t.indexAxis||n.indexAxis||"x"}function pr(e){if("x"===e||"y"===e||"r"===e)return e}function fr(e){if(pr(e))return e;for(var t=arguments.length,n=new Array(t>1?t-1:0),s=1;s<t;s++)n[s-1]=arguments[s];for(const i of n){const t=i.axis||("top"===(r=i.position)||"bottom"===r?"x":"left"===r||"right"===r?"y":void 0)||e.length>1&&pr(e[0].toLowerCase());if(t)return t}var r;throw new Error(`Cannot determine type of '${e}' axis. Please provide 'axis' or 'position' option.`)}function gr(e,t,n){if(n[t+"AxisID"]===e)return{axis:t}}function mr(e,t){const n=ut[e.type]||{scales:{}},s=t.scales||{},r=dr(e.type,t),i=Object.create(null);return Object.keys(s).forEach((t=>{const a=s[t];if(!X(a))return console.error(`Invalid scale configuration for scale: ${t}`);if(a._proxy)return console.warn(`Ignoring resolver passed as options for scale: ${t}`);const o=fr(t,a,function(e,t){if(t.data&&t.data.datasets){const n=t.data.datasets.filter((t=>t.xAxisID===e||t.yAxisID===e));if(n.length)return gr(e,"x",n[0])||gr(e,"y",n[0])}return{}}(t,e),ft.scales[a.type]),l=function(e,t){return e===t?"_index_":"_value_"}(o,r),u=n.scales||{};i[t]=ae(Object.create(null),[{axis:o},a,u[o],u[l]])})),e.data.datasets.forEach((n=>{const r=n.type||e.type,a=n.indexAxis||dr(r,t),o=(ut[r]||{}).scales||{};Object.keys(o).forEach((e=>{const t=function(e,t){let n=e;return"_index_"===e?n=t:"_value_"===e&&(n="x"===t?"y":"x"),n}(e,a),r=n[t+"AxisID"]||t;i[r]=i[r]||Object.create(null),ae(i[r],[{axis:t},s[r],o[e]])}))})),Object.keys(i).forEach((e=>{const t=i[e];ae(t,[ft.scales[t.type],ft.scale])})),i}function br(e){const t=e.options||(e.options={});t.plugins=Q(t.plugins,{}),t.scales=mr(e,t)}function xr(e){return(e=e||{}).datasets=e.datasets||[],e.labels=e.labels||[],e}const yr=new Map,vr=new Set;function wr(e,t){let n=yr.get(e);return n||(n=t(),yr.set(e,n),vr.add(n)),n}const kr=(e,t,n)=>{const s=ue(t,n);void 0!==s&&e.add(s)};class Sr{constructor(e){this._config=function(e){return(e=e||{}).data=xr(e.data),br(e),e}(e),this._scopeCache=new Map,this._resolverCache=new Map}get platform(){return this._config.platform}get type(){return this._config.type}set type(e){this._config.type=e}get data(){return this._config.data}set data(e){this._config.data=xr(e)}get options(){return this._config.options}set options(e){this._config.options=e}get plugins(){return this._config.plugins}update(){const e=this._config;this.clearCache(),br(e)}clearCache(){this._scopeCache.clear(),this._resolverCache.clear()}datasetScopeKeys(e){return wr(e,(()=>[[`datasets.${e}`,""]]))}datasetAnimationScopeKeys(e,t){return wr(`${e}.transition.${t}`,(()=>[[`datasets.${e}.transitions.${t}`,`transitions.${t}`],[`datasets.${e}`,""]]))}datasetElementScopeKeys(e,t){return wr(`${e}-${t}`,(()=>[[`datasets.${e}.elements.${t}`,`datasets.${e}`,`elements.${t}`,""]]))}pluginScopeKeys(e){const t=e.id;return wr(`${this.type}-plugin-${t}`,(()=>[[`plugins.${t}`,...e.additionalOptionScopes||[]]]))}_cachedScopes(e,t){const n=this._scopeCache;let s=n.get(e);return s&&!t||(s=new Map,n.set(e,s)),s}getOptionScopes(e,t,n){const{options:s,type:r}=this,i=this._cachedScopes(e,n),a=i.get(t);if(a)return a;const o=new Set;t.forEach((t=>{e&&(o.add(e),t.forEach((t=>kr(o,e,t)))),t.forEach((e=>kr(o,s,e))),t.forEach((e=>kr(o,ut[r]||{},e))),t.forEach((e=>kr(o,ft,e))),t.forEach((e=>kr(o,ct,e)))}));const l=Array.from(o);return 0===l.length&&l.push(Object.create(null)),vr.has(t)&&i.set(t,l),l}chartOptionScopes(){const{options:e,type:t}=this;return[e,ut[t]||{},ft.datasets[t]||{},{type:t},ft,ct]}resolveNamedOptions(e,t,n){let s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[""];const r={$shared:!0},{resolver:i,subPrefixes:a}=Ir(this._resolverCache,e,s);let o=i;if(function(e,t){const{isScriptable:n,isIndexable:s}=Vt(e);for(const r of t){const t=n(r),i=s(r),a=(i||t)&&e[r];if(t&&(de(a)||Cr(a))||i&&K(a))return!0}return!1}(i,t)){r.$shared=!1;o=Wt(i,n=de(n)?n():n,this.createResolver(e,n,a))}for(const l of t)r[l]=o[l];return r}createResolver(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[""],s=arguments.length>3?arguments[3]:void 0;const{resolver:r}=Ir(this._resolverCache,e,n);return X(t)?Wt(r,t,void 0,s):r}}function Ir(e,t,n){let s=e.get(t);s||(s=new Map,e.set(t,s));const r=n.join();let i=s.get(r);if(!i){i={resolver:Bt(t,n),subPrefixes:n.filter((e=>!e.toLowerCase().includes("hover")))},s.set(r,i)}return i}const Cr=e=>X(e)&&Object.getOwnPropertyNames(e).some((t=>de(e[t])));const Nr=["top","bottom","left","right","chartArea"];function Tr(e,t){return"top"===e||"bottom"===e||-1===Nr.indexOf(e)&&"x"===t}function _r(e,t){return function(n,s){return n[e]===s[e]?n[t]-s[t]:n[e]-s[e]}}function Er(e){const t=e.chart,n=t.options.animation;t.notifyPlugins("afterRender"),J(n&&n.onComplete,[e],t)}function $r(e){const t=e.chart,n=t.options.animation;J(n&&n.onProgress,[e],t)}function Rr(e){return ln()&&"string"===typeof e?e=document.getElementById(e):e&&e.length&&(e=e[0]),e&&e.canvas&&(e=e.canvas),e}const Ar={},Dr=e=>{const t=Rr(e);return Object.values(Ar).filter((e=>e.canvas===t)).pop()};function Fr(e,t,n){const s=Object.keys(e);for(const r of s){const s=+r;if(s>=t){const i=e[r];delete e[r],(n>0||s>t)&&(e[s+n]=i)}}}function Mr(e,t,n){return e.options.clip?e[n]:t[n]}class Or{static defaults=(()=>ft)();static instances=(()=>Ar)();static overrides=(()=>ut)();static registry=(()=>lr)();static version="4.4.5";static getChart=(()=>Dr)();static register(){lr.add(...arguments),Lr()}static unregister(){lr.remove(...arguments),Lr()}constructor(e,t){const n=this.config=new Sr(t),s=Rr(e),r=Dr(s);if(r)throw new Error("Canvas is already in use. Chart with ID '"+r.id+"' must be destroyed before the canvas with ID '"+r.canvas.id+"' can be reused.");const i=n.createResolver(n.chartOptionScopes(),this.getContext());this.platform=new(n.platform||function(e){return!ln()||"undefined"!==typeof OffscreenCanvas&&e instanceof OffscreenCanvas?Ds:Xs}(s)),this.platform.updateConfig(n);const a=this.platform.acquireContext(s,i.aspectRatio),o=a&&a.canvas,l=o&&o.height,u=o&&o.width;this.id=H(),this.ctx=a,this.canvas=o,this.width=u,this.height=l,this._options=i,this._aspectRatio=this.aspectRatio,this._layers=[],this._metasets=[],this._stacks=void 0,this.boxes=[],this.currentDevicePixelRatio=void 0,this.chartArea=void 0,this._active=[],this._lastEvent=void 0,this._listeners={},this._responsiveListeners=void 0,this._sortedMetasets=[],this.scales={},this._plugins=new ur,this.$proxies={},this._hiddenIndices={},this.attached=!1,this._animationsDisabled=void 0,this.$context=void 0,this._doResize=function(e,t){let n;return function(){for(var s=arguments.length,r=new Array(s),i=0;i<s;i++)r[i]=arguments[i];return t?(clearTimeout(n),n=setTimeout(e,t,r)):e.apply(this,r),t}}((e=>this.update(e)),i.resizeDelay||0),this._dataChanges=[],Ar[this.id]=this,a&&o?(Fn.listen(this,"complete",Er),Fn.listen(this,"progress",$r),this._initialize(),this.attached&&this.update()):console.error("Failed to create chart: can't acquire context from the given item")}get aspectRatio(){const{options:{aspectRatio:e,maintainAspectRatio:t},width:n,height:s,_aspectRatio:r}=this;return j(e)?t&&r?r:s?n/s:null:e}get data(){return this.config.data}set data(e){this.config.data=e}get options(){return this._options}set options(e){this.config.options=e}get registry(){return lr}_initialize(){return this.notifyPlugins("beforeInit"),this.options.responsive?this.resize():bn(this,this.options.devicePixelRatio),this.bindEvents(),this.notifyPlugins("afterInit"),this}clear(){return xt(this.canvas,this.ctx),this}stop(){return Fn.stop(this),this}resize(e,t){Fn.running(this)?this._resizeBeforeDraw={width:e,height:t}:this._resize(e,t)}_resize(e,t){const n=this.options,s=this.canvas,r=n.maintainAspectRatio&&this.aspectRatio,i=this.platform.getMaximumSize(s,e,t,r),a=n.devicePixelRatio||this.platform.getDevicePixelRatio(),o=this.width?"resize":"attach";this.width=i.width,this.height=i.height,this._aspectRatio=this.aspectRatio,bn(this,a,!0)&&(this.notifyPlugins("resize",{size:i}),J(n.onResize,[this,i],this),this.attached&&this._doResize(o)&&this.render())}ensureScalesHaveIDs(){ee(this.options.scales||{},((e,t)=>{e.id=t}))}buildOrUpdateScales(){const e=this.options,t=e.scales,n=this.scales,s=Object.keys(n).reduce(((e,t)=>(e[t]=!1,e)),{});let r=[];t&&(r=r.concat(Object.keys(t).map((e=>{const n=t[e],s=fr(e,n),r="r"===s,i="x"===s;return{options:n,dposition:r?"chartArea":i?"bottom":"left",dtype:r?"radialLinear":i?"category":"linear"}})))),ee(r,(t=>{const r=t.options,i=r.id,a=fr(i,r),o=Q(r.type,t.dtype);void 0!==r.position&&Tr(r.position,a)===Tr(t.dposition)||(r.position=t.dposition),s[i]=!0;let l=null;if(i in n&&n[i].type===o)l=n[i];else{l=new(lr.getScale(o))({id:i,type:o,ctx:this.ctx,chart:this}),n[l.id]=l}l.init(r,e)})),ee(s,((e,t)=>{e||delete n[t]})),ee(n,(e=>{Rs.configure(this,e,e.options),Rs.addBox(this,e)}))}_updateMetasets(){const e=this._metasets,t=this.data.datasets.length,n=e.length;if(e.sort(((e,t)=>e.index-t.index)),n>t){for(let e=t;e<n;++e)this._destroyDatasetMeta(e);e.splice(t,n-t)}this._sortedMetasets=e.slice(0).sort(_r("order","index"))}_removeUnreferencedMetasets(){const{_metasets:e,data:{datasets:t}}=this;e.length>t.length&&delete this._stacks,e.forEach(((e,n)=>{0===t.filter((t=>t===e._dataset)).length&&this._destroyDatasetMeta(n)}))}buildOrUpdateControllers(){const e=[],t=this.data.datasets;let n,s;for(this._removeUnreferencedMetasets(),n=0,s=t.length;n<s;n++){const s=t[n];let r=this.getDatasetMeta(n);const i=s.type||this.config.type;if(r.type&&r.type!==i&&(this._destroyDatasetMeta(n),r=this.getDatasetMeta(n)),r.type=i,r.indexAxis=s.indexAxis||dr(i,this.options),r.order=s.order||0,r.index=n,r.label=""+s.label,r.visible=this.isDatasetVisible(n),r.controller)r.controller.updateIndex(n),r.controller.linkScales();else{const t=lr.getController(i),{datasetElementType:s,dataElementType:a}=ft.datasets[i];Object.assign(t,{dataElementType:lr.getElement(a),datasetElementType:s&&lr.getElement(s)}),r.controller=new t(this,n),e.push(r.controller)}}return this._updateMetasets(),e}_resetElements(){ee(this.data.datasets,((e,t)=>{this.getDatasetMeta(t).controller.reset()}),this)}reset(){this._resetElements(),this.notifyPlugins("reset")}update(e){const t=this.config;t.update();const n=this._options=t.createResolver(t.chartOptionScopes(),this.getContext()),s=this._animationsDisabled=!n.animation;if(this._updateScales(),this._checkEventBindings(),this._updateHiddenIndices(),this._plugins.invalidate(),!1===this.notifyPlugins("beforeUpdate",{mode:e,cancelable:!0}))return;const r=this.buildOrUpdateControllers();this.notifyPlugins("beforeElementsUpdate");let i=0;for(let l=0,u=this.data.datasets.length;l<u;l++){const{controller:e}=this.getDatasetMeta(l),t=!s&&-1===r.indexOf(e);e.buildOrUpdateElements(t),i=Math.max(+e.getMaxOverflow(),i)}i=this._minPadding=n.layout.autoPadding?i:0,this._updateLayout(i),s||ee(r,(e=>{e.reset()})),this._updateDatasets(e),this.notifyPlugins("afterUpdate",{mode:e}),this._layers.sort(_r("z","_idx"));const{_active:a,_lastEvent:o}=this;o?this._eventHandler(o,!0):a.length&&this._updateHoverStyles(a,a,!0),this.render()}_updateScales(){ee(this.scales,(e=>{Rs.removeBox(this,e)})),this.ensureScalesHaveIDs(),this.buildOrUpdateScales()}_checkEventBindings(){const e=this.options,t=new Set(Object.keys(this._listeners)),n=new Set(e.events);pe(t,n)&&!!this._responsiveListeners===e.responsive||(this.unbindEvents(),this.bindEvents())}_updateHiddenIndices(){const{_hiddenIndices:e}=this,t=this._getUniformDataChanges()||[];for(const{method:n,start:s,count:r}of t){Fr(e,s,"_removeElements"===n?-r:r)}}_getUniformDataChanges(){const e=this._dataChanges;if(!e||!e.length)return;this._dataChanges=[];const t=this.data.datasets.length,n=t=>new Set(e.filter((e=>e[0]===t)).map(((e,t)=>t+","+e.splice(1).join(",")))),s=n(0);for(let r=1;r<t;r++)if(!pe(s,n(r)))return;return Array.from(s).map((e=>e.split(","))).map((e=>({method:e[1],start:+e[2],count:+e[3]})))}_updateLayout(e){if(!1===this.notifyPlugins("beforeLayout",{cancelable:!0}))return;Rs.update(this,this.width,this.height,e);const t=this.chartArea,n=t.width<=0||t.height<=0;this._layers=[],ee(this.boxes,(e=>{n&&"chartArea"===e.position||(e.configure&&e.configure(),this._layers.push(...e._layers()))}),this),this._layers.forEach(((e,t)=>{e._idx=t})),this.notifyPlugins("afterLayout")}_updateDatasets(e){if(!1!==this.notifyPlugins("beforeDatasetsUpdate",{mode:e,cancelable:!0})){for(let e=0,t=this.data.datasets.length;e<t;++e)this.getDatasetMeta(e).controller.configure();for(let t=0,n=this.data.datasets.length;t<n;++t)this._updateDataset(t,de(e)?e({datasetIndex:t}):e);this.notifyPlugins("afterDatasetsUpdate",{mode:e})}}_updateDataset(e,t){const n=this.getDatasetMeta(e),s={meta:n,index:e,mode:t,cancelable:!0};!1!==this.notifyPlugins("beforeDatasetUpdate",s)&&(n.controller._update(t),s.cancelable=!1,this.notifyPlugins("afterDatasetUpdate",s))}render(){!1!==this.notifyPlugins("beforeRender",{cancelable:!0})&&(Fn.has(this)?this.attached&&!Fn.running(this)&&Fn.start(this):(this.draw(),Er({chart:this})))}draw(){let e;if(this._resizeBeforeDraw){const{width:e,height:t}=this._resizeBeforeDraw;this._resizeBeforeDraw=null,this._resize(e,t)}if(this.clear(),this.width<=0||this.height<=0)return;if(!1===this.notifyPlugins("beforeDraw",{cancelable:!0}))return;const t=this._layers;for(e=0;e<t.length&&t[e].z<=0;++e)t[e].draw(this.chartArea);for(this._drawDatasets();e<t.length;++e)t[e].draw(this.chartArea);this.notifyPlugins("afterDraw")}_getSortedDatasetMetas(e){const t=this._sortedMetasets,n=[];let s,r;for(s=0,r=t.length;s<r;++s){const r=t[s];e&&!r.visible||n.push(r)}return n}getSortedVisibleDatasetMetas(){return this._getSortedDatasetMetas(!0)}_drawDatasets(){if(!1===this.notifyPlugins("beforeDatasetsDraw",{cancelable:!0}))return;const e=this.getSortedVisibleDatasetMetas();for(let t=e.length-1;t>=0;--t)this._drawDataset(e[t]);this.notifyPlugins("afterDatasetsDraw")}_drawDataset(e){const t=this.ctx,n=e._clip,s=!n.disabled,r=function(e,t){const{xScale:n,yScale:s}=e;return n&&s?{left:Mr(n,t,"left"),right:Mr(n,t,"right"),top:Mr(s,t,"top"),bottom:Mr(s,t,"bottom")}:t}(e,this.chartArea),i={meta:e,index:e.index,cancelable:!0};!1!==this.notifyPlugins("beforeDatasetDraw",i)&&(s&&kt(t,{left:!1===n.left?0:r.left-n.left,right:!1===n.right?this.width:r.right+n.right,top:!1===n.top?0:r.top-n.top,bottom:!1===n.bottom?this.height:r.bottom+n.bottom}),e.controller.draw(),s&&St(t),i.cancelable=!1,this.notifyPlugins("afterDatasetDraw",i))}isPointInArea(e){return wt(e,this.chartArea,this._minPadding)}getElementsAtEventForMode(e,t,n,s){const r=xs.modes[t];return"function"===typeof r?r(this,e,n,s):[]}getDatasetMeta(e){const t=this.data.datasets[e],n=this._metasets;let s=n.filter((e=>e&&e._dataset===t)).pop();return s||(s={type:null,data:[],dataset:null,controller:null,hidden:null,xAxisID:null,yAxisID:null,order:t&&t.order||0,index:e,_dataset:t,_parsed:[],_sorted:!1},n.push(s)),s}getContext(){return this.$context||(this.$context=zt(null,{chart:this,type:"chart"}))}getVisibleDatasetCount(){return this.getSortedVisibleDatasetMetas().length}isDatasetVisible(e){const t=this.data.datasets[e];if(!t)return!1;const n=this.getDatasetMeta(e);return"boolean"===typeof n.hidden?!n.hidden:!t.hidden}setDatasetVisibility(e,t){this.getDatasetMeta(e).hidden=!t}toggleDataVisibility(e){this._hiddenIndices[e]=!this._hiddenIndices[e]}getDataVisibility(e){return!this._hiddenIndices[e]}_updateVisibility(e,t,n){const s=n?"show":"hide",r=this.getDatasetMeta(e),i=r.controller._resolveAnimations(void 0,s);he(t)?(r.data[t].hidden=!n,this.update()):(this.setDatasetVisibility(e,n),i.update(r,{visible:n}),this.update((t=>t.datasetIndex===e?s:void 0)))}hide(e,t){this._updateVisibility(e,t,!1)}show(e,t){this._updateVisibility(e,t,!0)}_destroyDatasetMeta(e){const t=this._metasets[e];t&&t.controller&&t.controller._destroy(),delete this._metasets[e]}_stop(){let e,t;for(this.stop(),Fn.remove(this),e=0,t=this.data.datasets.length;e<t;++e)this._destroyDatasetMeta(e)}destroy(){this.notifyPlugins("beforeDestroy");const{canvas:e,ctx:t}=this;this._stop(),this.config.clearCache(),e&&(this.unbindEvents(),xt(e,t),this.platform.releaseContext(t),this.canvas=null,this.ctx=null),delete Ar[this.id],this.notifyPlugins("afterDestroy")}toBase64Image(){return this.canvas.toDataURL(...arguments)}bindEvents(){this.bindUserEvents(),this.options.responsive?this.bindResponsiveEvents():this.attached=!0}bindUserEvents(){const e=this._listeners,t=this.platform,n=(n,s)=>{t.addEventListener(this,n,s),e[n]=s},s=(e,t,n)=>{e.offsetX=t,e.offsetY=n,this._eventHandler(e)};ee(this.options.events,(e=>n(e,s)))}bindResponsiveEvents(){this._responsiveListeners||(this._responsiveListeners={});const e=this._responsiveListeners,t=this.platform,n=(n,s)=>{t.addEventListener(this,n,s),e[n]=s},s=(n,s)=>{e[n]&&(t.removeEventListener(this,n,s),delete e[n])},r=(e,t)=>{this.canvas&&this.resize(e,t)};let i;const a=()=>{s("attach",a),this.attached=!0,this.resize(),n("resize",r),n("detach",i)};i=()=>{this.attached=!1,s("resize",r),this._stop(),this._resize(0,0),n("attach",a)},t.isAttached(this.canvas)?a():i()}unbindEvents(){ee(this._listeners,((e,t)=>{this.platform.removeEventListener(this,t,e)})),this._listeners={},ee(this._responsiveListeners,((e,t)=>{this.platform.removeEventListener(this,t,e)})),this._responsiveListeners=void 0}updateHoverStyle(e,t,n){const s=n?"set":"remove";let r,i,a,o;for("dataset"===t&&(r=this.getDatasetMeta(e[0].datasetIndex),r.controller["_"+s+"DatasetHoverStyle"]()),a=0,o=e.length;a<o;++a){i=e[a];const t=i&&this.getDatasetMeta(i.datasetIndex).controller;t&&t[s+"HoverStyle"](i.element,i.datasetIndex,i.index)}}getActiveElements(){return this._active||[]}setActiveElements(e){const t=this._active||[],n=e.map((e=>{let{datasetIndex:t,index:n}=e;const s=this.getDatasetMeta(t);if(!s)throw new Error("No dataset found at index "+t);return{datasetIndex:t,element:s.data[n],index:n}}));!te(n,t)&&(this._active=n,this._lastEvent=null,this._updateHoverStyles(n,t))}notifyPlugins(e,t,n){return this._plugins.notify(this,e,t,n)}isPluginEnabled(e){return 1===this._plugins._cache.filter((t=>t.plugin.id===e)).length}_updateHoverStyles(e,t,n){const s=this.options.hover,r=(e,t)=>e.filter((e=>!t.some((t=>e.datasetIndex===t.datasetIndex&&e.index===t.index)))),i=r(t,e),a=n?e:r(e,t);i.length&&this.updateHoverStyle(i,s.mode,!1),a.length&&s.mode&&this.updateHoverStyle(a,s.mode,!0)}_eventHandler(e,t){const n={event:e,replay:t,cancelable:!0,inChartArea:this.isPointInArea(e)},s=t=>(t.options.events||this.options.events).includes(e.native.type);if(!1===this.notifyPlugins("beforeEvent",n,s))return;const r=this._handleEvent(e,t,n.inChartArea);return n.cancelable=!1,this.notifyPlugins("afterEvent",n,s),(r||n.changed)&&this.render(),this}_handleEvent(e,t,n){const{_active:s=[],options:r}=this,i=t,a=this._getActiveElements(e,s,n,i),o=function(e){return"mouseup"===e.type||"click"===e.type||"contextmenu"===e.type}(e),l=function(e,t,n,s){return n&&"mouseout"!==e.type?s?t:e:null}(e,this._lastEvent,n,o);n&&(this._lastEvent=null,J(r.onHover,[e,a,this],this),o&&J(r.onClick,[e,a,this],this));const u=!te(a,s);return(u||t)&&(this._active=a,this._updateHoverStyles(a,s,t)),this._lastEvent=l,u}_getActiveElements(e,t,n,s){if("mouseout"===e.type)return[];if(!n)return t;const r=this.options.hover;return this.getElementsAtEventForMode(e,r.mode,r,s)}}function Lr(){return ee(Or.instances,(e=>e._plugins.invalidate()))}function Pr(e,t,n,s){const r=Dt(e.options.borderRadius,["outerStart","outerEnd","innerStart","innerEnd"]);const i=(n-t)/2,a=Math.min(i,s*t/2),o=e=>{const t=(n-Math.min(i,e))*s/2;return Oe(e,0,Math.min(i,t))};return{outerStart:o(r.outerStart),outerEnd:o(r.outerEnd),innerStart:Oe(r.innerStart,0,a),innerEnd:Oe(r.innerEnd,0,a)}}function zr(e,t,n,s){return{x:n+e*Math.cos(t),y:s+e*Math.sin(t)}}function Br(e,t,n,s,r,i){const{x:a,y:o,startAngle:l,pixelMargin:u,innerRadius:c}=t,h=Math.max(t.outerRadius+s+n-u,0),d=c>0?c+s+n+u:0;let p=0;const f=r-l;if(s){const e=((c>0?c-s:0)+(h>0?h-s:0))/2;p=(f-(0!==e?f*e/(e+s):f))/2}const g=(f-Math.max(.001,f*h-n/fe)/h)/2,m=l+g+p,b=r-g-p,{outerStart:x,outerEnd:y,innerStart:v,innerEnd:w}=Pr(t,d,h,b-m),k=h-x,S=h-y,I=m+x/k,C=b-y/S,N=d+v,T=d+w,_=m+v/N,E=b-w/T;if(e.beginPath(),i){const t=(I+C)/2;if(e.arc(a,o,h,I,t),e.arc(a,o,h,t,C),y>0){const t=zr(S,C,a,o);e.arc(t.x,t.y,y,C,b+ye)}const n=zr(T,b,a,o);if(e.lineTo(n.x,n.y),w>0){const t=zr(T,E,a,o);e.arc(t.x,t.y,w,b+ye,E+Math.PI)}const s=(b-w/d+(m+v/d))/2;if(e.arc(a,o,d,b-w/d,s,!0),e.arc(a,o,d,s,m+v/d,!0),v>0){const t=zr(N,_,a,o);e.arc(t.x,t.y,v,_+Math.PI,m-ye)}const r=zr(k,m,a,o);if(e.lineTo(r.x,r.y),x>0){const t=zr(k,I,a,o);e.arc(t.x,t.y,x,m-ye,I)}}else{e.moveTo(a,o);const t=Math.cos(I)*h+a,n=Math.sin(I)*h+o;e.lineTo(t,n);const s=Math.cos(C)*h+a,r=Math.sin(C)*h+o;e.lineTo(s,r)}e.closePath()}function Wr(e,t,n,s,r){const{fullCircles:i,startAngle:a,circumference:o,options:l}=t,{borderWidth:u,borderJoinStyle:c,borderDash:h,borderDashOffset:d}=l,p="inner"===l.borderAlign;if(!u)return;e.setLineDash(h||[]),e.lineDashOffset=d,p?(e.lineWidth=2*u,e.lineJoin=c||"round"):(e.lineWidth=u,e.lineJoin=c||"bevel");let f=t.endAngle;if(i){Br(e,t,n,s,f,r);for(let t=0;t<i;++t)e.stroke();isNaN(o)||(f=a+(o%ge||ge))}p&&function(e,t,n){const{startAngle:s,pixelMargin:r,x:i,y:a,outerRadius:o,innerRadius:l}=t;let u=r/o;e.beginPath(),e.arc(i,a,o,s-u,n+u),l>r?(u=r/l,e.arc(i,a,l,n+u,s-u,!0)):e.arc(i,a,r,n+ye,s-ye),e.closePath(),e.clip()}(e,t,f),i||(Br(e,t,n,s,f,r),e.stroke())}function Vr(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t;e.lineCap=Q(n.borderCapStyle,t.borderCapStyle),e.setLineDash(Q(n.borderDash,t.borderDash)),e.lineDashOffset=Q(n.borderDashOffset,t.borderDashOffset),e.lineJoin=Q(n.borderJoinStyle,t.borderJoinStyle),e.lineWidth=Q(n.borderWidth,t.borderWidth),e.strokeStyle=Q(n.borderColor,t.borderColor)}function Ur(e,t,n){e.lineTo(n.x,n.y)}function Gr(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const s=e.length,{start:r=0,end:i=s-1}=n,{start:a,end:o}=t,l=Math.max(r,a),u=Math.min(i,o),c=r<a&&i<a||r>o&&i>o;return{count:s,start:l,loop:t.loop,ilen:u<l&&!c?s+u-l:u-l}}function Hr(e,t,n,s){const{points:r,options:i}=t,{count:a,start:o,loop:l,ilen:u}=Gr(r,n,s),c=function(e){return e.stepped?It:e.tension||"monotone"===e.cubicInterpolationMode?Ct:Ur}(i);let h,d,p,{move:f=!0,reverse:g}=s||{};for(h=0;h<=u;++h)d=r[(o+(g?u-h:h))%a],d.skip||(f?(e.moveTo(d.x,d.y),f=!1):c(e,p,d,g,i.stepped),p=d);return l&&(d=r[(o+(g?u:0))%a],c(e,p,d,g,i.stepped)),!!l}function jr(e,t,n,s){const r=t.points,{count:i,start:a,ilen:o}=Gr(r,n,s),{move:l=!0,reverse:u}=s||{};let c,h,d,p,f,g,m=0,b=0;const x=e=>(a+(u?o-e:e))%i,y=()=>{p!==f&&(e.lineTo(m,f),e.lineTo(m,p),e.lineTo(m,g))};for(l&&(h=r[x(0)],e.moveTo(h.x,h.y)),c=0;c<=o;++c){if(h=r[x(c)],h.skip)continue;const t=h.x,n=h.y,s=0|t;s===d?(n<p?p=n:n>f&&(f=n),m=(b*m+t)/++b):(y(),e.lineTo(t,n),d=s,b=0,p=f=n),g=n}y()}function Kr(e){const t=e.options,n=t.borderDash&&t.borderDash.length;return!e._decimated&&!e._loop&&!t.tension&&"monotone"!==t.cubicInterpolationMode&&!t.stepped&&!n?jr:Hr}const Xr="function"===typeof Path2D;function qr(e,t,n,s){Xr&&!t.options.segment?function(e,t,n,s){let r=t._path;r||(r=t._path=new Path2D,t.path(r,n,s)&&r.closePath()),Vr(e,t.options),e.stroke(r)}(e,t,n,s):function(e,t,n,s){const{segments:r,options:i}=t,a=Kr(t);for(const o of r)Vr(e,i,o.style),e.beginPath(),a(e,t,o,{start:n,end:n+s-1})&&e.closePath(),e.stroke()}(e,t,n,s)}class Yr extends qs{static id="line";static defaults={borderCapStyle:"butt",borderDash:[],borderDashOffset:0,borderJoinStyle:"miter",borderWidth:3,capBezierPoints:!0,cubicInterpolationMode:"default",fill:!1,spanGaps:!1,stepped:!1,tension:0};static defaultRoutes={backgroundColor:"backgroundColor",borderColor:"borderColor"};static descriptors={_scriptable:!0,_indexable:e=>"borderDash"!==e&&"fill"!==e};constructor(e){super(),this.animated=!0,this.options=void 0,this._chart=void 0,this._loop=void 0,this._fullLoop=void 0,this._path=void 0,this._points=void 0,this._segments=void 0,this._decimated=!1,this._pointsUpdated=!1,this._datasetIndex=void 0,e&&Object.assign(this,e)}updateControlPoints(e,t){const n=this.options;if((n.tension||"monotone"===n.cubicInterpolationMode)&&!n.stepped&&!this._pointsUpdated){const s=n.spanGaps?this._loop:this._fullLoop;on(this._points,n,e,s,t),this._pointsUpdated=!0}}set points(e){this._points=e,delete this._segments,delete this._path,this._pointsUpdated=!1}get points(){return this._points}get segments(){return this._segments||(this._segments=function(e,t){const n=e.points,s=e.options.spanGaps,r=n.length;if(!r)return[];const i=!!e._loop,{start:a,end:o}=function(e,t,n,s){let r=0,i=t-1;if(n&&!s)for(;r<t&&!e[r].skip;)r++;for(;r<t&&e[r].skip;)r++;for(r%=t,n&&(i+=r);i>r&&e[i%t].skip;)i--;return i%=t,{start:r,end:i}}(n,r,i,s);return $n(e,!0===s?[{start:a,end:o,loop:i}]:function(e,t,n,s){const r=e.length,i=[];let a,o=t,l=e[t];for(a=t+1;a<=n;++a){const n=e[a%r];n.skip||n.stop?l.skip||(s=!1,i.push({start:t%r,end:(a-1)%r,loop:s}),t=o=n.stop?a:null):(o=a,l.skip&&(t=a)),l=n}return null!==o&&i.push({start:t%r,end:o%r,loop:s}),i}(n,a,o<a?o+r:o,!!e._fullLoop&&0===a&&o===r-1),n,t)}(this,this.options.segment))}first(){const e=this.segments,t=this.points;return e.length&&t[e[0].start]}last(){const e=this.segments,t=this.points,n=e.length;return n&&t[e[n-1].end]}interpolate(e,t){const n=this.options,s=e[t],r=this.points,i=En(this,{property:t,start:s,end:s});if(!i.length)return;const a=[],o=function(e){return e.stepped?wn:e.tension||"monotone"===e.cubicInterpolationMode?kn:vn}(n);let l,u;for(l=0,u=i.length;l<u;++l){const{start:u,end:c}=i[l],h=r[u],d=r[c];if(h===d){a.push(h);continue}const p=o(h,d,Math.abs((s-h[t])/(d[t]-h[t])),n.stepped);p[t]=e[t],a.push(p)}return 1===a.length?a[0]:a}pathSegment(e,t,n){return Kr(this)(e,this,t,n)}path(e,t,n){const s=this.segments,r=Kr(this);let i=this._loop;t=t||0,n=n||this.points.length-t;for(const a of s)i&=r(e,this,a,{start:t,end:t+n-1});return!!i}draw(e,t,n,s){const r=this.options||{};(this.points||[]).length&&r.borderWidth&&(e.save(),qr(e,this,n,s),e.restore()),this.animated&&(this._pointsUpdated=!1,this._path=void 0)}}function Qr(e,t,n,s){const r=e.options,{[n]:i}=e.getProps([n],s);return Math.abs(t-i)<r.radius+r.hitRadius}function Zr(e,t){const{x:n,y:s,base:r,width:i,height:a}=e.getProps(["x","y","base","width","height"],t);let o,l,u,c,h;return e.horizontal?(h=a/2,o=Math.min(n,r),l=Math.max(n,r),u=s-h,c=s+h):(h=i/2,o=n-h,l=n+h,u=Math.min(s,r),c=Math.max(s,r)),{left:o,top:u,right:l,bottom:c}}function Jr(e,t,n,s){return e?0:Oe(t,n,s)}function ei(e){const t=Zr(e),n=t.right-t.left,s=t.bottom-t.top,r=function(e,t,n){const s=e.options.borderWidth,r=e.borderSkipped,i=Ft(s);return{t:Jr(r.top,i.top,0,n),r:Jr(r.right,i.right,0,t),b:Jr(r.bottom,i.bottom,0,n),l:Jr(r.left,i.left,0,t)}}(e,n/2,s/2),i=function(e,t,n){const{enableBorderRadius:s}=e.getProps(["enableBorderRadius"]),r=e.options.borderRadius,i=Mt(r),a=Math.min(t,n),o=e.borderSkipped,l=s||X(r);return{topLeft:Jr(!l||o.top||o.left,i.topLeft,0,a),topRight:Jr(!l||o.top||o.right,i.topRight,0,a),bottomLeft:Jr(!l||o.bottom||o.left,i.bottomLeft,0,a),bottomRight:Jr(!l||o.bottom||o.right,i.bottomRight,0,a)}}(e,n/2,s/2);return{outer:{x:t.left,y:t.top,w:n,h:s,radius:i},inner:{x:t.left+r.l,y:t.top+r.t,w:n-r.l-r.r,h:s-r.t-r.b,radius:{topLeft:Math.max(0,i.topLeft-Math.max(r.t,r.l)),topRight:Math.max(0,i.topRight-Math.max(r.t,r.r)),bottomLeft:Math.max(0,i.bottomLeft-Math.max(r.b,r.l)),bottomRight:Math.max(0,i.bottomRight-Math.max(r.b,r.r))}}}}function ti(e,t,n,s){const r=null===t,i=null===n,a=e&&!(r&&i)&&Zr(e,s);return a&&(r||Le(t,a.left,a.right))&&(i||Le(n,a.top,a.bottom))}function ni(e,t){e.rect(t.x,t.y,t.w,t.h)}function si(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const s=e.x!==n.x?-t:0,r=e.y!==n.y?-t:0,i=(e.x+e.w!==n.x+n.w?t:0)-s,a=(e.y+e.h!==n.y+n.h?t:0)-r;return{x:e.x+s,y:e.y+r,w:e.w+i,h:e.h+a,radius:e.radius}}var ri=Object.freeze({__proto__:null,ArcElement:class extends qs{static id="arc";static defaults={borderAlign:"center",borderColor:"#fff",borderDash:[],borderDashOffset:0,borderJoinStyle:void 0,borderRadius:0,borderWidth:2,offset:0,spacing:0,angle:void 0,circular:!0};static defaultRoutes={backgroundColor:"backgroundColor"};static descriptors={_scriptable:!0,_indexable:e=>"borderDash"!==e};circumference;endAngle;fullCircles;innerRadius;outerRadius;pixelMargin;startAngle;constructor(e){super(),this.options=void 0,this.circumference=void 0,this.startAngle=void 0,this.endAngle=void 0,this.innerRadius=void 0,this.outerRadius=void 0,this.pixelMargin=0,this.fullCircles=0,e&&Object.assign(this,e)}inRange(e,t,n){const s=this.getProps(["x","y"],n),{angle:r,distance:i}=Re(s,{x:e,y:t}),{startAngle:a,endAngle:o,innerRadius:l,outerRadius:u,circumference:c}=this.getProps(["startAngle","endAngle","innerRadius","outerRadius","circumference"],n),h=(this.options.spacing+this.options.borderWidth)/2,d=Q(c,o-a),p=Me(r,a,o)&&a!==o,f=d>=ge||p,g=Le(i,l+h,u+h);return f&&g}getCenterPoint(e){const{x:t,y:n,startAngle:s,endAngle:r,innerRadius:i,outerRadius:a}=this.getProps(["x","y","startAngle","endAngle","innerRadius","outerRadius"],e),{offset:o,spacing:l}=this.options,u=(s+r)/2,c=(i+a+l+o)/2;return{x:t+Math.cos(u)*c,y:n+Math.sin(u)*c}}tooltipPosition(e){return this.getCenterPoint(e)}draw(e){const{options:t,circumference:n}=this,s=(t.offset||0)/4,r=(t.spacing||0)/2,i=t.circular;if(this.pixelMargin="inner"===t.borderAlign?.33:0,this.fullCircles=n>ge?Math.floor(n/ge):0,0===n||this.innerRadius<0||this.outerRadius<0)return;e.save();const a=(this.startAngle+this.endAngle)/2;e.translate(Math.cos(a)*s,Math.sin(a)*s);const o=s*(1-Math.sin(Math.min(fe,n||0)));e.fillStyle=t.backgroundColor,e.strokeStyle=t.borderColor,function(e,t,n,s,r){const{fullCircles:i,startAngle:a,circumference:o}=t;let l=t.endAngle;if(i){Br(e,t,n,s,l,r);for(let t=0;t<i;++t)e.fill();isNaN(o)||(l=a+(o%ge||ge))}Br(e,t,n,s,l,r),e.fill()}(e,this,o,r,i),Wr(e,this,o,r,i),e.restore()}},BarElement:class extends qs{static id="bar";static defaults={borderSkipped:"start",borderWidth:0,borderRadius:0,inflateAmount:"auto",pointStyle:void 0};static defaultRoutes={backgroundColor:"backgroundColor",borderColor:"borderColor"};constructor(e){super(),this.options=void 0,this.horizontal=void 0,this.base=void 0,this.width=void 0,this.height=void 0,this.inflateAmount=void 0,e&&Object.assign(this,e)}draw(e){const{inflateAmount:t,options:{borderColor:n,backgroundColor:s}}=this,{inner:r,outer:i}=ei(this),a=(o=i.radius).topLeft||o.topRight||o.bottomLeft||o.bottomRight?Et:ni;var o;e.save(),i.w===r.w&&i.h===r.h||(e.beginPath(),a(e,si(i,t,r)),e.clip(),a(e,si(r,-t,i)),e.fillStyle=n,e.fill("evenodd")),e.beginPath(),a(e,si(r,t)),e.fillStyle=s,e.fill(),e.restore()}inRange(e,t,n){return ti(this,e,t,n)}inXRange(e,t){return ti(this,e,null,t)}inYRange(e,t){return ti(this,null,e,t)}getCenterPoint(e){const{x:t,y:n,base:s,horizontal:r}=this.getProps(["x","y","base","horizontal"],e);return{x:r?(t+s)/2:t,y:r?n:(n+s)/2}}getRange(e){return"x"===e?this.width/2:this.height/2}},LineElement:Yr,PointElement:class extends qs{static id="point";parsed;skip;stop;static defaults={borderWidth:1,hitRadius:1,hoverBorderWidth:1,hoverRadius:4,pointStyle:"circle",radius:3,rotation:0};static defaultRoutes={backgroundColor:"backgroundColor",borderColor:"borderColor"};constructor(e){super(),this.options=void 0,this.parsed=void 0,this.skip=void 0,this.stop=void 0,e&&Object.assign(this,e)}inRange(e,t,n){const s=this.options,{x:r,y:i}=this.getProps(["x","y"],n);return Math.pow(e-r,2)+Math.pow(t-i,2)<Math.pow(s.hitRadius+s.radius,2)}inXRange(e,t){return Qr(this,e,"x",t)}inYRange(e,t){return Qr(this,e,"y",t)}getCenterPoint(e){const{x:t,y:n}=this.getProps(["x","y"],e);return{x:t,y:n}}size(e){let t=(e=e||this.options||{}).radius||0;t=Math.max(t,t&&e.hoverRadius||0);return 2*(t+(t&&e.borderWidth||0))}draw(e,t){const n=this.options;this.skip||n.radius<.1||!wt(this,t,this.size(n)/2)||(e.strokeStyle=n.borderColor,e.lineWidth=n.borderWidth,e.fillStyle=n.backgroundColor,yt(e,n,this.x,this.y))}getRange(){const e=this.options||{};return e.radius+e.hitRadius}}});const ii=["rgb(54, 162, 235)","rgb(255, 99, 132)","rgb(255, 159, 64)","rgb(255, 205, 86)","rgb(75, 192, 192)","rgb(153, 102, 255)","rgb(201, 203, 207)"],ai=ii.map((e=>e.replace("rgb(","rgba(").replace(")",", 0.5)")));function oi(e){return ii[e%ii.length]}function li(e){return ai[e%ai.length]}function ui(e){let t=0;return(n,s)=>{const r=e.getDatasetMeta(s).controller;r instanceof is?t=function(e,t){return e.backgroundColor=e.data.map((()=>oi(t++))),t}(n,t):r instanceof os?t=function(e,t){return e.backgroundColor=e.data.map((()=>li(t++))),t}(n,t):r&&(t=function(e,t){return e.borderColor=oi(t),e.backgroundColor=li(t),++t}(n,t))}}function ci(e){let t;for(t in e)if(e[t].borderColor||e[t].backgroundColor)return!0;return!1}var hi={id:"colors",defaults:{enabled:!0,forceOverride:!1},beforeLayout(e,t,n){if(!n.enabled)return;const{data:{datasets:s},options:r}=e.config,{elements:i}=r,a=ci(s)||(o=r)&&(o.borderColor||o.backgroundColor)||i&&ci(i)||"rgba(0,0,0,0.1)"!==ft.borderColor||"rgba(0,0,0,0.1)"!==ft.backgroundColor;var o;if(!n.forceOverride&&a)return;const l=ui(e);s.forEach(l)}};function di(e){if(e._decimated){const t=e._data;delete e._decimated,delete e._data,Object.defineProperty(e,"data",{configurable:!0,enumerable:!0,writable:!0,value:t})}}function pi(e){e.data.datasets.forEach((e=>{di(e)}))}var fi={id:"decimation",defaults:{algorithm:"min-max",enabled:!1},beforeElementsUpdate:(e,t,n)=>{if(!n.enabled)return void pi(e);const s=e.width;e.data.datasets.forEach(((t,r)=>{const{_data:i,indexAxis:a}=t,o=e.getDatasetMeta(r),l=i||t.data;if("y"===Pt([a,e.options.indexAxis]))return;if(!o.controller.supportsDecimation)return;const u=e.scales[o.xAxisID];if("linear"!==u.type&&"time"!==u.type)return;if(e.options.parsing)return;let{start:c,count:h}=function(e,t){const n=t.length;let s,r=0;const{iScale:i}=e,{min:a,max:o,minDefined:l,maxDefined:u}=i.getUserBounds();return l&&(r=Oe(ze(t,i.axis,a).lo,0,n-1)),s=u?Oe(ze(t,i.axis,o).hi+1,r,n)-r:n-r,{start:r,count:s}}(o,l);if(h<=(n.threshold||4*s))return void di(t);let d;switch(j(i)&&(t._data=l,delete t.data,Object.defineProperty(t,"data",{configurable:!0,enumerable:!0,get:function(){return this._decimated},set:function(e){this._data=e}})),n.algorithm){case"lttb":d=function(e,t,n,s,r){const i=r.samples||s;if(i>=n)return e.slice(t,t+n);const a=[],o=(n-2)/(i-2);let l=0;const u=t+n-1;let c,h,d,p,f,g=t;for(a[l++]=e[g],c=0;c<i-2;c++){let s,r=0,i=0;const u=Math.floor((c+1)*o)+1+t,m=Math.min(Math.floor((c+2)*o)+1,n)+t,b=m-u;for(s=u;s<m;s++)r+=e[s].x,i+=e[s].y;r/=b,i/=b;const x=Math.floor(c*o)+1+t,y=Math.min(Math.floor((c+1)*o)+1,n)+t,{x:v,y:w}=e[g];for(d=p=-1,s=x;s<y;s++)p=.5*Math.abs((v-r)*(e[s].y-w)-(v-e[s].x)*(i-w)),p>d&&(d=p,h=e[s],f=s);a[l++]=h,g=f}return a[l++]=e[u],a}(l,c,h,s,n);break;case"min-max":d=function(e,t,n,s){let r,i,a,o,l,u,c,h,d,p,f=0,g=0;const m=[],b=t+n-1,x=e[t].x,y=e[b].x-x;for(r=t;r<t+n;++r){i=e[r],a=(i.x-x)/y*s,o=i.y;const t=0|a;if(t===l)o<d?(d=o,u=r):o>p&&(p=o,c=r),f=(g*f+i.x)/++g;else{const n=r-1;if(!j(u)&&!j(c)){const t=Math.min(u,c),s=Math.max(u,c);t!==h&&t!==n&&m.push({...e[t],x:f}),s!==h&&s!==n&&m.push({...e[s],x:f})}r>0&&n!==h&&m.push(e[n]),m.push(i),l=t,g=0,d=p=o,u=c=h=r}}return m}(l,c,h,s);break;default:throw new Error(`Unsupported decimation algorithm '${n.algorithm}'`)}t._decimated=d}))},destroy(e){pi(e)}};function gi(e,t,n,s){if(s)return;let r=t[e],i=n[e];return"angle"===e&&(r=Fe(r),i=Fe(i)),{property:e,start:r,end:i}}function mi(e,t,n){for(;t>e;t--){const e=n[t];if(!isNaN(e.x)&&!isNaN(e.y))break}return t}function bi(e,t,n,s){return e&&t?s(e[n],t[n]):e?e[n]:t?t[n]:0}function xi(e,t){let n=[],s=!1;return K(e)?(s=!0,n=e):n=function(e,t){const{x:n=null,y:s=null}=e||{},r=t.points,i=[];return t.segments.forEach((e=>{let{start:t,end:a}=e;a=mi(t,a,r);const o=r[t],l=r[a];null!==s?(i.push({x:o.x,y:s}),i.push({x:l.x,y:s})):null!==n&&(i.push({x:n,y:o.y}),i.push({x:n,y:l.y}))})),i}(e,t),n.length?new Yr({points:n,options:{tension:0},_loop:s,_fullLoop:s}):null}function yi(e){return e&&!1!==e.fill}function vi(e,t,n){let s=e[t].fill;const r=[t];let i;if(!n)return s;for(;!1!==s&&-1===r.indexOf(s);){if(!q(s))return s;if(i=e[s],!i)return!1;if(i.visible)return s;r.push(s),s=i.fill}return!1}function wi(e,t,n){const s=function(e){const t=e.options,n=t.fill;let s=Q(n&&n.target,n);void 0===s&&(s=!!t.backgroundColor);if(!1===s||null===s)return!1;if(!0===s)return"origin";return s}(e);if(X(s))return!isNaN(s.value)&&s;let r=parseFloat(s);return q(r)&&Math.floor(r)===r?function(e,t,n,s){"-"!==e&&"+"!==e||(n=t+n);if(n===t||n<0||n>=s)return!1;return n}(s[0],t,r,n):["origin","start","end","stack","shape"].indexOf(s)>=0&&s}function ki(e,t,n){const s=[];for(let r=0;r<n.length;r++){const i=n[r],{first:a,last:o,point:l}=Si(i,t,"x");if(!(!l||a&&o))if(a)s.unshift(l);else if(e.push(l),!o)break}e.push(...s)}function Si(e,t,n){const s=e.interpolate(t,n);if(!s)return{};const r=s[n],i=e.segments,a=e.points;let o=!1,l=!1;for(let u=0;u<i.length;u++){const e=i[u],t=a[e.start][n],s=a[e.end][n];if(Le(r,t,s)){o=r===t,l=r===s;break}}return{first:o,last:l,point:s}}class Ii{constructor(e){this.x=e.x,this.y=e.y,this.radius=e.radius}pathSegment(e,t,n){const{x:s,y:r,radius:i}=this;return t=t||{start:0,end:ge},e.arc(s,r,i,t.end,t.start,!0),!n.bounds}interpolate(e){const{x:t,y:n,radius:s}=this,r=e.angle;return{x:t+Math.cos(r)*s,y:n+Math.sin(r)*s,angle:r}}}function Ci(e){const{chart:t,fill:n,line:s}=e;if(q(n))return function(e,t){const n=e.getDatasetMeta(t),s=n&&e.isDatasetVisible(t);return s?n.dataset:null}(t,n);if("stack"===n)return function(e){const{scale:t,index:n,line:s}=e,r=[],i=s.segments,a=s.points,o=function(e,t){const n=[],s=e.getMatchingVisibleMetas("line");for(let r=0;r<s.length;r++){const e=s[r];if(e.index===t)break;e.hidden||n.unshift(e.dataset)}return n}(t,n);o.push(xi({x:null,y:t.bottom},s));for(let l=0;l<i.length;l++){const e=i[l];for(let t=e.start;t<=e.end;t++)ki(r,a[t],o)}return new Yr({points:r,options:{}})}(e);if("shape"===n)return!0;const r=function(e){const t=e.scale||{};if(t.getPointPositionForValue)return function(e){const{scale:t,fill:n}=e,s=t.options,r=t.getLabels().length,i=s.reverse?t.max:t.min,a=function(e,t,n){let s;return s="start"===e?n:"end"===e?t.options.reverse?t.min:t.max:X(e)?e.value:t.getBaseValue(),s}(n,t,i),o=[];if(s.grid.circular){const e=t.getPointPositionForValue(0,i);return new Ii({x:e.x,y:e.y,radius:t.getDistanceFromCenterForValue(a)})}for(let l=0;l<r;++l)o.push(t.getPointPositionForValue(l,a));return o}(e);return function(e){const{scale:t={},fill:n}=e,s=function(e,t){let n=null;return"start"===e?n=t.bottom:"end"===e?n=t.top:X(e)?n=t.getPixelForValue(e.value):t.getBasePixel&&(n=t.getBasePixel()),n}(n,t);if(q(s)){const e=t.isHorizontal();return{x:e?s:null,y:e?null:s}}return null}(e)}(e);return r instanceof Ii?r:xi(r,s)}function Ni(e,t,n){const s=Ci(t),{line:r,scale:i,axis:a}=t,o=r.options,l=o.fill,u=o.backgroundColor,{above:c=u,below:h=u}=l||{};s&&r.points.length&&(kt(e,n),function(e,t){const{line:n,target:s,above:r,below:i,area:a,scale:o}=t,l=n._loop?"angle":t.axis;e.save(),"x"===l&&i!==r&&(Ti(e,s,a.top),_i(e,{line:n,target:s,color:r,scale:o,property:l}),e.restore(),e.save(),Ti(e,s,a.bottom));_i(e,{line:n,target:s,color:i,scale:o,property:l}),e.restore()}(e,{line:r,target:s,above:c,below:h,area:n,scale:i,axis:a}),St(e))}function Ti(e,t,n){const{segments:s,points:r}=t;let i=!0,a=!1;e.beginPath();for(const o of s){const{start:s,end:l}=o,u=r[s],c=r[mi(s,l,r)];i?(e.moveTo(u.x,u.y),i=!1):(e.lineTo(u.x,n),e.lineTo(u.x,u.y)),a=!!t.pathSegment(e,o,{move:a}),a?e.closePath():e.lineTo(c.x,n)}e.lineTo(t.first().x,n),e.closePath(),e.clip()}function _i(e,t){const{line:n,target:s,property:r,color:i,scale:a}=t,o=function(e,t,n){const s=e.segments,r=e.points,i=t.points,a=[];for(const o of s){let{start:e,end:s}=o;s=mi(e,s,r);const l=gi(n,r[e],r[s],o.loop);if(!t.segments){a.push({source:o,target:l,start:r[e],end:r[s]});continue}const u=En(t,l);for(const t of u){const e=gi(n,i[t.start],i[t.end],t.loop),s=_n(o,r,e);for(const r of s)a.push({source:r,target:t,start:{[n]:bi(l,e,"start",Math.max)},end:{[n]:bi(l,e,"end",Math.min)}})}}return a}(n,s,r);for(const{source:l,target:u,start:c,end:h}of o){const{style:{backgroundColor:t=i}={}}=l,o=!0!==s;e.save(),e.fillStyle=t,Ei(e,a,o&&gi(r,c,h)),e.beginPath();const d=!!n.pathSegment(e,l);let p;if(o){d?e.closePath():$i(e,s,h,r);const t=!!s.pathSegment(e,u,{move:d,reverse:!0});p=d&&t,p||$i(e,s,c,r)}e.closePath(),e.fill(p?"evenodd":"nonzero"),e.restore()}}function Ei(e,t,n){const{top:s,bottom:r}=t.chart.chartArea,{property:i,start:a,end:o}=n||{};"x"===i&&(e.beginPath(),e.rect(a,s,o-a,r-s),e.clip())}function $i(e,t,n,s){const r=t.interpolate(n,s);r&&e.lineTo(r.x,r.y)}var Ri={id:"filler",afterDatasetsUpdate(e,t,n){const s=(e.data.datasets||[]).length,r=[];let i,a,o,l;for(a=0;a<s;++a)i=e.getDatasetMeta(a),o=i.dataset,l=null,o&&o.options&&o instanceof Yr&&(l={visible:e.isDatasetVisible(a),index:a,fill:wi(o,a,s),chart:e,axis:i.controller.options.indexAxis,scale:i.vScale,line:o}),i.$filler=l,r.push(l);for(a=0;a<s;++a)l=r[a],l&&!1!==l.fill&&(l.fill=vi(r,a,n.propagate))},beforeDraw(e,t,n){const s="beforeDraw"===n.drawTime,r=e.getSortedVisibleDatasetMetas(),i=e.chartArea;for(let a=r.length-1;a>=0;--a){const t=r[a].$filler;t&&(t.line.updateControlPoints(i,t.axis),s&&t.fill&&Ni(e.ctx,t,i))}},beforeDatasetsDraw(e,t,n){if("beforeDatasetsDraw"!==n.drawTime)return;const s=e.getSortedVisibleDatasetMetas();for(let r=s.length-1;r>=0;--r){const t=s[r].$filler;yi(t)&&Ni(e.ctx,t,e.chartArea)}},beforeDatasetDraw(e,t,n){const s=t.meta.$filler;yi(s)&&"beforeDatasetDraw"===n.drawTime&&Ni(e.ctx,s,e.chartArea)},defaults:{propagate:!0,drawTime:"beforeDatasetDraw"}};const Ai=(e,t)=>{let{boxHeight:n=t,boxWidth:s=t}=e;return e.usePointStyle&&(n=Math.min(n,t),s=e.pointStyleWidth||Math.min(s,t)),{boxWidth:s,boxHeight:n,itemHeight:Math.max(t,n)}};class Di extends qs{constructor(e){super(),this._added=!1,this.legendHitBoxes=[],this._hoveredItem=null,this.doughnutMode=!1,this.chart=e.chart,this.options=e.options,this.ctx=e.ctx,this.legendItems=void 0,this.columnSizes=void 0,this.lineWidths=void 0,this.maxHeight=void 0,this.maxWidth=void 0,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.height=void 0,this.width=void 0,this._margins=void 0,this.position=void 0,this.weight=void 0,this.fullSize=void 0}update(e,t,n){this.maxWidth=e,this.maxHeight=t,this._margins=n,this.setDimensions(),this.buildLabels(),this.fit()}setDimensions(){this.isHorizontal()?(this.width=this.maxWidth,this.left=this._margins.left,this.right=this.width):(this.height=this.maxHeight,this.top=this._margins.top,this.bottom=this.height)}buildLabels(){const e=this.options.labels||{};let t=J(e.generateLabels,[this.chart],this)||[];e.filter&&(t=t.filter((t=>e.filter(t,this.chart.data)))),e.sort&&(t=t.sort(((t,n)=>e.sort(t,n,this.chart.data)))),this.options.reverse&&t.reverse(),this.legendItems=t}fit(){const{options:e,ctx:t}=this;if(!e.display)return void(this.width=this.height=0);const n=e.labels,s=Lt(n.font),r=s.size,i=this._computeTitleHeight(),{boxWidth:a,itemHeight:o}=Ai(n,r);let l,u;t.font=s.string,this.isHorizontal()?(l=this.maxWidth,u=this._fitRows(i,r,a,o)+10):(u=this.maxHeight,l=this._fitCols(i,s,a,o)+10),this.width=Math.min(l,e.maxWidth||this.maxWidth),this.height=Math.min(u,e.maxHeight||this.maxHeight)}_fitRows(e,t,n,s){const{ctx:r,maxWidth:i,options:{labels:{padding:a}}}=this,o=this.legendHitBoxes=[],l=this.lineWidths=[0],u=s+a;let c=e;r.textAlign="left",r.textBaseline="middle";let h=-1,d=-u;return this.legendItems.forEach(((e,p)=>{const f=n+t/2+r.measureText(e.text).width;(0===p||l[l.length-1]+f+2*a>i)&&(c+=u,l[l.length-(p>0?0:1)]=0,d+=u,h++),o[p]={left:0,top:d,row:h,width:f,height:s},l[l.length-1]+=f+a})),c}_fitCols(e,t,n,s){const{ctx:r,maxHeight:i,options:{labels:{padding:a}}}=this,o=this.legendHitBoxes=[],l=this.columnSizes=[],u=i-e;let c=a,h=0,d=0,p=0,f=0;return this.legendItems.forEach(((e,i)=>{const{itemWidth:g,itemHeight:m}=function(e,t,n,s,r){const i=function(e,t,n,s){let r=e.text;r&&"string"!==typeof r&&(r=r.reduce(((e,t)=>e.length>t.length?e:t)));return t+n.size/2+s.measureText(r).width}(s,e,t,n),a=function(e,t,n){let s=e;"string"!==typeof t.text&&(s=Fi(t,n));return s}(r,s,t.lineHeight);return{itemWidth:i,itemHeight:a}}(n,t,r,e,s);i>0&&d+m+2*a>u&&(c+=h+a,l.push({width:h,height:d}),p+=h+a,f++,h=d=0),o[i]={left:p,top:d,col:f,width:g,height:m},h=Math.max(h,g),d+=m+a})),c+=h,l.push({width:h,height:d}),c}adjustHitBoxes(){if(!this.options.display)return;const e=this._computeTitleHeight(),{legendHitBoxes:t,options:{align:n,labels:{padding:s},rtl:r}}=this,i=Sn(r,this.left,this.width);if(this.isHorizontal()){let r=0,a=Ke(n,this.left+s,this.right-this.lineWidths[r]);for(const o of t)r!==o.row&&(r=o.row,a=Ke(n,this.left+s,this.right-this.lineWidths[r])),o.top+=this.top+e+s,o.left=i.leftForLtr(i.x(a),o.width),a+=o.width+s}else{let r=0,a=Ke(n,this.top+e+s,this.bottom-this.columnSizes[r].height);for(const o of t)o.col!==r&&(r=o.col,a=Ke(n,this.top+e+s,this.bottom-this.columnSizes[r].height)),o.top=a,o.left+=this.left+s,o.left=i.leftForLtr(i.x(o.left),o.width),a+=o.height+s}}isHorizontal(){return"top"===this.options.position||"bottom"===this.options.position}draw(){if(this.options.display){const e=this.ctx;kt(e,this),this._draw(),St(e)}}_draw(){const{options:e,columnSizes:t,lineWidths:n,ctx:s}=this,{align:r,labels:i}=e,a=ft.color,o=Sn(e.rtl,this.left,this.width),l=Lt(i.font),{padding:u}=i,c=l.size,h=c/2;let d;this.drawTitle(),s.textAlign=o.textAlign("left"),s.textBaseline="middle",s.lineWidth=.5,s.font=l.string;const{boxWidth:p,boxHeight:f,itemHeight:g}=Ai(i,c),m=this.isHorizontal(),b=this._computeTitleHeight();d=m?{x:Ke(r,this.left+u,this.right-n[0]),y:this.top+u+b,line:0}:{x:this.left+u,y:Ke(r,this.top+b+u,this.bottom-t[0].height),line:0},In(this.ctx,e.textDirection);const x=g+u;this.legendItems.forEach(((y,v)=>{s.strokeStyle=y.fontColor,s.fillStyle=y.fontColor;const w=s.measureText(y.text).width,k=o.textAlign(y.textAlign||(y.textAlign=i.textAlign)),S=p+h+w;let I=d.x,C=d.y;o.setWidth(this.width),m?v>0&&I+S+u>this.right&&(C=d.y+=x,d.line++,I=d.x=Ke(r,this.left+u,this.right-n[d.line])):v>0&&C+x>this.bottom&&(I=d.x=I+t[d.line].width+u,d.line++,C=d.y=Ke(r,this.top+b+u,this.bottom-t[d.line].height));if(function(e,t,n){if(isNaN(p)||p<=0||isNaN(f)||f<0)return;s.save();const r=Q(n.lineWidth,1);if(s.fillStyle=Q(n.fillStyle,a),s.lineCap=Q(n.lineCap,"butt"),s.lineDashOffset=Q(n.lineDashOffset,0),s.lineJoin=Q(n.lineJoin,"miter"),s.lineWidth=r,s.strokeStyle=Q(n.strokeStyle,a),s.setLineDash(Q(n.lineDash,[])),i.usePointStyle){const a={radius:f*Math.SQRT2/2,pointStyle:n.pointStyle,rotation:n.rotation,borderWidth:r},l=o.xPlus(e,p/2);vt(s,a,l,t+h,i.pointStyleWidth&&p)}else{const i=t+Math.max((c-f)/2,0),a=o.leftForLtr(e,p),l=Mt(n.borderRadius);s.beginPath(),Object.values(l).some((e=>0!==e))?Et(s,{x:a,y:i,w:p,h:f,radius:l}):s.rect(a,i,p,f),s.fill(),0!==r&&s.stroke()}s.restore()}(o.x(I),C,y),I=((e,t,n,s)=>e===(s?"left":"right")?n:"center"===e?(t+n)/2:t)(k,I+p+h,m?I+S:this.right,e.rtl),function(e,t,n){_t(s,n.text,e,t+g/2,l,{strikethrough:n.hidden,textAlign:o.textAlign(n.textAlign)})}(o.x(I),C,y),m)d.x+=S+u;else if("string"!==typeof y.text){const e=l.lineHeight;d.y+=Fi(y,e)+u}else d.y+=x})),Cn(this.ctx,e.textDirection)}drawTitle(){const e=this.options,t=e.title,n=Lt(t.font),s=Ot(t.padding);if(!t.display)return;const r=Sn(e.rtl,this.left,this.width),i=this.ctx,a=t.position,o=n.size/2,l=s.top+o;let u,c=this.left,h=this.width;if(this.isHorizontal())h=Math.max(...this.lineWidths),u=this.top+l,c=Ke(e.align,c,this.right-h);else{const t=this.columnSizes.reduce(((e,t)=>Math.max(e,t.height)),0);u=l+Ke(e.align,this.top,this.bottom-t-e.labels.padding-this._computeTitleHeight())}const d=Ke(a,c,c+h);i.textAlign=r.textAlign(je(a)),i.textBaseline="middle",i.strokeStyle=t.color,i.fillStyle=t.color,i.font=n.string,_t(i,t.text,d,u,n)}_computeTitleHeight(){const e=this.options.title,t=Lt(e.font),n=Ot(e.padding);return e.display?t.lineHeight+n.height:0}_getLegendItemAt(e,t){let n,s,r;if(Le(e,this.left,this.right)&&Le(t,this.top,this.bottom))for(r=this.legendHitBoxes,n=0;n<r.length;++n)if(s=r[n],Le(e,s.left,s.left+s.width)&&Le(t,s.top,s.top+s.height))return this.legendItems[n];return null}handleEvent(e){const t=this.options;if(!function(e,t){if(("mousemove"===e||"mouseout"===e)&&(t.onHover||t.onLeave))return!0;if(t.onClick&&("click"===e||"mouseup"===e))return!0;return!1}(e.type,t))return;const n=this._getLegendItemAt(e.x,e.y);if("mousemove"===e.type||"mouseout"===e.type){const i=this._hoveredItem,a=(r=n,null!==(s=i)&&null!==r&&s.datasetIndex===r.datasetIndex&&s.index===r.index);i&&!a&&J(t.onLeave,[e,i,this],this),this._hoveredItem=n,n&&!a&&J(t.onHover,[e,n,this],this)}else n&&J(t.onClick,[e,n,this],this);var s,r}}function Fi(e,t){return t*(e.text?e.text.length:0)}var Mi={id:"legend",_element:Di,start(e,t,n){const s=e.legend=new Di({ctx:e.ctx,options:n,chart:e});Rs.configure(e,s,n),Rs.addBox(e,s)},stop(e){Rs.removeBox(e,e.legend),delete e.legend},beforeUpdate(e,t,n){const s=e.legend;Rs.configure(e,s,n),s.options=n},afterUpdate(e){const t=e.legend;t.buildLabels(),t.adjustHitBoxes()},afterEvent(e,t){t.replay||e.legend.handleEvent(t.event)},defaults:{display:!0,position:"top",align:"center",fullSize:!0,reverse:!1,weight:1e3,onClick(e,t,n){const s=t.datasetIndex,r=n.chart;r.isDatasetVisible(s)?(r.hide(s),t.hidden=!0):(r.show(s),t.hidden=!1)},onHover:null,onLeave:null,labels:{color:e=>e.chart.options.color,boxWidth:40,padding:10,generateLabels(e){const t=e.data.datasets,{labels:{usePointStyle:n,pointStyle:s,textAlign:r,color:i,useBorderRadius:a,borderRadius:o}}=e.legend.options;return e._getSortedDatasetMetas().map((e=>{const l=e.controller.getStyle(n?0:void 0),u=Ot(l.borderWidth);return{text:t[e.index].label,fillStyle:l.backgroundColor,fontColor:i,hidden:!e.visible,lineCap:l.borderCapStyle,lineDash:l.borderDash,lineDashOffset:l.borderDashOffset,lineJoin:l.borderJoinStyle,lineWidth:(u.width+u.height)/4,strokeStyle:l.borderColor,pointStyle:s||l.pointStyle,rotation:l.rotation,textAlign:r||l.textAlign,borderRadius:a&&(o||l.borderRadius),datasetIndex:e.index}}),this)}},title:{color:e=>e.chart.options.color,display:!1,position:"center",text:""}},descriptors:{_scriptable:e=>!e.startsWith("on"),labels:{_scriptable:e=>!["generateLabels","filter","sort"].includes(e)}}};class Oi extends qs{constructor(e){super(),this.chart=e.chart,this.options=e.options,this.ctx=e.ctx,this._padding=void 0,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.width=void 0,this.height=void 0,this.position=void 0,this.weight=void 0,this.fullSize=void 0}update(e,t){const n=this.options;if(this.left=0,this.top=0,!n.display)return void(this.width=this.height=this.right=this.bottom=0);this.width=this.right=e,this.height=this.bottom=t;const s=K(n.text)?n.text.length:1;this._padding=Ot(n.padding);const r=s*Lt(n.font).lineHeight+this._padding.height;this.isHorizontal()?this.height=r:this.width=r}isHorizontal(){const e=this.options.position;return"top"===e||"bottom"===e}_drawArgs(e){const{top:t,left:n,bottom:s,right:r,options:i}=this,a=i.align;let o,l,u,c=0;return this.isHorizontal()?(l=Ke(a,n,r),u=t+e,o=r-n):("left"===i.position?(l=n+e,u=Ke(a,s,t),c=-.5*fe):(l=r-e,u=Ke(a,t,s),c=.5*fe),o=s-t),{titleX:l,titleY:u,maxWidth:o,rotation:c}}draw(){const e=this.ctx,t=this.options;if(!t.display)return;const n=Lt(t.font),s=n.lineHeight/2+this._padding.top,{titleX:r,titleY:i,maxWidth:a,rotation:o}=this._drawArgs(s);_t(e,t.text,0,0,n,{color:t.color,maxWidth:a,rotation:o,textAlign:je(t.align),textBaseline:"middle",translation:[r,i]})}}var Li={id:"title",_element:Oi,start(e,t,n){!function(e,t){const n=new Oi({ctx:e.ctx,options:t,chart:e});Rs.configure(e,n,t),Rs.addBox(e,n),e.titleBlock=n}(e,n)},stop(e){const t=e.titleBlock;Rs.removeBox(e,t),delete e.titleBlock},beforeUpdate(e,t,n){const s=e.titleBlock;Rs.configure(e,s,n),s.options=n},defaults:{align:"center",display:!1,font:{weight:"bold"},fullSize:!0,padding:10,position:"top",text:"",weight:2e3},defaultRoutes:{color:"color"},descriptors:{_scriptable:!0,_indexable:!1}};const Pi=new WeakMap;var zi={id:"subtitle",start(e,t,n){const s=new Oi({ctx:e.ctx,options:n,chart:e});Rs.configure(e,s,n),Rs.addBox(e,s),Pi.set(e,s)},stop(e){Rs.removeBox(e,Pi.get(e)),Pi.delete(e)},beforeUpdate(e,t,n){const s=Pi.get(e);Rs.configure(e,s,n),s.options=n},defaults:{align:"center",display:!1,font:{weight:"normal"},fullSize:!0,padding:0,position:"top",text:"",weight:1500},defaultRoutes:{color:"color"},descriptors:{_scriptable:!0,_indexable:!1}};const Bi={average(e){if(!e.length)return!1;let t,n,s=new Set,r=0,i=0;for(t=0,n=e.length;t<n;++t){const n=e[t].element;if(n&&n.hasValue()){const e=n.tooltipPosition();s.add(e.x),r+=e.y,++i}}if(0===i||0===s.size)return!1;return{x:[...s].reduce(((e,t)=>e+t))/s.size,y:r/i}},nearest(e,t){if(!e.length)return!1;let n,s,r,i=t.x,a=t.y,o=Number.POSITIVE_INFINITY;for(n=0,s=e.length;n<s;++n){const s=e[n].element;if(s&&s.hasValue()){const e=Ae(t,s.getCenterPoint());e<o&&(o=e,r=s)}}if(r){const e=r.tooltipPosition();i=e.x,a=e.y}return{x:i,y:a}}};function Wi(e,t){return t&&(K(t)?Array.prototype.push.apply(e,t):e.push(t)),e}function Vi(e){return("string"===typeof e||e instanceof String)&&e.indexOf("\n")>-1?e.split("\n"):e}function Ui(e,t){const{element:n,datasetIndex:s,index:r}=t,i=e.getDatasetMeta(s).controller,{label:a,value:o}=i.getLabelAndValue(r);return{chart:e,label:a,parsed:i.getParsed(r),raw:e.data.datasets[s].data[r],formattedValue:o,dataset:i.getDataset(),dataIndex:r,datasetIndex:s,element:n}}function Gi(e,t){const n=e.chart.ctx,{body:s,footer:r,title:i}=e,{boxWidth:a,boxHeight:o}=t,l=Lt(t.bodyFont),u=Lt(t.titleFont),c=Lt(t.footerFont),h=i.length,d=r.length,p=s.length,f=Ot(t.padding);let g=f.height,m=0,b=s.reduce(((e,t)=>e+t.before.length+t.lines.length+t.after.length),0);if(b+=e.beforeBody.length+e.afterBody.length,h&&(g+=h*u.lineHeight+(h-1)*t.titleSpacing+t.titleMarginBottom),b){g+=p*(t.displayColors?Math.max(o,l.lineHeight):l.lineHeight)+(b-p)*l.lineHeight+(b-1)*t.bodySpacing}d&&(g+=t.footerMarginTop+d*c.lineHeight+(d-1)*t.footerSpacing);let x=0;const y=function(e){m=Math.max(m,n.measureText(e).width+x)};return n.save(),n.font=u.string,ee(e.title,y),n.font=l.string,ee(e.beforeBody.concat(e.afterBody),y),x=t.displayColors?a+2+t.boxPadding:0,ee(s,(e=>{ee(e.before,y),ee(e.lines,y),ee(e.after,y)})),x=0,n.font=c.string,ee(e.footer,y),n.restore(),m+=f.width,{width:m,height:g}}function Hi(e,t,n,s){const{x:r,width:i}=n,{width:a,chartArea:{left:o,right:l}}=e;let u="center";return"center"===s?u=r<=(o+l)/2?"left":"right":r<=i/2?u="left":r>=a-i/2&&(u="right"),function(e,t,n,s){const{x:r,width:i}=s,a=n.caretSize+n.caretPadding;return"left"===e&&r+i+a>t.width||"right"===e&&r-i-a<0||void 0}(u,e,t,n)&&(u="center"),u}function ji(e,t,n){const s=n.yAlign||t.yAlign||function(e,t){const{y:n,height:s}=t;return n<s/2?"top":n>e.height-s/2?"bottom":"center"}(e,n);return{xAlign:n.xAlign||t.xAlign||Hi(e,t,n,s),yAlign:s}}function Ki(e,t,n,s){const{caretSize:r,caretPadding:i,cornerRadius:a}=e,{xAlign:o,yAlign:l}=n,u=r+i,{topLeft:c,topRight:h,bottomLeft:d,bottomRight:p}=Mt(a);let f=function(e,t){let{x:n,width:s}=e;return"right"===t?n-=s:"center"===t&&(n-=s/2),n}(t,o);const g=function(e,t,n){let{y:s,height:r}=e;return"top"===t?s+=n:s-="bottom"===t?r+n:r/2,s}(t,l,u);return"center"===l?"left"===o?f+=u:"right"===o&&(f-=u):"left"===o?f-=Math.max(c,d)+r:"right"===o&&(f+=Math.max(h,p)+r),{x:Oe(f,0,s.width-t.width),y:Oe(g,0,s.height-t.height)}}function Xi(e,t,n){const s=Ot(n.padding);return"center"===t?e.x+e.width/2:"right"===t?e.x+e.width-s.right:e.x+s.left}function qi(e){return Wi([],Vi(e))}function Yi(e,t){const n=t&&t.dataset&&t.dataset.tooltip&&t.dataset.tooltip.callbacks;return n?e.override(n):e}const Qi={beforeTitle:G,title(e){if(e.length>0){const t=e[0],n=t.chart.data.labels,s=n?n.length:0;if(this&&this.options&&"dataset"===this.options.mode)return t.dataset.label||"";if(t.label)return t.label;if(s>0&&t.dataIndex<s)return n[t.dataIndex]}return""},afterTitle:G,beforeBody:G,beforeLabel:G,label(e){if(this&&this.options&&"dataset"===this.options.mode)return e.label+": "+e.formattedValue||e.formattedValue;let t=e.dataset.label||"";t&&(t+=": ");const n=e.formattedValue;return j(n)||(t+=n),t},labelColor(e){const t=e.chart.getDatasetMeta(e.datasetIndex).controller.getStyle(e.dataIndex);return{borderColor:t.borderColor,backgroundColor:t.backgroundColor,borderWidth:t.borderWidth,borderDash:t.borderDash,borderDashOffset:t.borderDashOffset,borderRadius:0}},labelTextColor(){return this.options.bodyColor},labelPointStyle(e){const t=e.chart.getDatasetMeta(e.datasetIndex).controller.getStyle(e.dataIndex);return{pointStyle:t.pointStyle,rotation:t.rotation}},afterLabel:G,afterBody:G,beforeFooter:G,footer:G,afterFooter:G};function Zi(e,t,n,s){const r=e[t].call(n,s);return"undefined"===typeof r?Qi[t].call(n,s):r}class Ji extends qs{static positioners=(()=>Bi)();constructor(e){super(),this.opacity=0,this._active=[],this._eventPosition=void 0,this._size=void 0,this._cachedAnimations=void 0,this._tooltipItems=[],this.$animations=void 0,this.$context=void 0,this.chart=e.chart,this.options=e.options,this.dataPoints=void 0,this.title=void 0,this.beforeBody=void 0,this.body=void 0,this.afterBody=void 0,this.footer=void 0,this.xAlign=void 0,this.yAlign=void 0,this.x=void 0,this.y=void 0,this.height=void 0,this.width=void 0,this.caretX=void 0,this.caretY=void 0,this.labelColors=void 0,this.labelPointStyles=void 0,this.labelTextColors=void 0}initialize(e){this.options=e,this._cachedAnimations=void 0,this.$context=void 0}_resolveAnimations(){const e=this._cachedAnimations;if(e)return e;const t=this.chart,n=this.options.setContext(this.getContext()),s=n.enabled&&t.options.animation&&n.animations,r=new Pn(this.chart,s);return s._cacheable&&(this._cachedAnimations=Object.freeze(r)),r}getContext(){return this.$context||(this.$context=(e=this.chart.getContext(),t=this,n=this._tooltipItems,zt(e,{tooltip:t,tooltipItems:n,type:"tooltip"})));var e,t,n}getTitle(e,t){const{callbacks:n}=t,s=Zi(n,"beforeTitle",this,e),r=Zi(n,"title",this,e),i=Zi(n,"afterTitle",this,e);let a=[];return a=Wi(a,Vi(s)),a=Wi(a,Vi(r)),a=Wi(a,Vi(i)),a}getBeforeBody(e,t){return qi(Zi(t.callbacks,"beforeBody",this,e))}getBody(e,t){const{callbacks:n}=t,s=[];return ee(e,(e=>{const t={before:[],lines:[],after:[]},r=Yi(n,e);Wi(t.before,Vi(Zi(r,"beforeLabel",this,e))),Wi(t.lines,Zi(r,"label",this,e)),Wi(t.after,Vi(Zi(r,"afterLabel",this,e))),s.push(t)})),s}getAfterBody(e,t){return qi(Zi(t.callbacks,"afterBody",this,e))}getFooter(e,t){const{callbacks:n}=t,s=Zi(n,"beforeFooter",this,e),r=Zi(n,"footer",this,e),i=Zi(n,"afterFooter",this,e);let a=[];return a=Wi(a,Vi(s)),a=Wi(a,Vi(r)),a=Wi(a,Vi(i)),a}_createItems(e){const t=this._active,n=this.chart.data,s=[],r=[],i=[];let a,o,l=[];for(a=0,o=t.length;a<o;++a)l.push(Ui(this.chart,t[a]));return e.filter&&(l=l.filter(((t,s,r)=>e.filter(t,s,r,n)))),e.itemSort&&(l=l.sort(((t,s)=>e.itemSort(t,s,n)))),ee(l,(t=>{const n=Yi(e.callbacks,t);s.push(Zi(n,"labelColor",this,t)),r.push(Zi(n,"labelPointStyle",this,t)),i.push(Zi(n,"labelTextColor",this,t))})),this.labelColors=s,this.labelPointStyles=r,this.labelTextColors=i,this.dataPoints=l,l}update(e,t){const n=this.options.setContext(this.getContext()),s=this._active;let r,i=[];if(s.length){const e=Bi[n.position].call(this,s,this._eventPosition);i=this._createItems(n),this.title=this.getTitle(i,n),this.beforeBody=this.getBeforeBody(i,n),this.body=this.getBody(i,n),this.afterBody=this.getAfterBody(i,n),this.footer=this.getFooter(i,n);const t=this._size=Gi(this,n),a=Object.assign({},e,t),o=ji(this.chart,n,a),l=Ki(n,a,o,this.chart);this.xAlign=o.xAlign,this.yAlign=o.yAlign,r={opacity:1,x:l.x,y:l.y,width:t.width,height:t.height,caretX:e.x,caretY:e.y}}else 0!==this.opacity&&(r={opacity:0});this._tooltipItems=i,this.$context=void 0,r&&this._resolveAnimations().update(this,r),e&&n.external&&n.external.call(this,{chart:this.chart,tooltip:this,replay:t})}drawCaret(e,t,n,s){const r=this.getCaretPosition(e,n,s);t.lineTo(r.x1,r.y1),t.lineTo(r.x2,r.y2),t.lineTo(r.x3,r.y3)}getCaretPosition(e,t,n){const{xAlign:s,yAlign:r}=this,{caretSize:i,cornerRadius:a}=n,{topLeft:o,topRight:l,bottomLeft:u,bottomRight:c}=Mt(a),{x:h,y:d}=e,{width:p,height:f}=t;let g,m,b,x,y,v;return"center"===r?(y=d+f/2,"left"===s?(g=h,m=g-i,x=y+i,v=y-i):(g=h+p,m=g+i,x=y-i,v=y+i),b=g):(m="left"===s?h+Math.max(o,u)+i:"right"===s?h+p-Math.max(l,c)-i:this.caretX,"top"===r?(x=d,y=x-i,g=m-i,b=m+i):(x=d+f,y=x+i,g=m+i,b=m-i),v=x),{x1:g,x2:m,x3:b,y1:x,y2:y,y3:v}}drawTitle(e,t,n){const s=this.title,r=s.length;let i,a,o;if(r){const l=Sn(n.rtl,this.x,this.width);for(e.x=Xi(this,n.titleAlign,n),t.textAlign=l.textAlign(n.titleAlign),t.textBaseline="middle",i=Lt(n.titleFont),a=n.titleSpacing,t.fillStyle=n.titleColor,t.font=i.string,o=0;o<r;++o)t.fillText(s[o],l.x(e.x),e.y+i.lineHeight/2),e.y+=i.lineHeight+a,o+1===r&&(e.y+=n.titleMarginBottom-a)}}_drawColorBox(e,t,n,s,r){const i=this.labelColors[n],a=this.labelPointStyles[n],{boxHeight:o,boxWidth:l}=r,u=Lt(r.bodyFont),c=Xi(this,"left",r),h=s.x(c),d=o<u.lineHeight?(u.lineHeight-o)/2:0,p=t.y+d;if(r.usePointStyle){const t={radius:Math.min(l,o)/2,pointStyle:a.pointStyle,rotation:a.rotation,borderWidth:1},n=s.leftForLtr(h,l)+l/2,u=p+o/2;e.strokeStyle=r.multiKeyBackground,e.fillStyle=r.multiKeyBackground,yt(e,t,n,u),e.strokeStyle=i.borderColor,e.fillStyle=i.backgroundColor,yt(e,t,n,u)}else{e.lineWidth=X(i.borderWidth)?Math.max(...Object.values(i.borderWidth)):i.borderWidth||1,e.strokeStyle=i.borderColor,e.setLineDash(i.borderDash||[]),e.lineDashOffset=i.borderDashOffset||0;const t=s.leftForLtr(h,l),n=s.leftForLtr(s.xPlus(h,1),l-2),a=Mt(i.borderRadius);Object.values(a).some((e=>0!==e))?(e.beginPath(),e.fillStyle=r.multiKeyBackground,Et(e,{x:t,y:p,w:l,h:o,radius:a}),e.fill(),e.stroke(),e.fillStyle=i.backgroundColor,e.beginPath(),Et(e,{x:n,y:p+1,w:l-2,h:o-2,radius:a}),e.fill()):(e.fillStyle=r.multiKeyBackground,e.fillRect(t,p,l,o),e.strokeRect(t,p,l,o),e.fillStyle=i.backgroundColor,e.fillRect(n,p+1,l-2,o-2))}e.fillStyle=this.labelTextColors[n]}drawBody(e,t,n){const{body:s}=this,{bodySpacing:r,bodyAlign:i,displayColors:a,boxHeight:o,boxWidth:l,boxPadding:u}=n,c=Lt(n.bodyFont);let h=c.lineHeight,d=0;const p=Sn(n.rtl,this.x,this.width),f=function(n){t.fillText(n,p.x(e.x+d),e.y+h/2),e.y+=h+r},g=p.textAlign(i);let m,b,x,y,v,w,k;for(t.textAlign=i,t.textBaseline="middle",t.font=c.string,e.x=Xi(this,g,n),t.fillStyle=n.bodyColor,ee(this.beforeBody,f),d=a&&"right"!==g?"center"===i?l/2+u:l+2+u:0,y=0,w=s.length;y<w;++y){for(m=s[y],b=this.labelTextColors[y],t.fillStyle=b,ee(m.before,f),x=m.lines,a&&x.length&&(this._drawColorBox(t,e,y,p,n),h=Math.max(c.lineHeight,o)),v=0,k=x.length;v<k;++v)f(x[v]),h=c.lineHeight;ee(m.after,f)}d=0,h=c.lineHeight,ee(this.afterBody,f),e.y-=r}drawFooter(e,t,n){const s=this.footer,r=s.length;let i,a;if(r){const o=Sn(n.rtl,this.x,this.width);for(e.x=Xi(this,n.footerAlign,n),e.y+=n.footerMarginTop,t.textAlign=o.textAlign(n.footerAlign),t.textBaseline="middle",i=Lt(n.footerFont),t.fillStyle=n.footerColor,t.font=i.string,a=0;a<r;++a)t.fillText(s[a],o.x(e.x),e.y+i.lineHeight/2),e.y+=i.lineHeight+n.footerSpacing}}drawBackground(e,t,n,s){const{xAlign:r,yAlign:i}=this,{x:a,y:o}=e,{width:l,height:u}=n,{topLeft:c,topRight:h,bottomLeft:d,bottomRight:p}=Mt(s.cornerRadius);t.fillStyle=s.backgroundColor,t.strokeStyle=s.borderColor,t.lineWidth=s.borderWidth,t.beginPath(),t.moveTo(a+c,o),"top"===i&&this.drawCaret(e,t,n,s),t.lineTo(a+l-h,o),t.quadraticCurveTo(a+l,o,a+l,o+h),"center"===i&&"right"===r&&this.drawCaret(e,t,n,s),t.lineTo(a+l,o+u-p),t.quadraticCurveTo(a+l,o+u,a+l-p,o+u),"bottom"===i&&this.drawCaret(e,t,n,s),t.lineTo(a+d,o+u),t.quadraticCurveTo(a,o+u,a,o+u-d),"center"===i&&"left"===r&&this.drawCaret(e,t,n,s),t.lineTo(a,o+c),t.quadraticCurveTo(a,o,a+c,o),t.closePath(),t.fill(),s.borderWidth>0&&t.stroke()}_updateAnimationTarget(e){const t=this.chart,n=this.$animations,s=n&&n.x,r=n&&n.y;if(s||r){const n=Bi[e.position].call(this,this._active,this._eventPosition);if(!n)return;const i=this._size=Gi(this,e),a=Object.assign({},n,this._size),o=ji(t,e,a),l=Ki(e,a,o,t);s._to===l.x&&r._to===l.y||(this.xAlign=o.xAlign,this.yAlign=o.yAlign,this.width=i.width,this.height=i.height,this.caretX=n.x,this.caretY=n.y,this._resolveAnimations().update(this,l))}}_willRender(){return!!this.opacity}draw(e){const t=this.options.setContext(this.getContext());let n=this.opacity;if(!n)return;this._updateAnimationTarget(t);const s={width:this.width,height:this.height},r={x:this.x,y:this.y};n=Math.abs(n)<.001?0:n;const i=Ot(t.padding),a=this.title.length||this.beforeBody.length||this.body.length||this.afterBody.length||this.footer.length;t.enabled&&a&&(e.save(),e.globalAlpha=n,this.drawBackground(r,e,s,t),In(e,t.textDirection),r.y+=i.top,this.drawTitle(r,e,t),this.drawBody(r,e,t),this.drawFooter(r,e,t),Cn(e,t.textDirection),e.restore())}getActiveElements(){return this._active||[]}setActiveElements(e,t){const n=this._active,s=e.map((e=>{let{datasetIndex:t,index:n}=e;const s=this.chart.getDatasetMeta(t);if(!s)throw new Error("Cannot find a dataset at index "+t);return{datasetIndex:t,element:s.data[n],index:n}})),r=!te(n,s),i=this._positionChanged(s,t);(r||i)&&(this._active=s,this._eventPosition=t,this._ignoreReplayEvents=!0,this.update(!0))}handleEvent(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(t&&this._ignoreReplayEvents)return!1;this._ignoreReplayEvents=!1;const s=this.options,r=this._active||[],i=this._getActiveElements(e,r,t,n),a=this._positionChanged(i,e),o=t||!te(i,r)||a;return o&&(this._active=i,(s.enabled||s.external)&&(this._eventPosition={x:e.x,y:e.y},this.update(!0,t))),o}_getActiveElements(e,t,n,s){const r=this.options;if("mouseout"===e.type)return[];if(!s)return t.filter((e=>this.chart.data.datasets[e.datasetIndex]&&void 0!==this.chart.getDatasetMeta(e.datasetIndex).controller.getParsed(e.index)));const i=this.chart.getElementsAtEventForMode(e,r.mode,r,n);return r.reverse&&i.reverse(),i}_positionChanged(e,t){const{caretX:n,caretY:s,options:r}=this,i=Bi[r.position].call(this,e,t);return!1!==i&&(n!==i.x||s!==i.y)}}var ea={id:"tooltip",_element:Ji,positioners:Bi,afterInit(e,t,n){n&&(e.tooltip=new Ji({chart:e,options:n}))},beforeUpdate(e,t,n){e.tooltip&&e.tooltip.initialize(n)},reset(e,t,n){e.tooltip&&e.tooltip.initialize(n)},afterDraw(e){const t=e.tooltip;if(t&&t._willRender()){const n={tooltip:t};if(!1===e.notifyPlugins("beforeTooltipDraw",{...n,cancelable:!0}))return;t.draw(e.ctx),e.notifyPlugins("afterTooltipDraw",n)}},afterEvent(e,t){if(e.tooltip){const n=t.replay;e.tooltip.handleEvent(t.event,n,t.inChartArea)&&(t.changed=!0)}},defaults:{enabled:!0,external:null,position:"average",backgroundColor:"rgba(0,0,0,0.8)",titleColor:"#fff",titleFont:{weight:"bold"},titleSpacing:2,titleMarginBottom:6,titleAlign:"left",bodyColor:"#fff",bodySpacing:2,bodyFont:{},bodyAlign:"left",footerColor:"#fff",footerSpacing:2,footerMarginTop:6,footerFont:{weight:"bold"},footerAlign:"left",padding:6,caretPadding:2,caretSize:5,cornerRadius:6,boxHeight:(e,t)=>t.bodyFont.size,boxWidth:(e,t)=>t.bodyFont.size,multiKeyBackground:"#fff",displayColors:!0,boxPadding:0,borderColor:"rgba(0,0,0,0)",borderWidth:0,animation:{duration:400,easing:"easeOutQuart"},animations:{numbers:{type:"number",properties:["x","y","width","height","caretX","caretY"]},opacity:{easing:"linear",duration:200}},callbacks:Qi},defaultRoutes:{bodyFont:"font",footerFont:"font",titleFont:"font"},descriptors:{_scriptable:e=>"filter"!==e&&"itemSort"!==e&&"external"!==e,_indexable:!1,callbacks:{_scriptable:!1,_indexable:!1},animation:{_fallback:!1},animations:{_fallback:"animation"}},additionalOptionScopes:["interaction"]},ta=Object.freeze({__proto__:null,Colors:hi,Decimation:fi,Filler:Ri,Legend:Mi,SubTitle:zi,Title:Li,Tooltip:ea});function na(e,t,n,s){const r=e.indexOf(t);if(-1===r)return((e,t,n,s)=>("string"===typeof t?(n=e.push(t)-1,s.unshift({index:n,label:t})):isNaN(t)&&(n=null),n))(e,t,n,s);return r!==e.lastIndexOf(t)?n:r}function sa(e){const t=this.getLabels();return e>=0&&e<t.length?t[e]:e}class ra extends ir{static id="category";static defaults=(()=>({ticks:{callback:sa}}))();constructor(e){super(e),this._startValue=void 0,this._valueRange=0,this._addedLabels=[]}init(e){const t=this._addedLabels;if(t.length){const e=this.getLabels();for(const{index:n,label:s}of t)e[n]===s&&e.splice(n,1);this._addedLabels=[]}super.init(e)}parse(e,t){if(j(e))return null;const n=this.getLabels();return((e,t)=>null===e?null:Oe(Math.round(e),0,t))(t=isFinite(t)&&n[t]===e?t:na(n,e,Q(t,e),this._addedLabels),n.length-1)}determineDataLimits(){const{minDefined:e,maxDefined:t}=this.getUserBounds();let{min:n,max:s}=this.getMinMax(!0);"ticks"===this.options.bounds&&(e||(n=0),t||(s=this.getLabels().length-1)),this.min=n,this.max=s}buildTicks(){const e=this.min,t=this.max,n=this.options.offset,s=[];let r=this.getLabels();r=0===e&&t===r.length-1?r:r.slice(e,t+1),this._valueRange=Math.max(r.length-(n?0:1),1),this._startValue=this.min-(n?.5:0);for(let i=e;i<=t;i++)s.push({value:i});return s}getLabelForValue(e){return sa.call(this,e)}configure(){super.configure(),this.isHorizontal()||(this._reversePixels=!this._reversePixels)}getPixelForValue(e){return"number"!==typeof e&&(e=this.parse(e)),null===e?NaN:this.getPixelForDecimal((e-this._startValue)/this._valueRange)}getPixelForTick(e){const t=this.ticks;return e<0||e>t.length-1?null:this.getPixelForValue(t[e].value)}getValueForPixel(e){return Math.round(this._startValue+this.getDecimalForPixel(e)*this._valueRange)}getBasePixel(){return this.bottom}}function ia(e,t){const n=[],{bounds:s,step:r,min:i,max:a,precision:o,count:l,maxTicks:u,maxDigits:c,includeBounds:h}=e,d=r||1,p=u-1,{min:f,max:g}=t,m=!j(i),b=!j(a),x=!j(l),y=(g-f)/(c+1);let v,w,k,S,I=Ce((g-f)/p/d)*d;if(I<1e-14&&!m&&!b)return[{value:f},{value:g}];S=Math.ceil(g/I)-Math.floor(f/I),S>p&&(I=Ce(S*I/p/d)*d),j(o)||(v=Math.pow(10,o),I=Math.ceil(I*v)/v),"ticks"===s?(w=Math.floor(f/I)*I,k=Math.ceil(g/I)*I):(w=f,k=g),m&&b&&r&&function(e,t){const n=Math.round(e);return n-t<=e&&n+t>=e}((a-i)/r,I/1e3)?(S=Math.round(Math.min((a-i)/I,u)),I=(a-i)/S,w=i,k=a):x?(w=m?i:w,k=b?a:k,S=l-1,I=(k-w)/S):(S=(k-w)/I,S=Ie(S,Math.round(S),I/1e3)?Math.round(S):Math.ceil(S));const C=Math.max($e(I),$e(w));v=Math.pow(10,j(o)?C:o),w=Math.round(w*v)/v,k=Math.round(k*v)/v;let N=0;for(m&&(h&&w!==i?(n.push({value:i}),w<i&&N++,Ie(Math.round((w+N*I)*v)/v,i,aa(i,y,e))&&N++):w<i&&N++);N<S;++N){const e=Math.round((w+N*I)*v)/v;if(b&&e>a)break;n.push({value:e})}return b&&h&&k!==a?n.length&&Ie(n[n.length-1].value,a,aa(a,y,e))?n[n.length-1].value=a:n.push({value:a}):b&&k!==a||n.push({value:k}),n}function aa(e,t,n){let{horizontal:s,minRotation:r}=n;const i=_e(r),a=(s?Math.sin(i):Math.cos(i))||.001,o=.75*t*(""+e).length;return Math.min(t/a,o)}class oa extends ir{constructor(e){super(e),this.start=void 0,this.end=void 0,this._startValue=void 0,this._endValue=void 0,this._valueRange=0}parse(e,t){return j(e)||("number"===typeof e||e instanceof Number)&&!isFinite(+e)?null:+e}handleTickRangeOptions(){const{beginAtZero:e}=this.options,{minDefined:t,maxDefined:n}=this.getUserBounds();let{min:s,max:r}=this;const i=e=>s=t?s:e,a=e=>r=n?r:e;if(e){const e=Se(s),t=Se(r);e<0&&t<0?a(0):e>0&&t>0&&i(0)}if(s===r){let t=0===r?1:Math.abs(.05*r);a(r+t),e||i(s-t)}this.min=s,this.max=r}getTickLimit(){const e=this.options.ticks;let t,{maxTicksLimit:n,stepSize:s}=e;return s?(t=Math.ceil(this.max/s)-Math.floor(this.min/s)+1,t>1e3&&(console.warn(`scales.${this.id}.ticks.stepSize: ${s} would result generating up to ${t} ticks. Limiting to 1000.`),t=1e3)):(t=this.computeTickLimit(),n=n||11),n&&(t=Math.min(n,t)),t}computeTickLimit(){return Number.POSITIVE_INFINITY}buildTicks(){const e=this.options,t=e.ticks;let n=this.getTickLimit();n=Math.max(2,n);const s=ia({maxTicks:n,bounds:e.bounds,min:e.min,max:e.max,precision:t.precision,step:t.stepSize,count:t.count,maxDigits:this._maxDigits(),horizontal:this.isHorizontal(),minRotation:t.minRotation||0,includeBounds:!1!==t.includeBounds},this._range||this);return"ticks"===e.bounds&&Te(s,this,"value"),e.reverse?(s.reverse(),this.start=this.max,this.end=this.min):(this.start=this.min,this.end=this.max),s}configure(){const e=this.ticks;let t=this.min,n=this.max;if(super.configure(),this.options.offset&&e.length){const s=(n-t)/Math.max(e.length-1,1)/2;t-=s,n+=s}this._startValue=t,this._endValue=n,this._valueRange=n-t}getLabelForValue(e){return at(e,this.chart.options.locale,this.options.ticks.format)}}class la extends oa{static id="linear";static defaults=(()=>({ticks:{callback:lt.formatters.numeric}}))();determineDataLimits(){const{min:e,max:t}=this.getMinMax(!0);this.min=q(e)?e:0,this.max=q(t)?t:1,this.handleTickRangeOptions()}computeTickLimit(){const e=this.isHorizontal(),t=e?this.width:this.height,n=_e(this.options.ticks.minRotation),s=(e?Math.sin(n):Math.cos(n))||.001,r=this._resolveTickFontOptions(0);return Math.ceil(t/Math.min(40,r.lineHeight/s))}getPixelForValue(e){return null===e?NaN:this.getPixelForDecimal((e-this._startValue)/this._valueRange)}getValueForPixel(e){return this._startValue+this.getDecimalForPixel(e)*this._valueRange}}const ua=e=>Math.floor(ke(e)),ca=(e,t)=>Math.pow(10,ua(e)+t);function ha(e){return 1===e/Math.pow(10,ua(e))}function da(e,t,n){const s=Math.pow(10,n),r=Math.floor(e/s);return Math.ceil(t/s)-r}function pa(e,t){let{min:n,max:s}=t;n=Y(e.min,n);const r=[],i=ua(n);let a=function(e,t){let n=ua(t-e);for(;da(e,t,n)>10;)n++;for(;da(e,t,n)<10;)n--;return Math.min(n,ua(e))}(n,s),o=a<0?Math.pow(10,Math.abs(a)):1;const l=Math.pow(10,a),u=i>a?Math.pow(10,i):0,c=Math.round((n-u)*o)/o,h=Math.floor((n-u)/l/10)*l*10;let d=Math.floor((c-h)/Math.pow(10,a)),p=Y(e.min,Math.round((u+h+d*Math.pow(10,a))*o)/o);for(;p<s;)r.push({value:p,major:ha(p),significand:d}),d>=10?d=d<15?15:20:d++,d>=20&&(a++,d=2,o=a>=0?1:o),p=Math.round((u+h+d*Math.pow(10,a))*o)/o;const f=Y(e.max,p);return r.push({value:f,major:ha(f),significand:d}),r}class fa extends ir{static id="logarithmic";static defaults=(()=>({ticks:{callback:lt.formatters.logarithmic,major:{enabled:!0}}}))();constructor(e){super(e),this.start=void 0,this.end=void 0,this._startValue=void 0,this._valueRange=0}parse(e,t){const n=oa.prototype.parse.apply(this,[e,t]);if(0!==n)return q(n)&&n>0?n:null;this._zero=!0}determineDataLimits(){const{min:e,max:t}=this.getMinMax(!0);this.min=q(e)?Math.max(0,e):null,this.max=q(t)?Math.max(0,t):null,this.options.beginAtZero&&(this._zero=!0),this._zero&&this.min!==this._suggestedMin&&!q(this._userMin)&&(this.min=e===ca(this.min,0)?ca(this.min,-1):ca(this.min,0)),this.handleTickRangeOptions()}handleTickRangeOptions(){const{minDefined:e,maxDefined:t}=this.getUserBounds();let n=this.min,s=this.max;const r=t=>n=e?n:t,i=e=>s=t?s:e;n===s&&(n<=0?(r(1),i(10)):(r(ca(n,-1)),i(ca(s,1)))),n<=0&&r(ca(s,-1)),s<=0&&i(ca(n,1)),this.min=n,this.max=s}buildTicks(){const e=this.options,t=pa({min:this._userMin,max:this._userMax},this);return"ticks"===e.bounds&&Te(t,this,"value"),e.reverse?(t.reverse(),this.start=this.max,this.end=this.min):(this.start=this.min,this.end=this.max),t}getLabelForValue(e){return void 0===e?"0":at(e,this.chart.options.locale,this.options.ticks.format)}configure(){const e=this.min;super.configure(),this._startValue=ke(e),this._valueRange=ke(this.max)-ke(e)}getPixelForValue(e){return void 0!==e&&0!==e||(e=this.min),null===e||isNaN(e)?NaN:this.getPixelForDecimal(e===this.min?0:(ke(e)-this._startValue)/this._valueRange)}getValueForPixel(e){const t=this.getDecimalForPixel(e);return Math.pow(10,this._startValue+t*this._valueRange)}}function ga(e){const t=e.ticks;if(t.display&&e.display){const e=Ot(t.backdropPadding);return Q(t.font&&t.font.size,ft.font.size)+e.height}return 0}function ma(e,t,n,s,r){return e===s||e===r?{start:t-n/2,end:t+n/2}:e<s||e>r?{start:t-n,end:t}:{start:t,end:t+n}}function ba(e){const t={l:e.left+e._padding.left,r:e.right-e._padding.right,t:e.top+e._padding.top,b:e.bottom-e._padding.bottom},n=Object.assign({},t),s=[],r=[],i=e._pointLabels.length,a=e.options.pointLabels,o=a.centerPointLabels?fe/i:0;for(let h=0;h<i;h++){const i=a.setContext(e.getPointLabelContext(h));r[h]=i.padding;const d=e.getPointPosition(h,e.drawingArea+r[h],o),p=Lt(i.font),f=(l=e.ctx,u=p,c=K(c=e._pointLabels[h])?c:[c],{w:mt(l,u.string,c),h:c.length*u.lineHeight});s[h]=f;const g=Fe(e.getIndexAngle(h)+o),m=Math.round(Ee(g));xa(n,t,g,ma(m,d.x,f.w,0,180),ma(m,d.y,f.h,90,270))}var l,u,c;e.setCenterPoint(t.l-n.l,n.r-t.r,t.t-n.t,n.b-t.b),e._pointLabelItems=function(e,t,n){const s=[],r=e._pointLabels.length,i=e.options,{centerPointLabels:a,display:o}=i.pointLabels,l={extra:ga(i)/2,additionalAngle:a?fe/r:0};let u;for(let c=0;c<r;c++){l.padding=n[c],l.size=t[c];const r=ya(e,c,l);s.push(r),"auto"===o&&(r.visible=va(r,u),r.visible&&(u=r))}return s}(e,s,r)}function xa(e,t,n,s,r){const i=Math.abs(Math.sin(n)),a=Math.abs(Math.cos(n));let o=0,l=0;s.start<t.l?(o=(t.l-s.start)/i,e.l=Math.min(e.l,t.l-o)):s.end>t.r&&(o=(s.end-t.r)/i,e.r=Math.max(e.r,t.r+o)),r.start<t.t?(l=(t.t-r.start)/a,e.t=Math.min(e.t,t.t-l)):r.end>t.b&&(l=(r.end-t.b)/a,e.b=Math.max(e.b,t.b+l))}function ya(e,t,n){const s=e.drawingArea,{extra:r,additionalAngle:i,padding:a,size:o}=n,l=e.getPointPosition(t,s+r+a,i),u=Math.round(Ee(Fe(l.angle+ye))),c=function(e,t,n){90===n||270===n?e-=t/2:(n>270||n<90)&&(e-=t);return e}(l.y,o.h,u),h=function(e){if(0===e||180===e)return"center";if(e<180)return"left";return"right"}(u),d=function(e,t,n){"right"===n?e-=t:"center"===n&&(e-=t/2);return e}(l.x,o.w,h);return{visible:!0,x:l.x,y:c,textAlign:h,left:d,top:c,right:d+o.w,bottom:c+o.h}}function va(e,t){if(!t)return!0;const{left:n,top:s,right:r,bottom:i}=e;return!(wt({x:n,y:s},t)||wt({x:n,y:i},t)||wt({x:r,y:s},t)||wt({x:r,y:i},t))}function wa(e,t,n){const{left:s,top:r,right:i,bottom:a}=n,{backdropColor:o}=t;if(!j(o)){const n=Mt(t.borderRadius),l=Ot(t.backdropPadding);e.fillStyle=o;const u=s-l.left,c=r-l.top,h=i-s+l.width,d=a-r+l.height;Object.values(n).some((e=>0!==e))?(e.beginPath(),Et(e,{x:u,y:c,w:h,h:d,radius:n}),e.fill()):e.fillRect(u,c,h,d)}}function ka(e,t,n,s){const{ctx:r}=e;if(n)r.arc(e.xCenter,e.yCenter,t,0,ge);else{let n=e.getPointPosition(0,t);r.moveTo(n.x,n.y);for(let i=1;i<s;i++)n=e.getPointPosition(i,t),r.lineTo(n.x,n.y)}}class Sa extends oa{static id="radialLinear";static defaults=(()=>({display:!0,animate:!0,position:"chartArea",angleLines:{display:!0,lineWidth:1,borderDash:[],borderDashOffset:0},grid:{circular:!1},startAngle:0,ticks:{showLabelBackdrop:!0,callback:lt.formatters.numeric},pointLabels:{backdropColor:void 0,backdropPadding:2,display:!0,font:{size:10},callback:e=>e,padding:5,centerPointLabels:!1}}))();static defaultRoutes={"angleLines.color":"borderColor","pointLabels.color":"color","ticks.color":"color"};static descriptors={angleLines:{_fallback:"grid"}};constructor(e){super(e),this.xCenter=void 0,this.yCenter=void 0,this.drawingArea=void 0,this._pointLabels=[],this._pointLabelItems=[]}setDimensions(){const e=this._padding=Ot(ga(this.options)/2),t=this.width=this.maxWidth-e.width,n=this.height=this.maxHeight-e.height;this.xCenter=Math.floor(this.left+t/2+e.left),this.yCenter=Math.floor(this.top+n/2+e.top),this.drawingArea=Math.floor(Math.min(t,n)/2)}determineDataLimits(){const{min:e,max:t}=this.getMinMax(!1);this.min=q(e)&&!isNaN(e)?e:0,this.max=q(t)&&!isNaN(t)?t:0,this.handleTickRangeOptions()}computeTickLimit(){return Math.ceil(this.drawingArea/ga(this.options))}generateTickLabels(e){oa.prototype.generateTickLabels.call(this,e),this._pointLabels=this.getLabels().map(((e,t)=>{const n=J(this.options.pointLabels.callback,[e,t],this);return n||0===n?n:""})).filter(((e,t)=>this.chart.getDataVisibility(t)))}fit(){const e=this.options;e.display&&e.pointLabels.display?ba(this):this.setCenterPoint(0,0,0,0)}setCenterPoint(e,t,n,s){this.xCenter+=Math.floor((e-t)/2),this.yCenter+=Math.floor((n-s)/2),this.drawingArea-=Math.min(this.drawingArea/2,Math.max(e,t,n,s))}getIndexAngle(e){return Fe(e*(ge/(this._pointLabels.length||1))+_e(this.options.startAngle||0))}getDistanceFromCenterForValue(e){if(j(e))return NaN;const t=this.drawingArea/(this.max-this.min);return this.options.reverse?(this.max-e)*t:(e-this.min)*t}getValueForDistanceFromCenter(e){if(j(e))return NaN;const t=e/(this.drawingArea/(this.max-this.min));return this.options.reverse?this.max-t:this.min+t}getPointLabelContext(e){const t=this._pointLabels||[];if(e>=0&&e<t.length){const n=t[e];return function(e,t,n){return zt(e,{label:n,index:t,type:"pointLabel"})}(this.getContext(),e,n)}}getPointPosition(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const s=this.getIndexAngle(e)-ye+n;return{x:Math.cos(s)*t+this.xCenter,y:Math.sin(s)*t+this.yCenter,angle:s}}getPointPositionForValue(e,t){return this.getPointPosition(e,this.getDistanceFromCenterForValue(t))}getBasePosition(e){return this.getPointPositionForValue(e||0,this.getBaseValue())}getPointLabelPosition(e){const{left:t,top:n,right:s,bottom:r}=this._pointLabelItems[e];return{left:t,top:n,right:s,bottom:r}}drawBackground(){const{backgroundColor:e,grid:{circular:t}}=this.options;if(e){const n=this.ctx;n.save(),n.beginPath(),ka(this,this.getDistanceFromCenterForValue(this._endValue),t,this._pointLabels.length),n.closePath(),n.fillStyle=e,n.fill(),n.restore()}}drawGrid(){const e=this.ctx,t=this.options,{angleLines:n,grid:s,border:r}=t,i=this._pointLabels.length;let a,o,l;if(t.pointLabels.display&&function(e,t){const{ctx:n,options:{pointLabels:s}}=e;for(let r=t-1;r>=0;r--){const t=e._pointLabelItems[r];if(!t.visible)continue;const i=s.setContext(e.getPointLabelContext(r));wa(n,i,t);const a=Lt(i.font),{x:o,y:l,textAlign:u}=t;_t(n,e._pointLabels[r],o,l+a.lineHeight/2,a,{color:i.color,textAlign:u,textBaseline:"middle"})}}(this,i),s.display&&this.ticks.forEach(((e,t)=>{if(0!==t||0===t&&this.min<0){o=this.getDistanceFromCenterForValue(e.value);const n=this.getContext(t),a=s.setContext(n),l=r.setContext(n);!function(e,t,n,s,r){const i=e.ctx,a=t.circular,{color:o,lineWidth:l}=t;!a&&!s||!o||!l||n<0||(i.save(),i.strokeStyle=o,i.lineWidth=l,i.setLineDash(r.dash||[]),i.lineDashOffset=r.dashOffset,i.beginPath(),ka(e,n,a,s),i.closePath(),i.stroke(),i.restore())}(this,a,o,i,l)}})),n.display){for(e.save(),a=i-1;a>=0;a--){const s=n.setContext(this.getPointLabelContext(a)),{color:r,lineWidth:i}=s;i&&r&&(e.lineWidth=i,e.strokeStyle=r,e.setLineDash(s.borderDash),e.lineDashOffset=s.borderDashOffset,o=this.getDistanceFromCenterForValue(t.reverse?this.min:this.max),l=this.getPointPosition(a,o),e.beginPath(),e.moveTo(this.xCenter,this.yCenter),e.lineTo(l.x,l.y),e.stroke())}e.restore()}}drawBorder(){}drawLabels(){const e=this.ctx,t=this.options,n=t.ticks;if(!n.display)return;const s=this.getIndexAngle(0);let r,i;e.save(),e.translate(this.xCenter,this.yCenter),e.rotate(s),e.textAlign="center",e.textBaseline="middle",this.ticks.forEach(((s,a)=>{if(0===a&&this.min>=0&&!t.reverse)return;const o=n.setContext(this.getContext(a)),l=Lt(o.font);if(r=this.getDistanceFromCenterForValue(this.ticks[a].value),o.showLabelBackdrop){e.font=l.string,i=e.measureText(s.label).width,e.fillStyle=o.backdropColor;const t=Ot(o.backdropPadding);e.fillRect(-i/2-t.left,-r-l.size/2-t.top,i+t.width,l.size+t.height)}_t(e,s.label,0,-r,l,{color:o.color,strokeColor:o.textStrokeColor,strokeWidth:o.textStrokeWidth})})),e.restore()}drawTitle(){}}const Ia={millisecond:{common:!0,size:1,steps:1e3},second:{common:!0,size:1e3,steps:60},minute:{common:!0,size:6e4,steps:60},hour:{common:!0,size:36e5,steps:24},day:{common:!0,size:864e5,steps:30},week:{common:!1,size:6048e5,steps:4},month:{common:!0,size:2628e6,steps:12},quarter:{common:!1,size:7884e6,steps:4},year:{common:!0,size:3154e7}},Ca=Object.keys(Ia);function Na(e,t){return e-t}function Ta(e,t){if(j(t))return null;const n=e._adapter,{parser:s,round:r,isoWeekday:i}=e._parseOpts;let a=t;return"function"===typeof s&&(a=s(a)),q(a)||(a="string"===typeof s?n.parse(a,s):n.parse(a)),null===a?null:(r&&(a="week"!==r||!Ne(i)&&!0!==i?n.startOf(a,r):n.startOf(a,"isoWeek",i)),+a)}function _a(e,t,n,s){const r=Ca.length;for(let i=Ca.indexOf(e);i<r-1;++i){const e=Ia[Ca[i]],r=e.steps?e.steps:Number.MAX_SAFE_INTEGER;if(e.common&&Math.ceil((n-t)/(r*e.size))<=s)return Ca[i]}return Ca[r-1]}function Ea(e,t,n){if(n){if(n.length){const{lo:s,hi:r}=Pe(n,t);e[n[s]>=t?n[s]:n[r]]=!0}}else e[t]=!0}function $a(e,t,n){const s=[],r={},i=t.length;let a,o;for(a=0;a<i;++a)o=t[a],r[o]=a,s.push({value:o,major:!1});return 0!==i&&n?function(e,t,n,s){const r=e._adapter,i=+r.startOf(t[0].value,s),a=t[t.length-1].value;let o,l;for(o=i;o<=a;o=+r.add(o,1,s))l=n[o],l>=0&&(t[l].major=!0);return t}(e,s,r,n):s}class Ra extends ir{static id="time";static defaults={bounds:"data",adapters:{},time:{parser:!1,unit:!1,round:!1,isoWeekday:!1,minUnit:"millisecond",displayFormats:{}},ticks:{source:"auto",callback:!1,major:{enabled:!1}}};constructor(e){super(e),this._cache={data:[],labels:[],all:[]},this._unit="day",this._majorUnit=void 0,this._offsets={},this._normalized=!1,this._parseOpts=void 0}init(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=e.time||(e.time={}),s=this._adapter=new hs(e.adapters.date);s.init(t),ae(n.displayFormats,s.formats()),this._parseOpts={parser:n.parser,round:n.round,isoWeekday:n.isoWeekday},super.init(e),this._normalized=t.normalized}parse(e,t){return void 0===e?null:Ta(this,e)}beforeLayout(){super.beforeLayout(),this._cache={data:[],labels:[],all:[]}}determineDataLimits(){const e=this.options,t=this._adapter,n=e.time.unit||"day";let{min:s,max:r,minDefined:i,maxDefined:a}=this.getUserBounds();function o(e){i||isNaN(e.min)||(s=Math.min(s,e.min)),a||isNaN(e.max)||(r=Math.max(r,e.max))}i&&a||(o(this._getLabelBounds()),"ticks"===e.bounds&&"labels"===e.ticks.source||o(this.getMinMax(!1))),s=q(s)&&!isNaN(s)?s:+t.startOf(Date.now(),n),r=q(r)&&!isNaN(r)?r:+t.endOf(Date.now(),n)+1,this.min=Math.min(s,r-1),this.max=Math.max(s+1,r)}_getLabelBounds(){const e=this.getLabelTimestamps();let t=Number.POSITIVE_INFINITY,n=Number.NEGATIVE_INFINITY;return e.length&&(t=e[0],n=e[e.length-1]),{min:t,max:n}}buildTicks(){const e=this.options,t=e.time,n=e.ticks,s="labels"===n.source?this.getLabelTimestamps():this._generate();"ticks"===e.bounds&&s.length&&(this.min=this._userMin||s[0],this.max=this._userMax||s[s.length-1]);const r=this.min,i=function(e,t,n){let s=0,r=e.length;for(;s<r&&e[s]<t;)s++;for(;r>s&&e[r-1]>n;)r--;return s>0||r<e.length?e.slice(s,r):e}(s,r,this.max);return this._unit=t.unit||(n.autoSkip?_a(t.minUnit,this.min,this.max,this._getLabelCapacity(r)):function(e,t,n,s,r){for(let i=Ca.length-1;i>=Ca.indexOf(n);i--){const n=Ca[i];if(Ia[n].common&&e._adapter.diff(r,s,n)>=t-1)return n}return Ca[n?Ca.indexOf(n):0]}(this,i.length,t.minUnit,this.min,this.max)),this._majorUnit=n.major.enabled&&"year"!==this._unit?function(e){for(let t=Ca.indexOf(e)+1,n=Ca.length;t<n;++t)if(Ia[Ca[t]].common)return Ca[t]}(this._unit):void 0,this.initOffsets(s),e.reverse&&i.reverse(),$a(this,i,this._majorUnit)}afterAutoSkip(){this.options.offsetAfterAutoskip&&this.initOffsets(this.ticks.map((e=>+e.value)))}initOffsets(){let e,t,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],s=0,r=0;this.options.offset&&n.length&&(e=this.getDecimalForValue(n[0]),s=1===n.length?1-e:(this.getDecimalForValue(n[1])-e)/2,t=this.getDecimalForValue(n[n.length-1]),r=1===n.length?t:(t-this.getDecimalForValue(n[n.length-2]))/2);const i=n.length<3?.5:.25;s=Oe(s,0,i),r=Oe(r,0,i),this._offsets={start:s,end:r,factor:1/(s+1+r)}}_generate(){const e=this._adapter,t=this.min,n=this.max,s=this.options,r=s.time,i=r.unit||_a(r.minUnit,t,n,this._getLabelCapacity(t)),a=Q(s.ticks.stepSize,1),o="week"===i&&r.isoWeekday,l=Ne(o)||!0===o,u={};let c,h,d=t;if(l&&(d=+e.startOf(d,"isoWeek",o)),d=+e.startOf(d,l?"day":i),e.diff(n,t,i)>1e5*a)throw new Error(t+" and "+n+" are too far apart with stepSize of "+a+" "+i);const p="data"===s.ticks.source&&this.getDataTimestamps();for(c=d,h=0;c<n;c=+e.add(c,a,i),h++)Ea(u,c,p);return c!==n&&"ticks"!==s.bounds&&1!==h||Ea(u,c,p),Object.keys(u).sort(Na).map((e=>+e))}getLabelForValue(e){const t=this._adapter,n=this.options.time;return n.tooltipFormat?t.format(e,n.tooltipFormat):t.format(e,n.displayFormats.datetime)}format(e,t){const n=this.options.time.displayFormats,s=this._unit,r=t||n[s];return this._adapter.format(e,r)}_tickFormatFunction(e,t,n,s){const r=this.options,i=r.ticks.callback;if(i)return J(i,[e,t,n],this);const a=r.time.displayFormats,o=this._unit,l=this._majorUnit,u=o&&a[o],c=l&&a[l],h=n[t],d=l&&c&&h&&h.major;return this._adapter.format(e,s||(d?c:u))}generateTickLabels(e){let t,n,s;for(t=0,n=e.length;t<n;++t)s=e[t],s.label=this._tickFormatFunction(s.value,t,e)}getDecimalForValue(e){return null===e?NaN:(e-this.min)/(this.max-this.min)}getPixelForValue(e){const t=this._offsets,n=this.getDecimalForValue(e);return this.getPixelForDecimal((t.start+n)*t.factor)}getValueForPixel(e){const t=this._offsets,n=this.getDecimalForPixel(e)/t.factor-t.end;return this.min+n*(this.max-this.min)}_getLabelSize(e){const t=this.options.ticks,n=this.ctx.measureText(e).width,s=_e(this.isHorizontal()?t.maxRotation:t.minRotation),r=Math.cos(s),i=Math.sin(s),a=this._resolveTickFontOptions(0).size;return{w:n*r+a*i,h:n*i+a*r}}_getLabelCapacity(e){const t=this.options.time,n=t.displayFormats,s=n[t.unit]||n.millisecond,r=this._tickFormatFunction(e,0,$a(this,[e],this._majorUnit),s),i=this._getLabelSize(r),a=Math.floor(this.isHorizontal()?this.width/i.w:this.height/i.h)-1;return a>0?a:1}getDataTimestamps(){let e,t,n=this._cache.data||[];if(n.length)return n;const s=this.getMatchingVisibleMetas();if(this._normalized&&s.length)return this._cache.data=s[0].controller.getAllParsedValues(this);for(e=0,t=s.length;e<t;++e)n=n.concat(s[e].controller.getAllParsedValues(this));return this._cache.data=this.normalize(n)}getLabelTimestamps(){const e=this._cache.labels||[];let t,n;if(e.length)return e;const s=this.getLabels();for(t=0,n=s.length;t<n;++t)e.push(Ta(this,s[t]));return this._cache.labels=this._normalized?e:this.normalize(e)}normalize(e){return Ue(e.sort(Na))}}function Aa(e,t,n){let s,r,i,a,o=0,l=e.length-1;n?(t>=e[o].pos&&t<=e[l].pos&&({lo:o,hi:l}=ze(e,"pos",t)),({pos:s,time:i}=e[o]),({pos:r,time:a}=e[l])):(t>=e[o].time&&t<=e[l].time&&({lo:o,hi:l}=ze(e,"time",t)),({time:s,pos:i}=e[o]),({time:r,pos:a}=e[l]));const u=r-s;return u?i+(a-i)*(t-s)/u:i}class Da extends Ra{static id="timeseries";static defaults=(()=>Ra.defaults)();constructor(e){super(e),this._table=[],this._minPos=void 0,this._tableRange=void 0}initOffsets(){const e=this._getTimestampsForTable(),t=this._table=this.buildLookupTable(e);this._minPos=Aa(t,this.min),this._tableRange=Aa(t,this.max)-this._minPos,super.initOffsets(e)}buildLookupTable(e){const{min:t,max:n}=this,s=[],r=[];let i,a,o,l,u;for(i=0,a=e.length;i<a;++i)l=e[i],l>=t&&l<=n&&s.push(l);if(s.length<2)return[{time:t,pos:0},{time:n,pos:1}];for(i=0,a=s.length;i<a;++i)u=s[i+1],o=s[i-1],l=s[i],Math.round((u+o)/2)!==l&&r.push({time:l,pos:i/(a-1)});return r}_generate(){const e=this.min,t=this.max;let n=super.getDataTimestamps();return n.includes(e)&&n.length||n.splice(0,0,e),n.includes(t)&&1!==n.length||n.push(t),n.sort(((e,t)=>e-t))}_getTimestampsForTable(){let e=this._cache.all||[];if(e.length)return e;const t=this.getDataTimestamps(),n=this.getLabelTimestamps();return e=t.length&&n.length?this.normalize(t.concat(n)):t.length?t:n,e=this._cache.all=e,e}getDecimalForValue(e){return(Aa(this._table,e)-this._minPos)/this._tableRange}getValueForPixel(e){const t=this._offsets,n=this.getDecimalForPixel(e)/t.factor-t.end;return Aa(this._table,n*this._tableRange+this._minPos,!0)}}const Fa=[ls,ri,ta,Object.freeze({__proto__:null,CategoryScale:ra,LinearScale:la,LogarithmicScale:fa,RadialLinearScale:Sa,TimeScale:Ra,TimeSeriesScale:Da})],Ma="label";function Oa(e,t){"function"===typeof e?e(t):e&&(e.current=t)}function La(e,t){e.labels=t}function Pa(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Ma;const s=[];e.datasets=t.map((t=>{const r=e.datasets.find((e=>e[n]===t[n]));return r&&t.data&&!s.includes(r)?(s.push(r),Object.assign(r,t),r):{...t}}))}function za(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Ma;const n={labels:[],datasets:[]};return La(n,e.labels),Pa(n,e.datasets,t),n}function Ba(e,t){const{height:n=150,width:s=300,redraw:r=!1,datasetIdKey:a,type:o,data:l,options:u,plugins:c=[],fallbackContent:h,updateMode:d,...p}=e,f=(0,i.useRef)(null),g=(0,i.useRef)(),m=()=>{f.current&&(g.current=new Or(f.current,{type:o,data:za(l,a),options:u&&{...u},plugins:c}),Oa(t,g.current))},b=()=>{Oa(t,null),g.current&&(g.current.destroy(),g.current=null)};return(0,i.useEffect)((()=>{!r&&g.current&&u&&function(e,t){const n=e.options;n&&t&&Object.assign(n,t)}(g.current,u)}),[r,u]),(0,i.useEffect)((()=>{!r&&g.current&&La(g.current.config.data,l.labels)}),[r,l.labels]),(0,i.useEffect)((()=>{!r&&g.current&&l.datasets&&Pa(g.current.config.data,l.datasets,a)}),[r,l.datasets]),(0,i.useEffect)((()=>{g.current&&(r?(b(),setTimeout(m)):g.current.update(d))}),[r,u,l.labels,l.datasets,d]),(0,i.useEffect)((()=>{g.current&&(b(),setTimeout(m))}),[o]),(0,i.useEffect)((()=>(m(),()=>b())),[]),i.createElement("canvas",Object.assign({ref:f,role:"img",height:n,width:s},p),h)}const Wa=(0,i.forwardRef)(Ba);function Va(e,t){return Or.register(t),(0,i.forwardRef)(((t,n)=>i.createElement(Wa,Object.assign({},t,{ref:n,type:e}))))}const Ua=Va("line",as);Or.register(...Fa);const Ga=e=>e.charAt(0).toUpperCase()+e.slice(1),Ha=e=>{let{history:t}=e;const n=t.slice(-100),s=n.map((e=>e.time)),r={grass:"green",bushes:"orange",trees:"blue",rabbits:"gray",wolves:"red"},i={labels:s,datasets:["grass","bushes","trees","rabbits","wolves"].map((e=>({label:Ga(e),data:n.map((t=>t[e])),borderColor:r[e],backgroundColor:`${r[e]}33`,fill:!1,tension:.3})))};return(0,o.jsxs)("div",{className:"population-chart-container",children:[(0,o.jsx)("h2",{children:"\u041f\u043e\u043f\u0443\u043b\u044f\u0446\u0438\u0438 \u042d\u043a\u043e\u0441\u0438\u0441\u0442\u0435\u043c\u044b \u0432\u043e \u0412\u0440\u0435\u043c\u0435\u043d\u0438"}),(0,o.jsx)("div",{className:"chart-wrapper",children:(0,o.jsx)(Ua,{data:i,options:{responsive:!0,maintainAspectRatio:!1,plugins:{legend:{position:"top"}},scales:{x:{title:{display:!0,text:"\u0412\u0440\u0435\u043c\u044f (\u0448\u0430\u0433\u0438)"}},y:{beginAtZero:!0,title:{display:!0,text:"\u041f\u043e\u043f\u0443\u043b\u044f\u0446\u0438\u044f"}}}}})})]})};var ja={color:void 0,size:void 0,className:void 0,style:void 0,attr:void 0},Ka=i.createContext&&i.createContext(ja),Xa=["attr","size","title"];function qa(e,t){if(null==e)return{};var n,s,r=function(e,t){if(null==e)return{};var n={};for(var s in e)if(Object.prototype.hasOwnProperty.call(e,s)){if(t.indexOf(s)>=0)continue;n[s]=e[s]}return n}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(s=0;s<i.length;s++)n=i[s],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}function Ya(){return Ya=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var s in n)Object.prototype.hasOwnProperty.call(n,s)&&(e[s]=n[s])}return e},Ya.apply(this,arguments)}function Qa(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);t&&(s=s.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,s)}return n}function Za(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?Qa(Object(n),!0).forEach((function(t){Ja(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):Qa(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function Ja(e,t,n){return(t=function(e){var t=function(e,t){if("object"!=typeof e||!e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var s=n.call(e,t||"default");if("object"!=typeof s)return s;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)}(e,"string");return"symbol"==typeof t?t:t+""}(t))in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function eo(e){return e&&e.map(((e,t)=>i.createElement(e.tag,Za({key:t},e.attr),eo(e.child))))}function to(e){return t=>i.createElement(no,Ya({attr:Za({},e.attr)},t),eo(e.child))}function no(e){var t=t=>{var n,{attr:s,size:r,title:a}=e,o=qa(e,Xa),l=r||t.size||"1em";return t.className&&(n=t.className),e.className&&(n=(n?n+" ":"")+e.className),i.createElement("svg",Ya({stroke:"currentColor",fill:"currentColor",strokeWidth:"0"},t.attr,s,o,{className:n,style:Za(Za({color:e.color||t.color},t.style),e.style),height:l,width:l,xmlns:"http://www.w3.org/2000/svg"}),a&&i.createElement("title",null,a),e.children)};return void 0!==Ka?i.createElement(Ka.Consumer,null,(e=>t(e))):t(ja)}function so(e){return to({tag:"svg",attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M256 224c-79.41 0-192 122.76-192 200.25 0 34.9 26.81 55.75 71.74 55.75 48.84 0 81.09-25.08 120.26-25.08 39.51 0 71.85 25.08 120.26 25.08 44.93 0 71.74-20.85 71.74-55.75C448 346.76 335.41 224 256 224zm-147.28-12.61c-10.4-34.65-42.44-57.09-71.56-50.13-29.12 6.96-44.29 40.69-33.89 75.34 10.4 34.65 42.44 57.09 71.56 50.13 29.12-6.96 44.29-40.69 33.89-75.34zm84.72-20.78c30.94-8.14 46.42-49.94 34.58-93.36s-46.52-72.01-77.46-63.87-46.42 49.94-34.58 93.36c11.84 43.42 46.53 72.02 77.46 63.87zm281.39-29.34c-29.12-6.96-61.15 15.48-71.56 50.13-10.4 34.65 4.77 68.38 33.89 75.34 29.12 6.96 61.15-15.48 71.56-50.13 10.4-34.65-4.77-68.38-33.89-75.34zm-156.27 29.34c30.94 8.14 65.62-20.45 77.46-63.87 11.84-43.42-3.64-85.21-34.58-93.36s-65.62 20.45-77.46 63.87c-11.84 43.42 3.64 85.22 34.58 93.36z"},child:[]}]})(e)}function ro(e){return to({tag:"svg",attr:{viewBox:"0 0 512 512"},child:[{tag:"path",attr:{d:"M64 96H0c0 123.7 100.3 224 224 224v144c0 8.8 7.2 16 16 16h32c8.8 0 16-7.2 16-16V320C288 196.3 187.7 96 64 96zm384-64c-84.2 0-157.4 46.5-195.7 115.2 27.7 30.2 48.2 66.9 59 107.6C424 243.1 512 147.9 512 32h-64z"},child:[]}]})(e)}function io(e){return to({tag:"svg",attr:{viewBox:"0 0 384 512"},child:[{tag:"path",attr:{d:"M378.31 378.49L298.42 288h30.63c9.01 0 16.98-5 20.78-13.06 3.8-8.04 2.55-17.26-3.28-24.05L268.42 160h28.89c9.1 0 17.3-5.35 20.86-13.61 3.52-8.13 1.86-17.59-4.24-24.08L203.66 4.83c-6.03-6.45-17.28-6.45-23.32 0L70.06 122.31c-6.1 6.49-7.75 15.95-4.24 24.08C69.38 154.65 77.59 160 86.69 160h28.89l-78.14 90.91c-5.81 6.78-7.06 15.99-3.27 24.04C37.97 283 45.93 288 54.95 288h30.63L5.69 378.49c-6 6.79-7.36 16.09-3.56 24.26 3.75 8.05 12 13.25 21.01 13.25H160v24.45l-30.29 48.4c-5.32 10.64 2.42 23.16 14.31 23.16h95.96c11.89 0 19.63-12.52 14.31-23.16L224 440.45V416h136.86c9.01 0 17.26-5.2 21.01-13.25 3.8-8.17 2.44-17.47-3.56-24.26z"},child:[]}]})(e)}const ao=e=>{let{map:t}=e;return(0,o.jsxs)("div",{className:"population-map",children:[(0,o.jsx)("h2",{children:"\u041a\u0430\u0440\u0442\u0430 \u041f\u043e\u043f\u0443\u043b\u044f\u0446\u0438\u0438"}),(0,o.jsxs)("svg",{width:"800",height:"500",className:"map-svg",children:[t.grass.map((e=>(0,o.jsx)("circle",{cx:e.x,cy:e.y,r:"3",fill:"green"},e.id))),t.bushes.map((e=>(0,o.jsx)("g",{className:"icon bush",transform:`translate(${e.x}, ${e.y})`,children:(0,o.jsx)(ro,{})},e.id))),t.trees.map((e=>(0,o.jsx)("g",{className:"icon tree",transform:`translate(${e.x}, ${e.y})`,children:(0,o.jsx)(io,{})},e.id))),t.rabbits.map((e=>(0,o.jsx)("g",{className:"icon rabbit",transform:`translate(${e.x}, ${e.y})`,children:(0,o.jsx)(so,{})},e.id))),t.wolves.map((e=>(0,o.jsx)("g",{className:"icon wolf",transform:`translate(${e.x}, ${e.y})`,children:(0,o.jsx)(so,{})},e.id)))]})]})};class oo{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class lo{refCount(e){return uo("refCount")}incRef(e){return uo("incRef")}timerAvailable(){return!0}time(e){return uo("time")}read(e){return uo("read")}readSync(e){return uo("readSync")}readToGPU(e,t){return uo("readToGPU")}numDataIds(){return uo("numDataIds")}disposeData(e,t){return uo("disposeData")}write(e,t,n){return uo("write")}move(e,t,n,s,r){return uo("move")}createTensorFromGPUData(e,t,n){return uo("createTensorFromGPUData")}memory(){return uo("memory")}floatPrecision(){return uo("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return uo("dispose")}}function uo(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function co(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,fo(e,t,n)}function ho(e,t,n){return Math.max(e,Math.min(t,n))}function po(e){return e%2===0?e:e+1}function fo(e,t,n){const s=e[t];e[t]=e[n],e[n]=s}function go(e,t){if(!e)throw new Error("string"===typeof t?t:t())}function mo(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";go(yo(e,t),(()=>n+` Shapes ${e} and ${t} must match`))}function bo(e){go(null!=e,(()=>"The input to the tensor constructor must be a non-null value."))}function xo(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function yo(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function vo(e){return e%1===0}function wo(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function ko(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function So(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e=>0,n=arguments.length>2?arguments[2]:void 0,s=arguments.length>3?arguments[3]:void 0;return new Promise(((r,i)=>{let a=0;const o=()=>{if(e())return void r();a++;const l=t(a);null!=n&&a>=n?i():null!=s?s(o,l):setTimeout(o,l)};o()}))}function Io(e,t){let n=1,s=-1;for(let i=0;i<e.length;++i)if(e[i]>=0)n*=e[i];else if(-1===e[i]){if(-1!==s)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${s} and dim ${i}`);s=i}else if(e[i]<0)throw Error(`Shapes can not be < 0. Found ${e[i]} at dim ${i}`);if(-1===s){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(0===n)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);const r=e.slice();return r[s]=t/n,r}function Co(e,t){const n=t.length;return go((e=null==e?t.map(((e,t)=>t)):[].concat(e)).every((e=>e>=-n&&e<n)),(()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`)),go(e.every((e=>vo(e))),(()=>`All values in axis param must be integers but got axis ${e}`)),e.map((e=>e<0?n+e:e))}function No(e,t){const n=[],s=[],r=null!=t&&Array.isArray(t)&&0===t.length,i=null==t||r?null:Co(t,e).sort();let a=0;for(let o=0;o<e.length;++o){if(null!=i){if(i[a]===o&&1!==e[o])throw new Error(`Can't squeeze axis ${o} since its dim '${e[o]}' is not 1`);(null==i[a]||i[a]>o)&&1===e[o]&&(n.push(e[o]),s.push(o)),i[a]<=o&&a++}1!==e[o]&&(n.push(e[o]),s.push(o))}return{newShape:n,keptDims:s}}function To(e,t){return _o(e,t)}function _o(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error(`Unknown data type ${e}`);n=new Array(t)}return n}function Eo(e,t){return"complex64"!==t&&(("float32"!==t||"complex64"===e)&&(("int32"!==t||"float32"===e||"complex64"===e)&&("bool"!==t||"bool"!==e)))}function $o(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error(`Unknown dtype ${e}`)}function Ro(e){return"string"===typeof e||e instanceof String}function Ao(e){return"number"===typeof e}function Do(e){return Array.isArray(e)?Do(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":Ao(e)?"float32":Ro(e)?"string":"boolean"===typeof e?"bool":"float32"}function Fo(e){return!!(e&&e.constructor&&e.call&&e.apply)}function Mo(e,t){for(let n=t;n<e;++n)if(e%n===0)return n;return e}function Oo(e){const t=e.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=e[t-1];for(let s=t-3;s>=0;--s)n[s]=n[s+1]*e[s+1];return n}function Lo(e,t,n){let s=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=new Array;if(1===t.length){const i=t[0]*(s?2:1);for(let t=0;t<i;t++)r[t]=n[e+t]}else{const i=t[0],a=t.slice(1),o=a.reduce(((e,t)=>e*t))*(s?2:1);for(let t=0;t<i;t++)r[t]=Lo(e+t*o,a,n,s)}return r}function Po(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(0===e.length)return t[0];const s=e.reduce(((e,t)=>e*t))*(n?2:1);if(0===s)return[];if(s!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return Lo(0,e,t,n)}function zo(e,t){const n=Bo(e,t);for(let s=0;s<n.length;s++)n[s]=1;return n}function Bo(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function Wo(e,t){const n=e.reduce(((e,t)=>e*t),1);if(null==t||"float32"===t)return Po(e,new Float32Array(n));if("int32"===t)return Po(e,new Int32Array(n));if("bool"===t)return Po(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function Vo(e){e.forEach((t=>{go(Number.isInteger(t)&&t>=0,(()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`))}))}function Uo(e,t,n){if(0===t)return 0;if(1===t)return e[0];let s=e[e.length-1];for(let r=0;r<e.length-1;++r)s+=n[r]*e[r];return s}function Go(e,t,n){if(0===t)return[];if(1===t)return[e];const s=new Array(t);for(let r=0;r<s.length-1;++r)s[r]=Math.floor(e/n[r]),e-=s[r]*n[r];return s[s.length-1]=e,s}function Ho(e){return e&&e.then&&"function"===typeof e.then}const jo="tfjsflags";class Ko{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=Xo,this.populateURLFlags()}setPlatform(e,t){null!=this.platform&&(qo().getBool("IS_TEST")||qo().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},null!=this.urlFlags[e]){const t=this.urlFlags[e];qo().getBool("IS_TEST")||qo().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${t}.`),this.set(e,t)}}async getAsync(e){return e in this.flags||(this.flags[e]=await this.evaluateFlag(e)),this.flags[e]}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(Ho(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if("undefined"===typeof this.global||"undefined"===typeof this.global.location||"undefined"===typeof this.global.location.search)return;const e=this.getQueryParams(this.global.location.search);if(jo in e){e[jo].split(",").forEach((e=>{const[t,n]=e.split(":");this.urlFlags[t]=function(e,t){const n=t.toLowerCase();return"true"===n||"false"===n?"true"===n:""+ +n===n?+n:t}(0,n)}))}}}function Xo(e){const t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(function(e){for(var n=arguments.length,s=new Array(n>1?n-1:0),r=1;r<n;r++)s[r-1]=arguments[r];return function(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}(t,s[0],s[1]),s.join("=")})),t}function qo(){return Qo}let Yo,Qo=null;function Zo(){if(null==Yo){let e;if("undefined"!==typeof window)e=window;else if("undefined"!==typeof n.g)e=n.g;else if("undefined"!==typeof process)e=process;else{if("undefined"===typeof self)throw new Error("Could not find a global object");e=self}Yo=e}return Yo}function Jo(e,t){const n=function(){const e=Zo();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}();if(n.has(e))return n.get(e);{const s=t();return n.set(e,s),n.get(e)}}const el="Abs",tl="Acos",nl="Acosh",sl="Add",rl="AddN",il="All",al="Any",ol="ArgMax",ll="ArgMin",ul="Asin",cl="Asinh",hl="Atan",dl="Atanh",pl="Atan2",fl="AvgPool",gl="AvgPoolGrad",ml="AvgPool3D",bl="AvgPool3DGrad",xl="BatchMatMul",yl="BatchToSpaceND",vl="Bincount",wl="BitwiseAnd",kl="BroadcastArgs",Sl="Cast",Il="Ceil",Cl="ClipByValue",Nl="Complex",Tl="ComplexAbs",_l="Concat",El="Conv2D",$l="Conv2DBackpropFilter",Rl="Conv2DBackpropInput",Al="Conv3D",Dl="Conv3DBackpropFilterV2",Fl="Conv3DBackpropInputV2",Ml="Cos",Ol="Cosh",Ll="Cumprod",Pl="Cumsum",zl="CropAndResize",Bl="DenseBincount",Wl="DepthToSpace",Vl="DepthwiseConv2dNative",Ul="DepthwiseConv2dNativeBackpropFilter",Gl="DepthwiseConv2dNativeBackpropInput",Hl="Diag",jl="Dilation2D",Kl="Dilation2DBackpropInput",Xl="Dilation2DBackpropFilter",ql="Draw",Yl="RealDiv",Ql="Einsum",Zl="Elu",Jl="EluGrad",eu="Erf",tu="Equal",nu="Exp",su="ExpandDims",ru="Expm1",iu="FFT",au="Fill",ou="FlipLeftRight",lu="Floor",uu="FloorDiv",cu="FusedBatchNorm",hu="GatherV2",du="GatherNd",pu="Greater",fu="GreaterEqual",gu="Identity",mu="IFFT",bu="Imag",xu="IsFinite",yu="IsInf",vu="IsNan",wu="LeakyRelu",ku="Less",Su="LessEqual",Iu="LinSpace",Cu="Log",Nu="Log1p",Tu="LogicalAnd",_u="LogicalNot",Eu="LogicalOr",$u="LRN",Ru="LRNGrad",Au="Max",Du="Maximum",Fu="MaxPool",Mu="MaxPoolGrad",Ou="MaxPool3D",Lu="MaxPool3DGrad",Pu="MaxPoolWithArgmax",zu="Mean",Bu="Min",Wu="Minimum",Vu="MirrorPad",Uu="Mod",Gu="Multinomial",Hu="Multiply",ju="Neg",Ku="NotEqual",Xu="NonMaxSuppressionV3",qu="NonMaxSuppressionV4",Yu="NonMaxSuppressionV5",Qu="OnesLike",Zu="OneHot",Ju="Pack",ec="PadV2",tc="Pow",nc="Prelu",sc="Prod",rc="RaggedGather",ic="RaggedRange",ac="RaggedTensorToTensor",oc="Range",lc="Real",uc="Reciprocal",cc="Relu",hc="Reshape",dc="ResizeNearestNeighbor",pc="ResizeNearestNeighborGrad",fc="ResizeBilinear",gc="ResizeBilinearGrad",mc="Relu6",bc="Reverse",xc="Round",yc="Rsqrt",vc="ScatterNd",wc="TensorScatterUpdate",kc="SearchSorted",Sc="Select",Ic="Selu",Cc="Slice",Nc="Sin",Tc="Sinh",_c="Sign",Ec="Sigmoid",$c="Softplus",Rc="Sqrt",Ac="Sum",Dc="SpaceToBatchND",Fc="SplitV",Mc="Softmax",Oc="SparseFillEmptyRows",Lc="SparseReshape",Pc="SparseSegmentMean",zc="SparseSegmentSum",Bc="SparseToDense",Wc="SquaredDifference",Vc="Square",Uc="StaticRegexReplace",Gc="StridedSlice",Hc="StringNGrams",jc="StringSplit",Kc="StringToHashBucketFast",Xc="Sub",qc="Tan",Yc="Tanh",Qc="Tile",Zc="TopK",Jc="Transform",eh="Transpose",th="Unique",nh="Unpack",sh="UnsortedSegmentSum",rh="ZerosLike",ih="Step",ah="FromPixels",oh="RotateWithOffset",lh="_FusedMatMul",uh="FusedConv2D",ch="FusedDepthwiseConv2D";function hh(){qo().getBool("IS_TEST")||qo().getBool("PROD")||console.warn(...arguments)}function dh(){qo().getBool("IS_TEST")||qo().getBool("PROD")||console.log(...arguments)}const ph=Jo("kernelRegistry",(()=>new Map)),fh=Jo("gradRegistry",(()=>new Map));function gh(e,t){const n=vh(e,t);return ph.get(n)}function mh(e){return fh.get(e)}function bh(e){const t=ph.entries(),n=[];for(;;){const{done:s,value:r}=t.next();if(s)break;const[i,a]=r,[o]=i.split("_");o===e&&n.push(a)}return n}function xh(e){const{kernelName:t,backendName:n}=e,s=vh(t,n);ph.has(s)&&hh(`The kernel '${t}' for backend '${n}' is already registered`),ph.set(s,e)}function yh(e){const{kernelName:t}=e;fh.has(t)&&qo().getBool("DEBUG")&&hh(`Overriding the gradient for '${t}'`),fh.set(t,e)}function vh(e,t){return`${t}_${e}`}function wh(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}var kh=n(353);const Sh=n.n(kh)()||kh;function Ih(e){return Sh.fromString(e,!0,16)}const Ch=Ih("c3a5c85c97cb3127"),Nh=Ih("b492b66fbe98f273"),Th=Ih("9ae16a3b2f90404f");function _h(e){return e.xor(e.shru(47))}function Eh(e,t,n){const s=e.slice(t,t+n);return Sh.fromBytes(Array.from(s),!0,!0)}function $h(e,t){return Eh(e,t,8)}function Rh(e,t){return Eh(e,t,4)}function Ah(e,t){return 0===t?e:e.shru(t).or(e.shl(64-t))}function Dh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Ih("9ddfea08eb382d69"),s=e.xor(t).mul(n);s=s.xor(s.shru(47));let r=t.xor(s).mul(n);return r=r.xor(r.shru(47)),r=r.mul(n),r}function Fh(e,t,n,s){return function(e,t,n,s,r,i){r=r.add(e),i=Ah(i.add(r).add(s),21);const a=r;return r=(r=r.add(t)).add(n),i=i.add(Ah(r,44)),[r.add(s),i.add(a)]}($h(e,t),$h(e,t+8),$h(e,t+16),$h(e,t+24),n,s)}function Mh(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=Sh.fromNumber(81,!0);if(t<=32)return t<=16?function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;if(t>=8){const n=Th.add(2*t),s=$h(e,0).add(Th),r=$h(e,t-8);return Dh(Ah(r,37).mul(n).add(s),Ah(s,25).add(r).mul(n),n)}if(t>=4){const n=Th.add(2*t);return Dh(Rh(e,0).shl(3).add(t),Rh(e,t-4),n)}if(t>0){const n=e[0]+(e[t>>1]<<8),s=t+(e[t-1]<<2);return _h(Th.mul(n).xor(Ch.mul(s))).mul(Th)}return Th}(e,t):function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=Th.add(2*t),s=$h(e,0).mul(Nh),r=$h(e,8),i=$h(e,t-8).mul(n),a=$h(e,t-16).mul(Th);return Dh(Ah(s.add(r),43).add(Ah(i,30)).add(a),s.add(Ah(r.add(Th),18)).add(i),n)}(e,t);if(t<=64)return function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=Th.add(2*t),s=$h(e,0).mul(Th),r=$h(e,8),i=$h(e,t-8).mul(n),a=$h(e,t-16).mul(Th),o=Ah(s.add(r),43).add(Ah(i,30)).add(a),l=Dh(o,s.add(Ah(r.add(Th),18)).add(i),n),u=$h(e,16).mul(n),c=$h(e,24),h=o.add($h(e,t-32)).mul(n),d=l.add($h(e,t-24)).mul(n);return Dh(Ah(u.add(c),43).add(Ah(h,30)).add(d),u.add(Ah(c.add(s),18)).add(h),n)}(e,t);let s=n,r=n.mul(Nh).add(113),i=_h(r.mul(Th).add(113)).mul(Th),a=[Sh.UZERO,Sh.UZERO],o=[Sh.UZERO,Sh.UZERO];s=s.mul(Th).add($h(e,0));let l=0;const u=64*(t-1>>6),c=u+(t-1&63)-63;do{s=Ah(s.add(r).add(a[0]).add($h(e,l+8)),37).mul(Nh),r=Ah(r.add(a[1]).add($h(e,l+48)),42).mul(Nh),s=s.xor(o[1]),r=r.add(a[0]).add($h(e,l+40)),i=Ah(i.add(o[0]),33).mul(Nh),a=Fh(e,l,a[1].mul(Nh),s.add(o[0])),o=Fh(e,l+32,i.add(o[1]),r.add($h(e,l+16))),[i,s]=[s,i],l+=64}while(l!==u);const h=Nh.add(i.and(255).shl(1));return l=c,o[0]=o[0].add(t-1&63),a[0]=a[0].add(o[0]),o[0]=o[0].add(a[0]),s=Ah(s.add(r).add(a[0]).add($h(e,l+8)),37).mul(h),r=Ah(r.add(a[1]).add($h(e,l+48)),42).mul(h),s=s.xor(o[1].mul(9)),r=r.add(a[0].mul(9).add($h(e,l+40))),i=Ah(i.add(o[0]),33).mul(h),a=Fh(e,l,a[1].mul(h),s.add(o[0])),o=Fh(e,l+32,i.add(o[1]),r.add($h(e,l+16))),[i,s]=[s,i],Dh(Dh(a[0],o[0],h).add(_h(r).mul(Ch)).add(i),Dh(a[1],o[1],h).add(s),h)}function Oh(e,t){return"string"===t?zh(e):Lh([e],t)}function Lh(e,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=Vh(e)),qo().getBool("DEBUG")&&function(e,t){for(let n=0;n<e.length;n++){const s=e[n];if(isNaN(s)||!isFinite(s))throw Error(`A tensor of type ${t} being uploaded contains ${s}.`)}}(e,t),function(e,t){return e instanceof Float32Array&&"float32"===t||e instanceof Int32Array&&"int32"===t||e instanceof Uint8Array&&"bool"===t}(e,t))return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){const t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)0!==Math.round(e[n])&&(t[n]=1);return t}throw new Error(`Unknown data type ${t}`)}function Ph(){return qo().platform.now()}function zh(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return t=t||"utf-8",qo().platform.encode(e,t)}function Bh(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return t=t||"utf-8",qo().platform.decode(e,t)}function Wh(e){return null!=qo().platform.isTypedArray?qo().platform.isTypedArray(e):wh(e)}function Vh(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(null==t&&(t=[]),"boolean"===typeof e||"number"===typeof e||"string"===typeof e||Ho(e)||null==e||Wh(e)&&n)t.push(e);else if(Array.isArray(e)||Wh(e))for(let s=0;s<e.length;++s)Vh(e[s],t,n);else{let s=-1;for(const t of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(t)&&(s=Math.max(s,Number(t)));for(let r=0;r<=s;r++)Vh(e[r],t,n)}return t}class Uh{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new Hh)}profileKernel(e,t,n){let s;const r=()=>{s=n()};let i;const a=Ph();if(this.backendTimer.timerAvailable())i=this.backendTimer.time(r);else{r();for(const e of s)e.dataSync();i=Promise.resolve({kernelMs:Ph()-a})}if(qo().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let o=0;o<s.length;o++){const t=s[o];t.data().then((n=>{Gh(n,t.dtype,e)}))}return{kernelName:e,outputs:s,inputs:t,timeMs:i.then((e=>e.kernelMs)),extraInfo:i.then((e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():""))}}logKernelProfile(e){const{kernelName:t,outputs:n,timeMs:s,inputs:r,extraInfo:i}=e;n.forEach((e=>{Promise.all([e.data(),s,i]).then((n=>{this.logger.logKernelProfile(t,e,n[0],n[1],r,n[2])}))}))}}function Gh(e,t,n){if("float32"!==t)return!1;for(let s=0;s<e.length;s++){const t=e[s];if(isNaN(t)||!isFinite(t))return console.warn(`Found ${t} in the result of '${n}'`),!0}return!1}class Hh{logKernelProfile(e,t,n,s,r,i){const a="number"===typeof s?ko(`${s}ms`,9):s.error,o=ko(e,25),l=t.rank,u=t.size,c=ko(t.shape.toString(),14);let h="";for(const d in r){const e=r[d];if(null!=e){const n=e.shape||t.shape,s=n.length;h+=`${d}: ${s}D ${s>0?n:""} `}}console.log(`%c${o}\t%c${a}\t%c${l}D ${c}\t%c${u}\t%c${h}\t%c${i}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function jh(e,t,n,s){const r=Oo(t),i=function(e,t,n,s){const r=xo(t),i=s[s.length-1],a=new Array(i).fill(0),o=t.length,l="complex64"===n?Yh(e):e;if(o>1)for(let u=0;u<r/i;u++){const e=u*i;for(let t=0;t<i;t++)a[t]=Math.max(a[t],Kh(l[e+t],0,n).length)}return a}(e,t,n,r),a=t.length,o=qh(e,t,n,r,i),l=["Tensor"];return s&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${a}`),l.push(`  shape: [${t}]`),l.push("  values:")),l.push(o.map((e=>"    "+e)).join("\n")),l.join("\n")}function Kh(e,t,n){let s;return s=Array.isArray(e)?`${parseFloat(e[0].toFixed(7))} + ${parseFloat(e[1].toFixed(7))}j`:Ro(e)?`'${e}'`:"bool"===n?Xh(e):parseFloat(e.toFixed(7)).toString(),ko(s,t)}function Xh(e){return 0===e?"false":"true"}function qh(e,t,n,s,r){let i=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const a="complex64"===n?2:1,o=t[0],l=t.length;if(0===l){if("complex64"===n){return[Kh(Yh(e)[0],0,n)]}return"bool"===n?[Xh(e[0])]:[e[0].toString()]}if(1===l){if(o>20){const t=3*a;let s=Array.from(e.slice(0,t)),i=Array.from(e.slice((o-3)*a,o*a));return"complex64"===n&&(s=Yh(s),i=Yh(i)),["["+s.map(((e,t)=>Kh(e,r[t],n))).join(", ")+", ..., "+i.map(((e,t)=>Kh(e,r[o-3+t],n))).join(", ")+"]"]}return["["+("complex64"===n?Yh(e):Array.from(e)).map(((e,t)=>Kh(e,r[t],n))).join(", ")+"]"]}const u=t.slice(1),c=s.slice(1),h=s[0]*a,d=[];if(o>20){for(let t=0;t<3;t++){const s=t*h,i=s+h;d.push(...qh(e.slice(s,i),u,n,c,r,!1))}d.push("...");for(let t=o-3;t<o;t++){const s=t*h,i=s+h;d.push(...qh(e.slice(s,i),u,n,c,r,t===o-1))}}else for(let g=0;g<o;g++){const t=g*h,s=t+h;d.push(...qh(e.slice(t,s),u,n,c,r,g===o-1))}const p=2===l?",":"";d[0]="["+(o>0?d[0]+p:"");for(let g=1;g<d.length-1;g++)d[g]=" "+d[g]+p;let f=",\n";for(let g=2;g<l;g++)f+="\n";return d[d.length-1]=" "+d[d.length-1]+"]"+(i?"":f),d}function Yh(e){const t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}class Qh{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=xo(e),null!=n){const e=n.length;go(e===this.size,(()=>`Length of values '${e}' does not match the size inferred by the shape '${this.size}'.`))}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||_o(t,this.size),this.strides=Oo(e)}set(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),s=1;s<t;s++)n[s-1]=arguments[s];0===n.length&&(n=[0]),go(n.length===this.rank,(()=>`The number of provided coordinates (${n.length}) must match the rank (${this.rank})`));const r=this.locToIndex(n);this.values[r]=e}get(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];0===t.length&&(t=[0]);let s=0;for(const i of t){if(i<0||i>=this.shape[s]){const e=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(e)}s++}let r=t[t.length-1];for(let i=0;i<t.length-1;++i)r+=this.strides[i]*t[i];return this.values[r]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];const t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return Zh().makeTensor(this.values,this.shape,this.dtype)}}let Zh=null,Jh=null,ed=null;class td{constructor(e,t,n,s){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=xo(e),this.strides=Oo(e),this.dataId=n,this.id=s,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return Jh.buffer(this.shape,this.dtype,e)}bufferSync(){return Jh.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return Po(this.shape,e,"complex64"===this.dtype)}arraySync(){return Po(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const e=Zh().read(this.dataId);if("string"===this.dtype){const n=await e;try{return n.map((e=>Bh(e)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),Zh().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=Zh().readSync(this.dataId);if("string"===this.dtype)try{return e.map((e=>Bh(e)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await Zh().read(this.dataId);return"string"===this.dtype?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),Zh().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return Jh.print(this,e)}clone(){return this.throwIfDisposed(),Jh.clone(this)}toString(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return jh(this.dataSync(),this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),Jh.cast(this,e)}variable(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],t=arguments.length>1?arguments[1]:void 0,n=arguments.length>2?arguments[2]:void 0;return this.throwIfDisposed(),Zh().makeVariable(this,e,t,n)}}function nd(){return Jo("Tensor",(()=>td))}Object.defineProperty(td,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),nd();class sd extends td{constructor(e,t,n,s){super(e.shape,e.dtype,e.dataId,s),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!yo(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);Zh().disposeTensor(this),this.dataId=e.dataId,Zh().incRef(this,null)}dispose(){Zh().disposeVariable(this),this.isDisposedInternal=!0}}var rd,id,ad,od,ld;Object.defineProperty(sd,Symbol.hasInstance,{value:e=>e instanceof td&&null!=e.assign&&e.assign instanceof Function}),function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"}(rd||(rd={})),function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"}(id||(id={})),function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"}(ad||(ad={})),function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"}(od||(od={})),function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"}(ld||(ld={}));const ud={float32:od,int32:id,bool:ad,complex64:ld};function cd(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return ud[e][t]}function hd(e){return cd(e,"int32")}function dd(e){return null!=e&&"object"===typeof e&&"texture"in e&&e.texture instanceof WebGLTexture}function pd(e){return"undefined"!==typeof GPUBuffer&&null!=e&&"object"===typeof e&&"buffer"in e&&e.buffer instanceof GPUBuffer}function fd(e,t){if(e.dtype===t.dtype)return[e,t];const n=cd(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function gd(e,t){return t.some((t=>t.id===e.id))}function md(e){const t=[];return bd(e,t,new Set),t}function bd(e,t,n){if(null==e)return;if(e instanceof td)return void t.push(e);if(s=e,!Array.isArray(s)&&"object"!==typeof s)return;var s;const r=e;for(const i in r){const e=r[i];n.has(e)||(n.add(e),bd(e,t,n))}}function xd(e){return null!=e.kernelName}class yd{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((e=>e.name))))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class vd{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new yd}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(null==this.backendInstance){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return e in this.registryFactory?(hh(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(null==this.registryFactory[e])throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,null==this.registry[e]){this.backendInstance=null;const{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new Uh(this.backendInstance),!0}setupRegisteredKernels(){bh(this.backendName).forEach((e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(e){bh(e).forEach((t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])}))}initializeBackend(e){const t=this.registryFactory[e];if(null==t)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const n=t.factory();if(!n||n instanceof lo||"function"!==typeof n.then)return this.registry[e]=n,{success:!0,asyncInit:!1};{const t=++this.pendingBackendInitId,s=n.then((n=>!(t<this.pendingBackendInitId)&&(this.registry[e]=n,this.pendingBackendInit=null,!0))).catch((n=>(t<this.pendingBackendInitId||(this.pendingBackendInit=null,hh(`Initialization of backend ${e} failed`),hh(n.stack||n.message)),!1)));return this.pendingBackendInit=s,{success:s,asyncInit:!0}}}catch(n){return hh(`Initialization of backend ${e} failed`),hh(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority))}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t],{success:s,asyncInit:r}=this.initializeBackend(n);if(r||s)return{name:n,asyncInit:r}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const n=this.state.tensorInfo.get(t),s=n.backend,r=this.readSync(t),i=s.refCount(t);s.disposeData(t,!0),n.backend=e,e.move(t,r,n.shape,n.dtype,i),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n,s=null;if(null==t){if("function"!==typeof e)throw new Error("Please provide a function to tidy()");t=e}else{if("string"!==typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!==typeof t)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=e}return this.scopedRun((()=>this.startScope(s)),(()=>this.endScope(n)),(()=>(n=t(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n)))}scopedRun(e,t,n){e();try{const e=n();return t(),e}catch(s){throw t(),s}}nextTensorId(){return vd.nextTensorId++}nextVariableId(){return vd.nextVariableId++}clone(e){const t=kd.runKernel(gu,{x:e}),n={x:e};return this.addTapeNode(this.state.activeScope.name,n,[t],(e=>({x:()=>{const t={x:e},n={dtype:"float32"};return kd.runKernel(Sl,t,n)}})),[],{}),t}runKernel(e,t,n){null==this.backendName&&this.backend;if(!(null!=gh(e,this.backendName)))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){const s=this.backend.numDataIds();let r=0;n.forEach((e=>{r+="complex64"===e.dtype?3:1}));const i=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],a=s-t-r-i;if(a>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${e}'`)}runKernelFunc(e){let t,n=[];const s=this.isTapeOn(),r=this.state.numBytes,i=this.state.numTensors;let a,o;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;const l=xd(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(xd(e)){const{kernelName:t,inputs:r,attrs:i}=e;null==this.backendName&&this.backend;const l=gh(t,this.backendName);go(null!=l,(()=>`Cannot find registered kernel '${t}' for backend '${this.backendName}'`)),a=()=>{const e=this.backend.numDataIds();o=l.kernelFunc({inputs:r,attrs:i,backend:this.backend});const a=Array.isArray(o)?o:[o];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,a);const u=a.map((e=>null!=e.rank?e:this.makeTensorFromTensorInfo(e)));if(s){const e=this.getTensorsForGradient(t,r,u);n=this.saveTensorsForBackwardMode(e)}return u}}else{const{forwardFunc:t}=e,r=e=>{s&&(n=e.map((e=>this.keep(this.clone(e)))))};a=()=>{const e=this.backend.numDataIds();o=this.tidy((()=>t(this.backend,r)));const n=Array.isArray(o)?o:[o];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,e,n),n}}const{inputs:u,attrs:c}=e,h=xd(e)?null:e.backwardsFunc;let d;return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(d=this.profiler.profileKernel(l,u,(()=>a())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(d),t=d.outputs):t=a()})),s&&this.addTapeNode(l,u,t,h,n,c),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-r,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-i,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(u).map((e=>null!=u[e]?u[e].shape:null)),outputShapes:t.map((e=>e.shape)),kernelTimeMs:d.timeMs,extraInfo:d.extraInfo}),Array.isArray(o)?t:t[0]}saveTensorsForBackwardMode(e){return e.map((e=>this.keep(this.clone(e))))}getTensorsForGradient(e,t,n){const s=mh(e);if(null!=s){const e=s.inputsToSave||[],r=s.outputsToSave||[];let i;s.saveAllInputs?(go(Array.isArray(t),(()=>"saveAllInputs is true, expected inputs to be an array.")),i=Object.keys(t).map((e=>t[e]))):i=e.map((e=>t[e]));const a=n.filter(((e,t)=>r[t]));return i.concat(a)}return[]}makeTensor(e,t,n,s){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",s=s||this.backend;let r=e;"string"===n&&Ro(e[0])&&(r=e.map((e=>zh(e))));const i=s.write(r,t,n),a=new td(t,n,i,this.nextTensorId());if(this.trackTensor(a,s),"string"===n){const e=this.state.tensorInfo.get(i),t=function(e){if(null==e)return 0;let t=0;return e.forEach((e=>t+=e.length)),t}(r);this.state.numBytes+=t-e.bytes,e.bytes=t}return a}makeTensorFromDataId(e,t,n,s){const r={dataId:e,shape:t,dtype:n=n||"float32"};return this.makeTensorFromTensorInfo(r,s)}makeTensorFromTensorInfo(e,t){const{dataId:n,shape:s,dtype:r}=e,i=new td(s,r,n,this.nextTensorId());return this.trackTensor(i,t),i}makeVariable(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,s=arguments.length>3?arguments[3]:void 0;n=n||this.nextVariableId().toString(),null!=s&&s!==e.dtype&&(e=e.cast(s));const r=new sd(e,t,n,this.nextTensorId());if(null!=this.state.registeredVariables[r.name])throw new Error(`Variable with name ${r.name} was already registered`);return this.state.registeredVariables[r.name]=r,this.incRef(r,this.backend),r}trackTensor(e,t){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(n=e.size*$o(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof sd||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const t=e.size*$o(e.dtype);this.state.numBytes-=t}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((e=>e.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const s of this.state.activeProfile.kernels)s.kernelTimeMs=await s.kernelTimeMs,s.extraInfo=await s.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,n,s,r,i){const a={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:r},o=mh(e);null!=o&&(s=o.gradFunc),null!=s&&(a.gradient=e=>(e=e.map(((e,t)=>{if(null==e){const e=n[t],s=Bo(e.size,e.dtype);return this.makeTensor(s,e.shape,e.dtype)}return e})),s(e.length>1?e:e[0],r,i))),this.state.activeTape.push(a)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=md(e),n=new Set(t.map((e=>e.id)));for(let r=0;r<this.state.activeScope.track.length;r++){const e=this.state.activeScope.track[r];e.kept||n.has(e.id)||e.dispose()}const s=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach((e=>{e.kept||e.scopeId!==s.id||this.track(e)}))}gradients(e,t,n){let s=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(go(t.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);const r=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",e)));go(r instanceof td,(()=>"The result y returned by f() must be a tensor."));const i=function(e,t,n){const s={},r={};for(let l=0;l<t.length;l++)s[t[l].id]=!0;for(let l=0;l<e.length;l++){const n=e[l],i=n.inputs;for(const e in i){const a=i[e];let o=!1;for(let e=0;e<t.length;e++)if(s[a.id]){n.outputs.forEach((e=>s[e.id]=!0)),o=!0,r[n.id]=!0;break}if(o)break}}const i={};i[n.id]=!0;const a={};for(let l=e.length-1;l>=0;l--){const t=e[l],n=t.inputs;for(let e=0;e<t.outputs.length;e++)if(i[t.outputs[e].id]){for(const e in n)i[n[e].id]=!0,a[t.id]=!0;break}}const o=[];for(let l=0;l<e.length;l++){const t=e[l];if(r[t.id]&&a[t.id]){const e={};for(const r in t.inputs){const n=t.inputs[r];s[n.id]&&(e[r]=n)}const n=Object.assign({},t);n.inputs=e,n.outputs=t.outputs,o.push(n)}}return o}(this.state.activeTape,t,r);if(!s&&0===i.length&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{const e={};e[r.id]=null==n?function(e){const t=zo(xo(e),"float32");return kd.makeTensor(t,e,"float32")}(r.shape):n,function(e,t,n,s){for(let r=t.length-1;r>=0;r--){const i=t[r],a=[];if(i.outputs.forEach((t=>{const n=e[t.id];null!=n?a.push(n):a.push(null)})),null==i.gradient)throw new Error(`Cannot compute gradient: gradient function not found for ${i.kernelName}.`);const o=i.gradient(a);for(const t in i.inputs){if(!(t in o))throw new Error(`Cannot backprop through input ${t}. Available gradients found: ${Object.keys(o)}.`);const r=n((()=>o[t]()));if("float32"!==r.dtype)throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input ${t} must have 'float32' dtype, but has '${r.dtype}'`);const a=i.inputs[t];if(!yo(r.shape,a.shape))throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input '${t}' has shape '${r.shape}', which does not match the shape of the input '${a.shape}'`);if(null==e[a.id])e[a.id]=r;else{const t=e[a.id];e[a.id]=s(t,r),t.dispose()}}}}(e,i,(e=>this.tidy(e)),Sd);const s=t.map((t=>e[t.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((e=>{for(const t of e.saved)t.dispose()})),this.state.activeTape=null),{value:r,grads:s}}))}customGrad(e){var t=this;return go(Fo(e),(()=>"The f passed in customGrad(f) must be a function.")),function(){for(var n=arguments.length,s=new Array(n),r=0;r<n;r++)s[r]=arguments[r];let i;go(s.every((e=>e instanceof td)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));const a={};s.forEach(((e,t)=>{a[t]=e}));return t.runKernelFunc({forwardFunc:(t,n)=>(i=e(...s,n),go(i.value instanceof td,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),go(Fo(i.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),i.value),backwardsFunc:(e,t)=>{const n=i.gradFunc(e,t),r=Array.isArray(n)?n:[n];go(r.length===s.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),go(r.every((e=>e instanceof td)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));const a={};return r.forEach(((e,t)=>{a[t]=()=>e})),a},inputs:a})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=Ph(),n=await this.backend.time(e);return n.wallMs=Ph()-t,n}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new yd;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function wd(){const e=Zo();if(null==e._tfengine){const t=new Ko(e);e._tfengine=new vd(t)}var t;return t=e._tfengine.ENV,Qo=t,Zh=()=>e._tfengine,e._tfengine}vd.nextTensorId=0,vd.nextVariableId=0;const kd=wd();function Sd(e,t){const n={a:e,b:t};return kd.runKernel(sl,n)}let Id;function Cd(e){if(void 0!==Id)return Id;if(e||"undefined"!==typeof navigator&&null!=navigator){if(e||(e=navigator),"ReactNative"===e.product)return!0;const t=e.userAgent||e.vendor||("undefined"!==typeof window?window.opera:"");if(!t){const t=e;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function Nd(){return"undefined"!==typeof window&&null!=window.document||"undefined"!==typeof WorkerGlobalScope}const Td=qo();function _d(e,t){let n=e;if(Wh(e))return"string"===t?[]:[e.length];if(dd(e)){const t=e.channels||"RGBA";return[e.height,e.width*t.length]}if(pd(e))return[e.buffer.size/(null==t?4:$o(t))];if(!Array.isArray(e))return[];const s=[];for(;Array.isArray(n)||Wh(n)&&"string"!==t;)s.push(n.length),n=n[0];return Array.isArray(e)&&qo().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&Ed(e,s,[]),s}function Ed(e,t,n){if(n=n||[],!Array.isArray(e)&&!Wh(e))return void go(0===t.length,(()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`));go(t.length>0,(()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`)),go(e.length===t[0],(()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`));const s=t.slice(1);for(let r=0;r<e.length;++r)Ed(e[r],s,n.concat(r))}function $d(e,t,n,s){if("string_or_numeric"!==e){if(null==e)throw new Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw new Error(`Argument '${n}' passed to '${s}' must be ${e} tensor, but got ${t} tensor`)}}function Rd(e,t,n){let s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(e instanceof nd())return $d(s,e.dtype,t,n),e;let r=Do(e);if("string"!==r&&["bool","int32","float32"].indexOf(s)>=0&&(r=s),$d(s,r,t,n),null==e||!Wh(e)&&!Array.isArray(e)&&"number"!==typeof e&&"boolean"!==typeof e&&"string"!==typeof e){const s=null==e?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${s}'`)}const i=_d(e,r);Wh(e)||Array.isArray(e)||(e=[e]);const a="string"!==r?Lh(e,r):Vh(e,[],!0);return kd.makeTensor(a,i,r)}function Ad(e,t,n){let s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map(((e,r)=>Rd(e,`${t}[${r}]`,n,s)))}Td.registerFlag("DEBUG",(()=>!1),(e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),Td.registerFlag("IS_BROWSER",(()=>Nd())),Td.registerFlag("IS_NODE",(()=>"undefined"!==typeof process&&"undefined"!==typeof process.versions&&"undefined"!==typeof process.versions.node)),Td.registerFlag("IS_CHROME",(()=>"undefined"!==typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor))),Td.registerFlag("IS_SAFARI",(()=>"undefined"!==typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor))),Td.registerFlag("PROD",(()=>!1)),Td.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>Td.getBool("DEBUG"))),Td.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>!0)),Td.registerFlag("IS_TEST",(()=>!1)),Td.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",(()=>Td.getBool("DEBUG"))),Td.registerFlag("WRAP_TO_IMAGEBITMAP",(()=>!1)),Td.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",(()=>!1)),Td.registerFlag("USE_SETTIMEOUTCUSTOM",(()=>!1));function Dd(e){const t=Object.keys(e);if(1!==t.length)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0];const s=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+="__op";const r=function(){kd.startScope(n);try{const e=s(...arguments);return Ho(e)&&console.error("Cannot return a Promise inside of tidy."),kd.endScope(e),e}catch(e){throw kd.endScope(null),e}};return Object.defineProperty(r,"name",{value:n,configurable:!0}),r}const Fd=Dd({complex_:function(e,t){const n=Rd(e,"real","complex"),s=Rd(t,"imag","complex");mo(n.shape,s.shape,`real and imag shapes, ${n.shape} and ${s.shape}, must match in call to tf.complex().`);const r={real:n,imag:s};return kd.runKernel(Nl,r)}});function Md(e,t,n,s){if(null==s)s=Do(e);else if("complex64"===s)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(pd(e)||dd(e)){if("float32"!==s&&"int32"!==s)throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${s}.`);return kd.backend.createTensorFromGPUData(e,t||n,s)}if(!Wh(e)&&!Array.isArray(e)&&"number"!==typeof e&&"boolean"!==typeof e&&"string"!==typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){Vo(t);const e=xo(t),s=xo(n);go(e===s,(()=>`Based on the provided shape, [${t}], the tensor should have ${e} values but has ${s}`));for(let r=0;r<n.length;++r){const e=n[r],s=r!==n.length-1||e!==xo(t.slice(r));go(n[r]===t[r]||!s,(()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `))}}return Wh(e)||Array.isArray(e)||(e=[e]),t=t||n,e="string"!==s?Lh(e,s):Vh(e,[],!0),kd.makeTensor(e,t,s)}function Od(e,t,n){return Md(e,t,_d(e,n),n)}class Ld{static join(e){return new Ld(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,null==e)return;if(e instanceof Array||(e=[e]),0===(e=e.map((e=>Wh(e)?e.buffer:e))).length)return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let n=0;n<e.length;n++){const s=e[n];n!==e.length-1&&s.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const r=t+s.byteLength;this.shards.push({buffer:s,start:t,end:r}),t=r}0===this.shards.length&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.byteLength;if(0===this.shards.length)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),t=Math.min(this.byteLength,t),t<=e)return new ArrayBuffer(0);const n=this.findShardForByte(e);if(-1===n)throw new Error(`Could not find start shard for byte ${e}`);const s=new ArrayBuffer(t-e),r=new Uint8Array(s);let i=0;for(let a=n;a<this.shards.length;a++){const n=this.shards[a],s=e+i-n.start,o=i,l=Math.min(t,n.end)-n.start,u=new Uint8Array(n.buffer,s,l-s);if(r.set(u,o),i+=u.length,t<n.end)break}return s}findShardForByte(e){if(0===this.shards.length||e<0||e>=this.byteLength)return-1;if(null!=this.bufferUniformSize)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(t){return e<t.start?-1:e>=t.end?1:0}if(0===t(this.shards[this.previousShardIndex]))return this.previousShardIndex;const n=function(e,t){let n=0,s=e.length;for(;n<=s;){const r=Math.floor((s-n)/2)+n,i=t(e[r]);if(0===i)return r;i<0?s=r:n=r+1}return-1}(this.shards,t);return-1===n?-1:(this.previousShardIndex=n,this.previousShardIndex)}}function Pd(){return kd}function zd(){return kd.memory()}function Bd(e,t){return kd.tidy(e,t)}function Wd(e){md(e).forEach((e=>e.dispose()))}function Vd(e){return kd.keep(e)}function Ud(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return kd.registerBackend(e,t,n)}function Gd(){return kd.backend}ed=function(e){qo().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")};async function Hd(e,t){const n=[],s=[],r=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);for(let i=0;i<r.length;++i){const a=r[i],o=Array.isArray(e)?e[i].tensor:e[a];if("float32"!==o.dtype&&"int32"!==o.dtype&&"bool"!==o.dtype&&"string"!==o.dtype&&"complex64"!==o.dtype)throw new Error(`Unsupported dtype in weight '${a}': ${o.dtype}`);const l={name:a,shape:o.shape,dtype:o.dtype};if("string"===o.dtype){const e=new Promise((async e=>{const t=await o.bytes(),n=t.reduce(((e,t)=>e+t.length),0)+4*t.length,s=new Uint8Array(n);let r=0;for(let i=0;i<t.length;i++){const e=t[i],n=new Uint8Array(new Uint32Array([e.length]).buffer);s.set(n,r),r+=4,s.set(e,r),r+=e.length}e(s)}));s.push(e)}else s.push(o.data());null!=t&&(l.group=t),n.push(l)}return{data:jd(await Promise.all(s)),specs:n}}function jd(e){if(null===e)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0;const n=[];e.forEach((e=>{if(t+=e.byteLength,n.push(e.byteLength===e.buffer.byteLength?e:new e.constructor(e)),!(e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${e.constructor.name}`)}));const s=new Uint8Array(t);let r=0;return n.forEach((e=>{s.set(new Uint8Array(e.buffer),r),r+=e.byteLength})),s.buffer}const Kd="undefined"!==typeof Buffer&&("undefined"===typeof Blob||"undefined"===typeof atob||"undefined"===typeof btoa);function Xd(e){return Kd?Buffer.byteLength(e,"utf8"):new Blob([e]).size}function qd(e,t){const n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(n.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(n.trainingConfig=e.trainingConfig),n}async function Yd(e,t){let n,s;return null!=e.weightsManifest&&([n,s]=await t(e.weightsManifest)),function(e,t,n){const s={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(null!=e.trainingConfig&&(s.trainingConfig=e.trainingConfig),null!=e.weightsManifest){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");s.weightSpecs=t,s.weightData=n}return null!=e.signature&&(s.signature=e.signature),null!=e.userDefinedMetadata&&(s.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(s.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(s.initializerSignature=e.initializerSignature),s}(e,n,s)}function Qd(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:Xd(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:Xd(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:new Ld(e.weightData).byteLength}}function Zd(e){const t=[];for(const n of e)t.push(...n.weights);return t}class Jd{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==Jd.instance&&(Jd.instance=new Jd),Jd.instance}static registerSaveRouter(e){Jd.getInstance().saveRouters.push(e)}static registerLoadRouter(e){Jd.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return Jd.getHandlers(e,"save")}static getLoadHandlers(e,t){return Jd.getHandlers(e,"load",t)}static getHandlers(e,t,n){const s=[];return("load"===t?Jd.getInstance().loadRouters:Jd.getInstance().saveRouters).forEach((t=>{const r=t(e,n);null!==r&&s.push(r)})),s}}const ep="tensorflowjs",tp="models_store",np="model_info_store";function sp(){if(!qo().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const e="undefined"===typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function rp(e){const t=e.result;t.createObjectStore(tp,{keyPath:"modelPath"}),t.createObjectStore(np,{keyPath:"modelPath"})}class ip{constructor(e){if(this.indexedDB=sp(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise(((e,n)=>{const s=this.indexedDB.open(ep,1);s.onupgradeneeded=()=>rp(s),s.onsuccess=()=>{const r=s.result;if(null==t){const t=r.transaction(tp,"readonly"),s=t.objectStore(tp).get(this.modelPath);s.onsuccess=()=>{if(null==s.result)return r.close(),n(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));e(s.result.modelArtifacts)},s.onerror=e=>(r.close(),n(s.error)),t.oncomplete=()=>r.close()}else{t.weightData=Ld.join(t.weightData);const s=Qd(t),a=r.transaction(np,"readwrite");let o,l,u=a.objectStore(np);try{o=u.put({modelPath:this.modelPath,modelArtifactsInfo:s})}catch(i){return n(i)}o.onsuccess=()=>{l=r.transaction(tp,"readwrite");const o=l.objectStore(tp);let c;try{c=o.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:s})}catch(i){return n(i)}c.onsuccess=()=>e({modelArtifactsInfo:s}),c.onerror=e=>{u=a.objectStore(np);const t=u.delete(this.modelPath);t.onsuccess=()=>(r.close(),n(c.error)),t.onerror=e=>(r.close(),n(c.error))}},o.onerror=e=>(r.close(),n(o.error)),a.oncomplete=()=>{null==l?r.close():l.oncomplete=()=>r.close()}}},s.onerror=e=>n(s.error)}))}}ip.URL_SCHEME="indexeddb://";const ap=e=>{return qo().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(ip.URL_SCHEME)?(t=e.slice(ip.URL_SCHEME.length),new ip(t)):null;var t};Jd.registerSaveRouter(ap),Jd.registerLoadRouter(ap);class op{constructor(){this.indexedDB=sp()}async listModels(){return new Promise(((e,t)=>{const n=this.indexedDB.open(ep,1);n.onupgradeneeded=()=>rp(n),n.onsuccess=()=>{const s=n.result,r=s.transaction(np,"readonly"),i=r.objectStore(np).getAll();i.onsuccess=()=>{const t={};for(const e of i.result)t[e.modelPath]=e.modelArtifactsInfo;e(t)},i.onerror=e=>(s.close(),t(i.error)),r.oncomplete=()=>s.close()},n.onerror=e=>t(n.error)}))}async removeModel(e){var t;return e=(t=e).startsWith(ip.URL_SCHEME)?t.slice(ip.URL_SCHEME.length):t,new Promise(((t,n)=>{const s=this.indexedDB.open(ep,1);s.onupgradeneeded=()=>rp(s),s.onsuccess=()=>{const r=s.result,i=r.transaction(np,"readwrite"),a=i.objectStore(np),o=a.get(e);let l;o.onsuccess=()=>{if(null==o.result)return r.close(),n(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const s=a.delete(e),i=()=>{l=r.transaction(tp,"readwrite");const s=l.objectStore(tp).delete(e);s.onsuccess=()=>t(o.result.modelArtifactsInfo),s.onerror=e=>n(o.error)};s.onsuccess=i,s.onerror=e=>(i(),r.close(),n(o.error))}},o.onerror=e=>(r.close(),n(o.error)),i.oncomplete=()=>{null==l?r.close():l.oncomplete=()=>r.close()}},s.onerror=e=>n(s.error)}))}}const lp="/",up="tensorflowjs_models",cp="info",hp="model_topology",dp="weight_specs",pp="weight_data",fp="model_metadata";function gp(e){return{info:[up,e,cp].join(lp),topology:[up,e,hp].join(lp),weightSpecs:[up,e,dp].join(lp),weightData:[up,e,pp].join(lp),modelMetadata:[up,e,fp].join(lp)}}function mp(e){for(const t of Object.values(e))window.localStorage.removeItem(t)}function bp(e){const t=e.split(lp);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(lp)}class xp{constructor(e){if(!qo().getBool("IS_BROWSER")||"undefined"===typeof window||"undefined"===typeof window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=gp(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const n=JSON.stringify(e.modelTopology),s=JSON.stringify(e.weightSpecs),r=Qd(e),i=Ld.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,s),this.LS.setItem(this.keys.weightData,function(e){if(Kd)return Buffer.from(e).toString("base64");const t=new Uint8Array(e);let n="";for(let s=0,r=t.length;s<r;s++)n+=String.fromCharCode(t[s]);return btoa(n)}(i));const t={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,initializerSignature:null!=e.initializerSignature?e.initializerSignature:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(t)),{modelArtifactsInfo:r}}catch(t){throw mp(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(null==e)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if("JSON"!==e.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=n;const s=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==s)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=s;const r=this.LS.getItem(this.keys.modelMetadata);if(null!=r){const e=JSON.parse(r);t.format=e.format,t.generatedBy=e.generatedBy,t.convertedBy=e.convertedBy,null!=e.signature&&(t.signature=e.signature),null!=e.userDefinedMetadata&&(t.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(t.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(t.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(t.trainingConfig=e.trainingConfig)}const i=this.LS.getItem(this.keys.weightData);if(null==i)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=function(e){if(Kd){const t=Buffer.from(e,"base64");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}const t=atob(e),n=new Uint8Array(t.length);for(let s=0;s<t.length;++s)n.set([t.charCodeAt(s)],s);return n.buffer}(i),t}}xp.URL_SCHEME="localstorage://";const yp=e=>{return qo().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(xp.URL_SCHEME)?(t=e.slice(xp.URL_SCHEME.length),new xp(t)):null;var t};Jd.registerSaveRouter(yp),Jd.registerLoadRouter(yp);class vp{constructor(){go(qo().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser")),go("undefined"===typeof window||"undefined"!==typeof window.localStorage,(()=>"Current browser does not appear to support localStorage")),this.LS=window.localStorage}async listModels(){const e={},t=up+lp,n=lp+cp;for(let s=0;s<this.LS.length;++s){const r=this.LS.key(s);if(r.startsWith(t)&&r.endsWith(n)){e[bp(r)]=JSON.parse(this.LS.getItem(r))}}return e}async removeModel(e){var t;const n=gp(e=(t=e).startsWith(xp.URL_SCHEME)?t.slice(xp.URL_SCHEME.length):t);if(null==this.LS.getItem(n.info))throw new Error(`Cannot find model at path '${e}'`);const s=JSON.parse(this.LS.getItem(n.info));return mp(n),s}}const wp="://";class kp{constructor(){this.managers={}}static getInstance(){return null==kp.instance&&(kp.instance=new kp),kp.instance}static registerManager(e,t){go(null!=e,(()=>"scheme must not be undefined or null.")),e.endsWith(wp)&&(e=e.slice(0,e.indexOf(wp))),go(e.length>0,(()=>"scheme must not be an empty string."));const n=kp.getInstance();go(null==n.managers[e],(()=>`A model store manager is already registered for scheme '${e}'.`)),n.managers[e]=t}static getManager(e){const t=kp.getInstance().managers[e];if(null==t)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(kp.getInstance().managers)}}class Sp{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){"undefined"!==typeof window&&qo().getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(e),setTimeout((()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")}),t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",(e=>{if(e.source===window&&e.data.name===this.messageName){e.stopPropagation();(0,this.functionRefs[e.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}}),!0))):setTimeout(e,t)}isTypedArray(e){return wh(e)}}if(qo().get("IS_BROWSER")){qo().setPlatform("browser",new Sp);try{kp.registerManager(xp.URL_SCHEME,new vp)}catch(SG){}try{kp.registerManager(ip.URL_SCHEME,new op)}catch(SG){}}const Ip=()=>n(817);let Cp;class Np{constructor(){this.util=n(590),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=qo().global.fetch?qo().global.fetch(e,t):(null==Cp&&(Cp=Ip()),Cp(e,t))}now(){const e=process.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}function Tp(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32",n=arguments.length>2?arguments[2]:void 0;return t=t||"float32",Vo(e),new Qh(e,t,n)}qo().get("IS_NODE")&&!qo().get("IS_BROWSER")&&qo().setPlatform("node",new Np);const _p=Dd({cast_:function(e,t){const n=Rd(e,"x","cast");if(!function(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const s={x:n},r={dtype:t};return kd.runKernel(Sl,s,r)}});const Ep=Dd({clone_:function(e){const t={x:Rd(e,"x","clone","string_or_numeric")};return kd.runKernel(gu,t)}});wd();Jh={buffer:Tp,cast:_p,clone:Ep,print:function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];console.log(e.toString(t))}};const $p=Dd({add_:function(e,t){let n=Rd(e,"a","add"),s=Rd(t,"b","add");[n,s]=fd(n,s);const r={a:n,b:s};return kd.runKernel(sl,r)}});const Rp=Dd({floorDiv_:function(e,t){let n=Rd(e,"a","floorDiv"),s=Rd(t,"b","floorDiv");[n,s]=fd(n,s);const r={a:n,b:s};return kd.runKernel(uu,r)}});const Ap=Dd({div_:function(e,t){let n=Rd(e,"a","div"),s=Rd(t,"b","div");if([n,s]=fd(n,s),"int32"===n.dtype&&"int32"===s.dtype)return Rp(n,s);const r={a:n,b:s};return kd.runKernel(Yl,r,{})}});const Dp=Dd({mul_:function(e,t){let n=Rd(e,"a","mul"),s=Rd(t,"b","mul");[n,s]=fd(n,s);const r={a:n,b:s};return kd.runKernel(Hu,r)}});const Fp=Dd({sqrt_:function(e){const t={x:Rd(e,"x","sqrt","float32")};return kd.runKernel(Rc,t)}});const Mp=Dd({square_:function(e){const t=Rd(e,"x","square");return kd.runKernel("Square",{x:t},{})}});const Op=Dd({zerosLike_:function(e){const t={x:Rd(e,"x","zerosLike")};return kd.runKernel(rh,t)}});function Lp(e){return kd.customGrad(e)}function Pp(e,t){if((Wh(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&Wh(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Md(e,[],[],t)}const zp=new Map,Bp=new Map;class Wp{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class Vp{constructor(){this.classNameMap={}}static getMap(){return null==Vp.instance&&(Vp.instance=new Vp),Vp.instance}static register(e){Vp.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function Up(e,t,n){go(null!=e.className,(()=>"Class being registered does not have the static className property defined.")),go("string"===typeof e.className,(()=>"className is required to be a string, but got type "+typeof e.className)),go(e.className.length>0,(()=>"Class being registered has an empty-string as its className, which is disallowed.")),"undefined"===typeof t&&(t="Custom"),"undefined"===typeof n&&(n=e.className);const s=t+">"+n;return Vp.register(e),zp.set(s,e),Bp.set(e,s),e}class Gp extends Wp{minimize(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2?arguments[2]:void 0;const{value:s,grads:r}=this.computeGradients(e,n);if(null!=n){const e=n.map((e=>({name:e.name,tensor:r[e.name]})));this.applyGradients(e)}else this.applyGradients(r);return Wd(r),t?s:(s.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return function(e,t){go(Fo(e),(()=>"The f passed in variableGrads(f) must be a function")),go(null==t||Array.isArray(t)&&t.every((e=>e instanceof sd)),(()=>"The varList passed in variableGrads(f, varList) must be an array of variables"));const n=null!=t;if(!n){t=[];for(const e in kd.registeredVariables)t.push(kd.registeredVariables[e])}const s=n?t.filter((e=>!e.trainable)):null,r=t.length;t=t.filter((e=>e.trainable)),go(t.length>0,(()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${r} variables is trainable.`));const{value:i,grads:a}=kd.gradients(e,t,null,!0);go(a.some((e=>null!=e)),(()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().")),go(0===i.rank,(()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${i.rank} tensor`));const o={};return t.forEach(((e,t)=>{null!=a[t]&&(o[e.name]=a[t])})),null!=s&&s.forEach((e=>o[e.name]=null)),{value:i,grads:o}}(e,t)}dispose(){null!=this.iterations_&&Wd(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:Pp(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(Gp,Symbol.hasInstance,{value:e=>null!=e.minimize&&null!=e.computeGradients&&null!=e.applyGradients});class Hp extends Gp{static get className(){return"Adadelta"}constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=kd.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const s=kd.registeredVariables[t],r=!1;null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:`${t}/accum_grad`,variable:Bd((()=>Op(s).variable(r)))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:`${t}/accum_var`,variable:Bd((()=>Op(s).variable(r)))});const i=Array.isArray(e)?e[n].tensor:e[t];if(null==i)return;const a=this.accumulatedGrads[n].variable,o=this.accumulatedUpdates[n].variable;Bd((()=>{const e=$p(Dp(a,this.rho),Dp(Mp(i),1-this.rho)),t=Dp(Ap(Fp($p(o,this.epsilon)),Fp($p(a,this.epsilon))),i),n=$p(Dp(o,this.rho),Dp(Mp(t),1-this.rho));a.assign(e),o.assign(n);const r=$p(Dp(t,-this.learningRate),s);s.assign(r)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(Wd(this.accumulatedGrads.map((e=>e.variable))),Wd(this.accumulatedUpdates.map((e=>e.variable))))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){const t=(e=await this.extractIterations(e)).length/2,n=!1;this.accumulatedGrads=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedUpdates=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}function jp(e,t,n){Vo(e);const s={shape:e,value:t,dtype:n=n||Do(t)};return kd.runKernel(au,{},s)}class Kp extends Gp{static get className(){return"Adagrad"}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1;super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const s=kd.registeredVariables[t];if(null==this.accumulatedGrads[n]){const e=!1;this.accumulatedGrads[n]={originalName:`${t}/accumulator`,variable:Bd((()=>jp(s.shape,this.initialAccumulatorValue).variable(e)))}}const r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;const i=this.accumulatedGrads[n].variable;Bd((()=>{const e=$p(i,Mp(r));i.assign(e);const t=$p(Dp(Ap(r,Fp($p(e,kd.backend.epsilon()))),-this.learningRate),s);s.assign(t)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&Wd(this.accumulatedGrads.map((e=>e.variable)))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);this.accumulatedGrads=e.map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}const Xp=Dd({pow_:function(e,t){let n=Rd(e,"base","pow"),s=Rd(t,"exp","pow");[n,s]=fd(n,s);const r={a:n,b:s};return kd.runKernel(tc,r)}});const qp=Dd({sub_:function(e,t){let n=Rd(e,"a","sub"),s=Rd(t,"b","sub");[n,s]=fd(n,s);const r={a:n,b:s};return kd.runKernel(Xc,r)}});class Yp extends Gp{static get className(){return"Adam"}constructor(e,t,n){let s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=s,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],Bd((()=>{this.accBeta1=Pp(t).variable(),this.accBeta2=Pp(n).variable()})),null==s&&(this.epsilon=kd.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);Bd((()=>{const n=qp(1,this.accBeta1),s=qp(1,this.accBeta2);t.forEach(((t,r)=>{const i=kd.registeredVariables[t],a=!1;null==this.accumulatedFirstMoment[r]&&(this.accumulatedFirstMoment[r]={originalName:`${t}/m`,variable:Bd((()=>Op(i).variable(a)))}),null==this.accumulatedSecondMoment[r]&&(this.accumulatedSecondMoment[r]={originalName:`${t}/v`,variable:Bd((()=>Op(i).variable(a)))});const o=Array.isArray(e)?e[r].tensor:e[t];if(null==o)return;const l=this.accumulatedFirstMoment[r].variable,u=this.accumulatedSecondMoment[r].variable,c=$p(Dp(l,this.beta1),Dp(o,1-this.beta1)),h=$p(Dp(u,this.beta2),Dp(Mp(o),1-this.beta2)),d=Ap(c,n),p=Ap(h,s);l.assign(c),u.assign(h);const f=$p(Dp(Ap(d,$p(Fp(p),this.epsilon)),-this.learningRate),i);i.assign(f)})),this.accBeta1.assign(Dp(this.accBeta1,this.beta1)),this.accBeta2.assign(Dp(this.accBeta2,this.beta2))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&Wd(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedSecondMoment&&Wd(this.accumulatedSecondMoment.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e),Bd((()=>{this.accBeta1.assign(Xp(this.beta1,this.iterations_+1)),this.accBeta2.assign(Xp(this.beta2,this.iterations_+1))}));const t=e.length/2,n=!1;this.accumulatedFirstMoment=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedSecondMoment=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}const Qp=Dd({abs_:function(e){const t=Rd(e,"x","abs");if("complex64"===t.dtype){const e={x:t};return kd.runKernel(Tl,e)}{const e={x:t};return kd.runKernel(el,e)}}});function Zp(e,t){const n=e.length,s=[];for(let r=0;r<n;r++){const i=n-1-r,a=e[i]||1;(t[t.length-1-r]||1)>1&&1===a&&s.unshift(i)}return s}function Jp(e,t){const n=[];for(let s=0;s<t.length;s++){const r=e[e.length-s-1],i=t.length-s-1,a=t[i];(null==r||1===r&&a>1)&&n.unshift(i)}return n}function ef(e,t){const n=Math.max(e.length,t.length),s=new Array(n);for(let r=0;r<n;r++){let i=e[e.length-r-1];null==i&&(i=1);let a=t[t.length-r-1];if(null==a&&(a=1),1===i)s[n-r-1]=a;else if(1===a)s[n-r-1]=i;else{if(i!==a){throw Error(`Operands could not be broadcast together with shapes ${e} and ${t}.`)}s[n-r-1]=i}}return s}const tf=Dd({maximum_:function(e,t){let n=Rd(e,"a","maximum"),s=Rd(t,"b","maximum");[n,s]=fd(n,s),"bool"===n.dtype&&(n=_p(n,"int32"),s=_p(s,"int32")),ef(n.shape,s.shape);const r={a:n,b:s};return kd.runKernel(Du,r)}});class nf extends Gp{static get className(){return"Adamax"}constructor(e,t,n){let s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0;super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=s,this.decay=r,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],Bd((()=>{this.iteration=Pp(0).variable(),this.accBeta1=Pp(t).variable()})),null==s&&(this.epsilon=kd.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);Bd((()=>{const n=qp(1,this.accBeta1),s=Ap(-this.learningRate,$p(Dp(this.iteration,this.decay),1));t.forEach(((t,r)=>{const i=kd.registeredVariables[t],a=!1;null==this.accumulatedFirstMoment[r]&&(this.accumulatedFirstMoment[r]={originalName:`${t}/m`,variable:Op(i).variable(a)}),null==this.accumulatedWeightedInfNorm[r]&&(this.accumulatedWeightedInfNorm[r]={originalName:`${t}/v`,variable:Op(i).variable(a)});const o=Array.isArray(e)?e[r].tensor:e[t];if(null==o)return;const l=this.accumulatedFirstMoment[r].variable,u=this.accumulatedWeightedInfNorm[r].variable,c=$p(Dp(l,this.beta1),Dp(o,1-this.beta1)),h=Dp(u,this.beta2),d=Qp(o),p=tf(h,d);l.assign(c),u.assign(p);const f=$p(Dp(Ap(s,n),Ap(c,$p(p,this.epsilon))),i);i.assign(f)})),this.iteration.assign($p(this.iteration,1)),this.accBeta1.assign(Dp(this.accBeta1,this.beta1))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&Wd(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedWeightedInfNorm&&Wd(this.accumulatedWeightedInfNorm.map((e=>e.variable)))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}class sf extends Gp{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const s=Array.isArray(e)?e[n].tensor:e[t];if(null==s)return;const r=kd.registeredVariables[t];Bd((()=>{const e=$p(Dp(this.c,s),r);r.assign(e)}))})),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=Vd(Pp(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(0!==(e=await this.extractIterations(e)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}class rf extends sf{static get className(){return"Momentum"}constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=Pp(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const s=kd.registeredVariables[t];if(null==this.accumulations[n]){const e=!1;this.accumulations[n]={originalName:`${t}/momentum`,variable:Bd((()=>Op(s).variable(e)))}}const r=this.accumulations[n].variable,i=Array.isArray(e)?e[n].tensor:e[t];null!=i&&Bd((()=>{let e;const t=$p(Dp(this.m,r),i);e=this.useNesterov?$p(Dp(this.c,$p(i,Dp(t,this.m))),s):$p(Dp(this.c,t),s),r.assign(t),s.assign(e)}))})),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&Wd(this.accumulations.map((e=>e.variable)))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);this.accumulations=e.map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}class af extends Gp{static get className(){return"RMSProp"}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=s,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=r,null==s&&(this.epsilon=kd.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const s=kd.registeredVariables[t],r=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:`${t}/rms`,variable:Bd((()=>Op(s).variable(r)))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:`${t}/momentum`,variable:Bd((()=>Op(s).variable(r)))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:`${t}/mg`,variable:Bd((()=>Op(s).variable(r)))});const i=Array.isArray(e)?e[n].tensor:e[t];if(null==i)return;const a=this.accumulatedMeanSquares[n].variable,o=this.accumulatedMoments[n].variable;Bd((()=>{const e=$p(Dp(a,this.decay),Dp(Mp(i),1-this.decay));if(this.centered){const t=this.accumulatedMeanGrads[n].variable,r=$p(Dp(t,this.decay),Dp(i,1-this.decay)),l=Ap(Dp(i,this.learningRate),Fp(qp(e,$p(Mp(r),this.epsilon)))),u=$p(Dp(o,this.momentum),l);a.assign(e),t.assign(r),o.assign(u);const c=qp(s,u);s.assign(c)}else{const e=$p(Dp(a,this.decay),Dp(Mp(i),1-this.decay)),t=$p(Dp(o,this.momentum),Ap(Dp(i,this.learningRate),Fp($p(e,this.epsilon))));a.assign(e),o.assign(t);const n=qp(s,t);s.assign(n)}}))})),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&Wd(this.accumulatedMeanSquares.map((e=>e.variable))),null!=this.accumulatedMeanGrads&&this.centered&&Wd(this.accumulatedMeanGrads.map((e=>e.variable))),null!=this.accumulatedMoments&&Wd(this.accumulatedMoments.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedMoments=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.centered&&(this.accumulatedMeanGrads=e.slice(2*t,3*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}const of=[Hp,Kp,Yp,nf,rf,af,sf];function lf(e){return new Promise((e=>setTimeout(e))).then(e)}class uf{constructor(e){if(!qo().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(uf.URL_SCHEME)&&(e=e.slice(uf.URL_SCHEME.length)),null!=e&&0!==e.length||(e="model"),this.modelJsonFileName=e+".json",this.weightDataFileName=e+".weights.bin"}async save(e){if("undefined"===typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=Ld.join(e.weightData),n=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const t=qd(e,[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}]),s=window.URL.createObjectURL(new Blob([JSON.stringify(t)],{type:"application/json"})),r=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(r.download=this.modelJsonFileName,r.href=s,await lf((()=>r.dispatchEvent(new MouseEvent("click")))),null!=e.weightData){const e=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;e.download=this.weightDataFileName,e.href=n,await lf((()=>e.dispatchEvent(new MouseEvent("click"))))}return{modelArtifactsInfo:Qd(e)}}}}uf.URL_SCHEME="downloads://";function cf(e,t,n,s){!function(e){go(null!=e&&Array.isArray(e)&&e.length>0,(()=>"promises must be a none empty array"))}(e),function(e,t){go(e>=0&&e<=1,(()=>`Progress fraction must be in range [0, 1], but got startFraction ${e}`)),go(t>=0&&t<=1,(()=>`Progress fraction must be in range [0, 1], but got endFraction ${t}`)),go(t>=e,(()=>`startFraction must be no more than endFraction, but got startFraction ${e} and endFraction ${t}`))}(n=null==n?0:n,s=null==s?1:s);let r=0;return Promise.all(e.map((i=>(i.then((i=>{const a=n+ ++r/e.length*(s-n);return t(a),i})),i))))}async function hf(e,t){null==t&&(t={});const n=null==t.fetchFunc?qo().platform.fetch:t.fetchFunc,s=e.map((e=>n(e,t.requestInit,{isBinary:!0}))),r=(null==t.onProgress?await Promise.all(s):await cf(s,t.onProgress,0,.5)).map((e=>e.arrayBuffer()));return null==t.onProgress?await Promise.all(r):await cf(r,t.onProgress,.5,1)}Jd.registerSaveRouter((e=>qo().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(uf.URL_SCHEME)?function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"model";return new uf(e)}(e.slice(uf.URL_SCHEME.length)):null));class df{constructor(e,t){if(this.DEFAULT_METHOD="POST",null==t&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,null!=t.fetchFunc?(go("function"===typeof t.fetchFunc,(()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")),this.fetch=t.fetchFunc):this.fetch=qo().platform.fetch,go(null!=e&&e.length>0,(()=>"URL path for http must not be null, undefined or empty.")),Array.isArray(e)&&go(2===e.length,(()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`)),this.path=e,null!=t.requestInit&&null!=t.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const n=qd(e,[{paths:["./model.weights.bin"],weights:e.weightSpecs}]);if(t.body.append("model.json",new Blob([JSON.stringify(n)],{type:"application/json"}),"model.json"),null!=e.weightData){const n=Ld.join(e.weightData);t.body.append("model.weights.bin",new Blob([n],{type:"application/octet-stream"}),"model.weights.bin")}const s=await this.fetch(this.path,t);if(s.ok)return{modelArtifactsInfo:Qd(e),responses:[s]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${s.status}.`)}async loadModelJSON(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch(r){let e=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?e+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":e+=" Please make sure the server is serving valid JSON for this request.",new Error(e)}const n=t.modelTopology,s=t.weightsManifest;if(null==n&&null==s)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return t}async load(){if(this.loadOptions.streamWeights)return this.loadStream();return Yd(await this.loadModelJSON(),(e=>this.loadWeights(e)))}async loadStream(){const e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),n=Zd(e.weightsManifest);return Object.assign(Object.assign({},e),{weightSpecs:n,getWeightStream:()=>function(e,t){var n;const s=null==t.fetchFunc?qo().platform.fetch:t.fetchFunc;let r,i=0;return null===(n=t.onProgress)||void 0===n||n.call(t,0),new ReadableStream({pull:async n=>{for(var a;i<e.length;){if(!r){const n=(await s(e[i],t.requestInit,{isBinary:!0})).body;r=n.getReader()}const{done:o,value:l}=await r.read();if(!o)return void n.enqueue(l);i++,r=void 0,null===(a=t.onProgress)||void 0===a||a.call(t,i/e.length)}n.close()}})}(t,this.loadOptions)})}async getWeightUrls(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[n,s]=function(e){const t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),s=e.substring(0,t),r=n>t?e.substring(n):"";return[s+"/",r]}(t),r=this.weightPathPrefix||n,i=[],a=[];for(const o of e)for(const e of o.paths)null!=this.weightUrlConverter?a.push(this.weightUrlConverter(e)):i.push(r+e+s);return this.weightUrlConverter&&i.push(...await Promise.all(a)),i}async loadWeights(e){const t=await this.getWeightUrls(e);return[Zd(e),await hf(t,this.loadOptions)]}}function pf(e){return null!=e.match(df.URL_SCHEME_REGEX)}df.URL_SCHEME_REGEX=/^https?:\/\//;const ff=(e,t)=>{if("undefined"===typeof fetch&&(null==t||null==t.fetchFunc))return null;{let n=!0;if(n=Array.isArray(e)?e.every((e=>pf(e))):pf(e),n)return gf(e,t)}return null};function gf(e,t){return new df(e,t)}Jd.registerSaveRouter(ff),Jd.registerLoadRouter(ff);const mf=-2,bf=-1;function xf(e,t,n){const s=e.shape.length;go(s===t.length,(()=>`Error in slice${s}D: Length of begin ${t} must match the rank of the array (${s}).`)),go(s===n.length,(()=>`Error in slice${s}D: Length of size ${n} must match the rank of the array (${s}).`));for(let r=0;r<s;++r)go(t[r]+n[r]<=e.shape[r],(()=>`Error in slice${s}D: begin[${r}] + size[${r}] (${t[r]+n[r]}) would overflow input.shape[${r}] (${e.shape[r]})`))}function yf(e){const t=[];let n=0;for(;e>0;)1&e&&t.push(n),e/=2,n++;return t}function vf(e,t,n){const s=[];for(let r=0;r<e.length;r++)s[r]=Math.ceil((t[r]-e[r])/n[r]);return s}function wf(e,t,n,s){const r=[...e];for(let i=r.length;i<s.length;i++)r.push(1);for(let i=0;i<n;i++)0===i?r[t]=1:(r.splice(t,0,1),r.pop());return r}function kf(e,t,n){return n<=e?n:n-(t-1)}function Sf(e,t){const n=[];for(let s=0;s<e;s++)n.push(t+s);return n}function If(e,t,n,s,r,i,a,o,l){const u=e.length;let c=new Array(u),h=new Array(u),d=new Array(u);if(t.length&&n>0){const l=t[0],u=n+1;c=Cf(a,l,u,s,e),h=Nf(o,l,u,r,e),d=wf(i,l,u,e)}else for(let p=0;p<u;p++)c[p]=_f(a,s,i,e,p,l),h[p]=Ef(o,r,i,e,p,l),d[p]=Tf(i,p,l);return{begin:c,end:h,strides:d}}function Cf(e,t,n,s,r){const i=[...r],a=Sf(n,t);for(let o=0;o<i.length;o++)if(a.indexOf(o)>-1)i[o]=0;else{const r=kf(t,n,o);let a=s[r];e&1<<r&&(a=0),i[o]=a}return i}function Nf(e,t,n,s,r){const i=[...r],a=Sf(n,t);for(let o=0;o<i.length;o++)if(a.indexOf(o)>-1)i[o]=Number.MAX_SAFE_INTEGER;else{const r=kf(t,n,o);let a=s[r];e&1<<r&&(a=Number.MAX_SAFE_INTEGER),i[o]=a}for(let o=0;o<i.length;o++){const e=r[o];i[o]<0&&(i[o]+=e),i[o]=ho(0,i[o],r[o])}return i}function Tf(e,t,n){let s=e[t];return(n&1<<t||null==s)&&(s=1),s}function _f(e,t,n,s,r,i){let a=t[r];const o=n[r]||1;(e&1<<r||i&1<<r||null==a)&&(a=o>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const l=s[r];return a<0&&(a+=l),a=ho(0,a,l-1),a}function Ef(e,t,n,s,r,i){let a=t[r];const o=n[r]||1;(e&1<<r||i&1<<r||null==a)&&(a=o>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const l=s[r];return a<0&&(a+=l),a=o>0?ho(0,a,l):ho(-1,a,l-1),a}function $f(e,t,n){let s=n.length;for(let r=0;r<n.length;r++)if(n[r]>1){s=r;break}for(let r=s+1;r<n.length;r++)if(t[r]>0||n[r]!==e[r])return!1;return!0}function Rf(e,t){let n=e.length>0?e[e.length-1]:1;for(let s=0;s<e.length-1;s++)n+=e[s]*t[s];return n}function Af(e,t,n){let s;const r=e.shape.length;let i;return s="number"===typeof t?[t,...new Array(r-1).fill(0)]:t.length<r?t.concat(new Array(r-t.length).fill(0)):t.slice(),s.forEach((e=>{go(-1!==e,(()=>"slice() does not support negative begin indexing."))})),i=null==n?new Array(r).fill(-1):"number"===typeof n?[n,...new Array(r-1).fill(-1)]:n.length<r?n.concat(new Array(r-n.length).fill(-1)):n,i=i.map(((t,n)=>t>=0?t:(go(-1===t,(()=>`Negative size values should be exactly -1 but got ${t} for the slice() size at index ${n}.`)),e.shape[n]-s[n]))),[s,i]}function Df(e,t,n,s,r,i,a,o,l){let u;if(null==s?(u=new Array(t.length),u.fill(1)):u=s,null!=a&&0!==(a&a-1))throw new Error("Multiple ellipses in slice is not allowed.");let c=!1;const h={dims:u.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:u.slice(),beginMask:r,endMask:i,ellipsisMask:a,newAxisMask:o,shrinkAxisMask:l};for(let x=0;x<h.dims;x++)c&&0!==(1<<x&o)&&h.numAddAxisAfterEllipsis++,1<<x&a&&(c=!0);c||(h.ellipsisMask|=1<<h.dims,h.dims++);const d={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=null!=e.begin,t.endValid=null!=e.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let s=0;s<e.dims;s++)if(1<<s&e.ellipsisMask){const r=Math.min(t.dims-(e.dims-s)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<r;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=s}else if(1<<s&e.newAxisMask)t.finalShapeGatherIndices.push(mf),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${t.dims} dims, ${t.begin.length}.`);null!=e.begin&&(t.begin[n]=e.begin[s]),null!=e.end&&(t.end[n]=e.end[s]),t.strides[n]=e.strides[s],e.beginMask&1<<s&&(t.beginMask|=1<<n),e.endMask&1<<s&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<s?(t.finalShapeGatherIndices.push(bf),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(s)),t.inputShapeGatherIndicesSparse[n]=s,n++}}(h,d);let p=!0,f=!0,g=!0;const m=[],b=[];for(let x=0;x<e.length;++x){if(0===d.strides[x])throw Error(`strides[${x}] must be non-zero`);const t=!!(d.shrinkAxisMask&1<<x),n=e[x];if(-1===n){m.push(t?1:-1);continue}const s=[d.beginMask&1<<x,d.endMask&1<<x],r=[d.strides[x]>0?0:-1,d.strides[x]>0?n:n-1];if(t&&d.strides[x]<=0)throw Error("only stride 1 allowed on non-range indexing.");g=g&&1===d.strides[x];const i=!!(d.beginMask&1<<x&&d.endMask&1<<x);if(d.beginValid&&d.endValid){if(t){const e=d.begin[x]<0?n+d.begin[x]:d.begin[x];if(d.begin[x]=e,d.end[x]=d.begin[x]+1,e<0||e>=n)throw Error(`slice index ${d.begin[x]} of dimension ${x} out of bounds.`)}else d.begin[x]=Ff(d.begin[x],0,d.strides[x],n,s,r),d.end[x]=Ff(d.end[x],1,d.strides[x],n,s,r);const e=1===d.strides[x]&&0===d.begin[x]&&d.end[x]===n;p=p&&e,f=f&&(0===x&&1===d.strides[x]||e)}else p=p&&1===d.strides[x]&&i,f=f&&(0===x&&1===d.strides[x]||i);let a,o=!1;if(d.beginValid&&d.endValid?(a=d.end[x]-d.begin[x],o=!0):t?(a=1,o=!0):i&&n>=0&&(a=d.strides[x]<0?-n:n,o=!0),o){let e;e=0===a||a<0!==d.strides[x]<0?0:Math.trunc(a/d.strides[x])+(a%d.strides[x]!==0?1:0),m.push(e)}else m.push(-1)}for(let x=0;x<d.finalShapeGatherIndices.length;++x){const e=d.finalShapeGatherIndices[x];e>=0?b.push(m[e]):e===mf&&b.push(1)}return{finalShapeSparse:b.filter(((e,t)=>d.finalShapeGatherIndices[t]!==mf)),finalShape:b,isIdentity:p,sliceDim0:f,isSimpleSlice:g,begin:d.begin,end:d.end,strides:d.strides}}function Ff(e,t,n,s,r,i){if(r[t])return n>0?i[t]:i[t+1&1];{const t=e<0?s+e:e;return t<i[0]?i[0]:t>i[1]?i[1]:t}}const Mf=Dd({all_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const s={x:Rd(e,"x","all","bool")},r={axis:t,keepDims:n};return kd.runKernel(il,s,r)}});const Of=Dd({any_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const s={x:Rd(e,"x","any","bool")},r={axis:t,keepDims:n};return kd.runKernel(al,s,r)}});const Lf=Dd({argMax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:Rd(e,"x","argMax")},s={axis:t};return kd.runKernel(ol,n,s)}});function Pf(e,t,n,s){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",i=arguments.length>5?arguments[5]:void 0;return Wf(e,[...t,e[3]],n,i,s,null,null,Qf(r))}function zf(e,t,n,s,r,i){let a=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"channelsLast";const[o,l]=Gf(t);let u;if("channelsLast"===a)u=[o,l,e[3],e[3]];else{if("channelsFirst"!==a)throw new Error(`Unknown dataFormat ${a}`);u=[o,l,e[1],e[1]]}return Wf(e,u,n,s,r,i,!1,a)}function Bf(e,t,n,s,r,i){let a=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NDHWC";const[o,l,u]=Hf(t);let c,h;if("NDHWC"===a)h="channelsLast",c=[o,l,u,e[4],e[4]];else{if("NCDHW"!==a)throw new Error(`Unknown dataFormat ${a}`);h="channelsFirst",c=[o,l,u,e[1],e[1]]}return Vf(e,c,n,s,r,!1,h,i)}function Wf(e,t,n,s,r,i){let a=arguments.length>6&&void 0!==arguments[6]&&arguments[6],o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:"channelsLast",[l,u,c,h]=[-1,-1,-1,-1];if("channelsLast"===o)[l,u,c,h]=e;else{if("channelsFirst"!==o)throw new Error(`Unknown dataFormat ${o}`);[l,h,u,c]=e}const[d,p,,f]=t,[g,m]=Gf(n),[b,x]=Gf(s),y=jf(d,b),v=jf(p,x),{padInfo:w,outHeight:k,outWidth:S}=function(e,t,n,s,r,i,a,o,l){let u,c,h;if("number"===typeof e){u={top:e,bottom:e,left:e,right:e,type:0===e?"VALID":"NUMBER"};const r=function(e,t,n,s,r){null==s&&(s=Uf(e,t,n));const i=e[0],a=e[1],o=Kf((i-t+2*s)/n+1,r),l=Kf((a-t+2*s)/n+1,r);return[o,l]}([t,n],i,s,e,o);c=r[0],h=r[1]}else if("same"===e){c=Math.ceil(t/s),h=Math.ceil(n/r);const e=Math.max(0,(c-1)*s+i-t),o=Math.max(0,(h-1)*r+a-n),l=Math.floor(e/2),d=e-l,p=Math.floor(o/2);u={top:l,bottom:d,left:p,right:o-p,type:"SAME"}}else if("valid"===e)u={top:0,bottom:0,left:0,right:0,type:"VALID"},c=Math.ceil((t-i+1)/s),h=Math.ceil((n-a+1)/r);else{if("object"!==typeof e)throw Error(`Unknown padding parameter: ${e}`);{const d="channelsLast"===l?e[1][0]:e[2][0],p="channelsLast"===l?e[1][1]:e[2][1],f="channelsLast"===l?e[2][0]:e[3][0],g="channelsLast"===l?e[2][1]:e[3][1];u={top:d,bottom:p,left:f,right:g,type:0===d&&0===p&&0===f&&0===g?"VALID":"EXPLICIT"},c=Kf((t-i+d+p)/s+1,o),h=Kf((n-a+f+g)/r+1,o)}}return{padInfo:u,outHeight:c,outWidth:h}}(r,u,c,g,m,y,v,i,o),I=a?f*h:f;let C;return"channelsFirst"===o?C=[l,I,k,S]:"channelsLast"===o&&(C=[l,k,S,I]),{batchSize:l,dataFormat:o,inHeight:u,inWidth:c,inChannels:h,outHeight:k,outWidth:S,outChannels:I,padInfo:w,strideHeight:g,strideWidth:m,filterHeight:d,filterWidth:p,effectiveFilterHeight:y,effectiveFilterWidth:v,dilationHeight:b,dilationWidth:x,inShape:e,outShape:C,filterShape:t}}function Vf(e,t,n,s,r){let i=arguments.length>5&&void 0!==arguments[5]&&arguments[5],a=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"channelsLast",o=arguments.length>7?arguments[7]:void 0,[l,u,c,h,d]=[-1,-1,-1,-1,-1];if("channelsLast"===a)[l,u,c,h,d]=e;else{if("channelsFirst"!==a)throw new Error(`Unknown dataFormat ${a}`);[l,d,u,c,h]=e}const[p,f,g,,m]=t,[b,x,y]=Hf(n),[v,w,k]=Hf(s),S=jf(p,v),I=jf(f,w),C=jf(g,k),{padInfo:N,outDepth:T,outHeight:_,outWidth:E}=function(e,t,n,s,r,i,a,o,l,u,c){let h,d,p,f;"valid"===e&&(e=0);if("number"===typeof e){h={top:e,bottom:e,left:e,right:e,front:e,back:e,type:0===e?"VALID":"NUMBER"};const g=function(e,t,n,s,r,i){null==r&&(r=Uf(e,t[0],s[0]));const a=[0,0,0,n];for(let o=0;o<3;o++)e[o]+2*r>=t[o]&&(a[o]=Kf((e[o]-t[o]+2*r)/s[o]+1,i));return a}([t,n,s,1],[o,l,u],1,[r,i,a],e,c);d=g[0],p=g[1],f=g[2]}else{if("same"!==e)throw Error(`Unknown padding parameter: ${e}`);{d=Math.ceil(t/r),p=Math.ceil(n/i),f=Math.ceil(s/a);const e=(d-1)*r+o-t,c=(p-1)*i+l-n,g=(f-1)*a+u-s,m=Math.floor(e/2),b=e-m,x=Math.floor(c/2),y=c-x,v=Math.floor(g/2);h={top:x,bottom:y,left:v,right:g-v,front:m,back:b,type:"SAME"}}}return{padInfo:h,outDepth:d,outHeight:p,outWidth:f}}(r,u,c,h,b,x,y,S,I,C,o),$=i?m*d:m;let R;return"channelsFirst"===a?R=[l,$,T,_,E]:"channelsLast"===a&&(R=[l,T,_,E,$]),{batchSize:l,dataFormat:a,inDepth:u,inHeight:c,inWidth:h,inChannels:d,outDepth:T,outHeight:_,outWidth:E,outChannels:$,padInfo:N,strideDepth:b,strideHeight:x,strideWidth:y,filterDepth:p,filterHeight:f,filterWidth:g,effectiveFilterDepth:S,effectiveFilterHeight:I,effectiveFilterWidth:C,dilationDepth:v,dilationHeight:w,dilationWidth:k,inShape:e,outShape:R,filterShape:t}}function Uf(e,t,n){const s=jf(t,arguments.length>3&&void 0!==arguments[3]?arguments[3]:1);return Math.floor((e[0]*(n-1)-n+s)/2)}function Gf(e){return"number"===typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function Hf(e){return"number"===typeof e?[e,e,e]:e}function jf(e,t){return t<=1?e:e+(e-1)*(t-1)}function Kf(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function Xf(e){const[t,n,s]=Gf(e);return 1===t&&1===n&&1===s}function qf(e,t){return Xf(e)||Xf(t)}function Yf(e){return Gf(e).every((e=>e>0))}function Qf(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function Zf(e,t,n){if(null!=n){if("string"===typeof t)throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if("number"===typeof t)go(vo(t),(()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`));else{if("object"!==typeof t)throw Error(`Error in ${e}: Unknown padding parameter: ${t}`);t.forEach((t=>{t.forEach((t=>{go(vo(t),(()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`))}))}))}}}const Jf=Dd({reshape_:function(e,t){const n={x:Rd(e,"x","reshape","string_or_numeric")},s={shape:t};return kd.runKernel(hc,n,s)}});const eg=Dd({avgPool_:function(e,t,n,s,r){const i=Rd(e,"x","avgPool","float32");go(qf(n,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`));let a=i,o=!1;3===i.rank&&(o=!0,a=Jf(i,[1,i.shape[0],i.shape[1],i.shape[2]])),go(4===a.rank,(()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`)),Zf("avgPool",s,r);const l={x:a},u={filterSize:t,strides:n,pad:s,dimRoundingMode:r};let c=kd.runKernel(fl,l,u);return c=_p(c,i.dtype),o?Jf(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});const tg=Dd({avgPool3d_:function(e,t,n,s,r){let i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC";const a=Rd(e,"x","avgPool3d","float32");let o=a,l=!1;4===a.rank&&(l=!0,o=Jf(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),go(5===o.rank,(()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`)),go("NDHWC"===i,(()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`)),go("number"===typeof n&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,(()=>`Error in avgPool3d: Stride must be > 0, but got '${n}'`)),Zf("avgPool3d",s,r);const u={x:o},c={filterSize:t,strides:n,pad:s,dimRoundingMode:r,dataFormat:i};let h=kd.runKernel(ml,u,c);return h=_p(h,o.dtype),l?Jf(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});const ng=Dd({batchNorm_:function(e,t,n,s,r,i){null==i&&(i=.001);const a=Rd(e,"x","batchNorm"),o=Rd(t,"mean","batchNorm"),l=Rd(n,"variance","batchNorm");let u,c;null!=r&&(u=Rd(r,"scale","batchNorm")),null!=s&&(c=Rd(s,"offset","batchNorm")),go(o.rank===l.rank,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),go(null==c||o.rank===c.rank,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),go(null==u||o.rank===u.rank,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));const h={x:function(e){let t;return t=0===e.rank||1===e.rank?Jf(e,[1,1,1,e.size]):2===e.rank?Jf(e,[1,1,e.shape[0],e.shape[1]]):3===e.rank?Jf(e,[1,e.shape[0],e.shape[1],e.shape[2]]):e,t}(a),scale:u,offset:c,mean:o,variance:l},d={varianceEpsilon:i},p=kd.runKernel(cu,h,d);return Jf(p,a.shape)}});const sg=Dd({batchNorm2d_:function(e,t,n,s,r,i){const a=Rd(e,"x","batchNorm"),o=Rd(t,"mean","batchNorm"),l=Rd(n,"variance","batchNorm");let u,c;return null!=r&&(u=Rd(r,"scale","batchNorm")),null!=s&&(c=Rd(s,"offset","batchNorm")),go(2===a.rank,(()=>`Error in batchNorm2D: x must be rank 2 but got rank ${a.rank}.`)),go(2===o.rank||1===o.rank,(()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`)),go(2===l.rank||1===l.rank,(()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`)),null!=u&&go(2===u.rank||1===u.rank,(()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${u.rank}.`)),null!=c&&go(2===c.rank||1===c.rank,(()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${c.rank}.`)),ng(a,o,l,c,u,i)}});const rg=Dd({batchNorm3d_:function(e,t,n,s,r,i){const a=Rd(e,"x","batchNorm"),o=Rd(t,"mean","batchNorm"),l=Rd(n,"variance","batchNorm");let u,c;return null!=r&&(u=Rd(r,"scale","batchNorm")),null!=s&&(c=Rd(s,"offset","batchNorm")),go(3===a.rank,(()=>`Error in batchNorm3D: x must be rank 3 but got rank ${a.rank}.`)),go(3===o.rank||1===o.rank,(()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`)),go(3===l.rank||1===l.rank,(()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`)),null!=u&&go(3===u.rank||1===u.rank,(()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${u.rank}.`)),null!=c&&go(3===c.rank||1===c.rank,(()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${c.rank}.`)),ng(a,o,l,c,u,i)}});const ig=Dd({batchNorm4d_:function(e,t,n,s,r,i){const a=Rd(e,"x","batchNorm"),o=Rd(t,"mean","batchNorm"),l=Rd(n,"variance","batchNorm");let u,c;return null!=r&&(u=Rd(r,"scale","batchNorm")),null!=s&&(c=Rd(s,"offset","batchNorm")),go(4===a.rank,(()=>`Error in batchNorm4D: x must be rank 4 but got rank ${a.rank}.`)),go(4===o.rank||1===o.rank,(()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`)),go(4===l.rank||1===l.rank,(()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`)),null!=u&&go(4===u.rank||1===u.rank,(()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${u.rank}.`)),null!=c&&go(4===c.rank||1===c.rank,(()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${c.rank}.`)),ng(a,o,l,c,u,i)}});const ag=Dd({broadcastTo_:function(e,t){let n=Rd(e,"broadcastTo","x");const s=n.shape;if(Vo(t),t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){const e=n.shape.slice();for(;e.length<t.length;)e.unshift(1);n=Jf(n,e)}const r=n.shape,i=Array.from(t);for(let l=t.length-1;l>=0;l--)if(r[l]===t[l])i[l]=1;else if(1!==n.shape[l])throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${t}].`);if(0===i.map(((e,t)=>e>1?t:-1)).filter((e=>e>=0)).length)return Ep(n);const a={x:n},o={reps:i};return kd.runKernel(Qc,a,o)}});const og=Dd({clipByValue_:function(e,t,n){const s=Rd(e,"x","clipByValue");if(go(t<=n,(()=>`Error in clip: min (${t}) must be less than or equal to max (${n}).`)),t===n)return jp(s.shape,t,s.dtype);const r={x:s},i={clipValueMin:t,clipValueMax:n};return kd.runKernel(Cl,r,i)}});const lg=Dd({concat_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;go(e.length>=1,(()=>"Pass at least one tensor to concat"));const n=Ad(e,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach((e=>{if("complex64"!==e.dtype)throw new Error(`Cannot concatenate complex64 tensors with a tensor\n          with dtype ${e.dtype}. `)})),1===n.length)return Ep(n[0]);const s=n,r={axis:t};return kd.runKernel(_l,s,r)}});const ug=Dd({concat1d_:function(e){return lg(e,0)}});const cg=Dd({concat2d_:function(e,t){return lg(e,t)}});const hg=Dd({concat3d_:function(e,t){return lg(e,t)}});const dg=Dd({concat4d_:function(e,t){return lg(e,t)}});const pg=Dd({conv2d_:function(e,t,n,s){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],a=arguments.length>6?arguments[6]:void 0;const o=Rd(e,"x","conv2d","float32"),l=Rd(t,"filter","conv2d","float32");let u=o,c=!1;3===o.rank&&(c=!0,u=Jf(o,[1,o.shape[0],o.shape[1],o.shape[2]])),go(4===u.rank,(()=>`Error in conv2d: input must be rank 4, but got rank ${u.rank}.`)),go(4===l.rank,(()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`)),Zf("conv2d",s,a);const h="NHWC"===r?u.shape[3]:u.shape[1];go(h===l.shape[2],(()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${l.shape[2]}.`)),go(qf(n,i),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`)),go(Yf(i),(()=>"Error in conv2D: Dilated rates should be larger than 0.")),go(Yf(n),(()=>"Error in conv2D: Strides should be larger than 0."));const d={x:u,filter:l},p={strides:n,pad:s,dataFormat:r,dilations:i,dimRoundingMode:a},f=kd.runKernel(El,d,p);return c?Jf(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const fg=Dd({conv1d_:function(e,t,n,s){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NWC",i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,a=arguments.length>6?arguments[6]:void 0;const o=Rd(e,"x","conv1d"),l=Rd(t,"filter","conv1d");let u=o,c=!1;2===o.rank&&(c=!0,u=Jf(o,[1,o.shape[0],o.shape[1]])),go(3===u.rank,(()=>`Error in conv1d: input must be rank 3, but got rank ${u.rank}.`)),go(3===l.rank,(()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`)),Zf("conv1d",s,a),go(u.shape[2]===l.shape[1],(()=>`Error in conv1d: depth of input (${u.shape[2]}) must match input depth for filter ${l.shape[1]}.`)),go(qf(n,i),(()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${i}'`)),go(Yf(i),(()=>"Error in conv1D: Dilated rates should be larger than 0.")),go(Yf(n),(()=>"Error in conv1D: Stride should be larger than 0.")),go("NWC"===r,(()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`));const h=Jf(l,[1,l.shape[0],l.shape[1],l.shape[2]]),d=Jf(u,[u.shape[0],1,u.shape[1],u.shape[2]]),p=pg(d,h,[1,n],s,"NHWC",[1,i],a);return Jf(p,c?[p.shape[2],p.shape[3]]:[p.shape[0],p.shape[2],p.shape[3]])}});const gg=Dd({conv2DBackpropInput_:function(e,t,n,s,r){let i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",a=arguments.length>6?arguments[6]:void 0;go(e.length===t.rank,(()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));let o=e,l=t,u=!1;3===t.rank&&(u=!0,l=Jf(t,[1,t.shape[0],t.shape[1],t.shape[2]]),o=[1,e[0],e[1],e[2]]),go(4===o.length,(()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`)),go(4===l.rank,(()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`)),go(4===n.rank,(()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`));const c="NHWC"===i?o[3]:o[1],h="NHWC"===i?l.shape[3]:l.shape[1];go(c===n.shape[2],(()=>`Error in conv2dDerInput: depth of input (${c}) must match input depth for filter ${n.shape[2]}.`)),go(h===n.shape[3],(()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${n.shape[3]}.`)),Zf("conv2dDerInput",r,a);const d={dy:l,filter:n},p={strides:s,pad:r,dataFormat:i,dimRoundingMode:a,inputShape:o},f=kd.runKernel(Rl,d,p);return u?Jf(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const mg=Dd({conv2dTranspose_:function(e,t,n,s,r,i){const a=Rd(e,"x","conv2dTranspose"),o=Rd(t,"filter","conv2dTranspose");return gg(n,a,o,s,r,"NHWC",i)}});const bg=Dd({conv3d_:function(e,t,n,s){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NDHWC",i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1,1];const a=Rd(e,"x","conv3d"),o=Rd(t,"filter","conv3d");let l=a,u=!1;4===a.rank&&(u=!0,l=Jf(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),go(5===l.rank,(()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`)),go(5===o.rank,(()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`)),go(l.shape[4]===o.shape[3],(()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${o.shape[3]}.`)),go(qf(n,i),(()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${i}'`)),go("NDHWC"===r,(()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`)),go(Yf(i),(()=>"Error in conv3D: Dilated rates should be larger than 0.")),go(Yf(n),(()=>"Error in conv3D: Strides should be larger than 0."));const c={x:l,filter:o},h={strides:n,pad:s,dataFormat:r,dilations:i},d=kd.runKernel(Al,c,h);return u?Jf(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});const xg=Dd({conv3DBackpropInput_:function(e,t,n,s,r){go(e.length===t.rank,(()=>`Length of inShape (${e.length}) and rank of dy (${t.rank}) must match`));let i=e,a=t,o=!1;4===t.rank&&(o=!0,a=Jf(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),i=[1,e[0],e[1],e[2],e[3]]);const l=i[4],u=a.shape[4];go(5===i.length,(()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${i.length}.`)),go(5===a.rank,(()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${a.rank}`)),go(5===n.rank,(()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`)),go(l===n.shape[3],(()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`)),go(u===n.shape[4],(()=>`Error in conv3dDerInput: depth of output (${u}) must match output depth for filter ${n.shape[4]}.`));const c={dy:a,filter:n},h={pad:r,strides:s,inputShape:i},d=kd.runKernel(Fl,c,h);return o?Jf(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});const yg=Dd({conv3dTranspose_:function(e,t,n,s,r){const i=Rd(e,"x","conv3dTranspose"),a=Rd(t,"filter","conv3dTranspose");return xg(n,i,a,s,r)}});const vg=Dd({denseBincount_:function(e,t,n){let s=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=Rd(e,"x","denseBincount"),i=Rd(t,"weights","denseBincount");go("int32"===r.dtype,(()=>`Error in denseBincount: input dtype must be int32, but got ${r.dtype}`)),go(r.rank<=2,(()=>`Error in denseBincount: input must be at most rank 2, but got rank ${r.rank}.`)),go(n>=0,(()=>`size must be non-negative, but got ${n}.`)),go(i.size===r.size||0===i.size,(()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${r.shape}, weights shape: ${i.shape}.`));const a={x:r,weights:i},o={size:n,binaryOutput:s};return kd.runKernel(Bl,a,o)}});const wg=Dd({depthwiseConv2d_:function(e,t,n,s){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],a=arguments.length>6?arguments[6]:void 0;const o=Rd(e,"x","depthwiseConv2d","float32"),l=Rd(t,"filter","depthwiseConv2d","float32");let u=o,c=!1;3===o.rank&&(c=!0,u=Jf(o,[1,o.shape[0],o.shape[1],o.shape[2]])),go(4===u.rank,(()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${u.rank}.`)),go(4===l.rank,(()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`));const h="NHWC"===r?u.shape[3]:u.shape[1];go(h===l.shape[2],(()=>`Error in depthwiseConv2d: number of input channels (${h}) must match the inChannels dimension in filter ${l.shape[2]}.`)),Zf("depthwiseConv2d",s,a);const d={x:u,filter:l},p={strides:n,pad:s,dataFormat:r,dilations:i,dimRoundingMode:a},f=kd.runKernel(Vl,d,p);return c?Jf(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const kg=Dd({elu_:function(e){const t={x:Rd(e,"x","elu","float32")};return kd.runKernel(Zl,t)}});const Sg=Dd({equal_:function(e,t){let n=Rd(e,"a","equal","string_or_numeric"),s=Rd(t,"b","equal","string_or_numeric");[n,s]=fd(n,s),ef(n.shape,s.shape);const r={a:n,b:s};return kd.runKernel(tu,r)}});const Ig=Dd({erf_:function(e){let t=Rd(e,"x","erf");go("int32"===t.dtype||"float32"===t.dtype,(()=>"Input dtype must be `int32` or `float32`.")),"int32"===t.dtype&&(t=_p(t,"float32"));const n={x:t};return kd.runKernel(eu,n)}});const Cg=Dd({exp_:function(e){const t={x:Rd(e,"x","exp")};return kd.runKernel(nu,t)}});const Ng=Dd({expandDims_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=Rd(e,"x","expandDims","string_or_numeric");go(t<=n.rank,(()=>"Axis must be <= rank of the tensor"));const s={input:n},r={dim:t};return kd.runKernel(su,s,r)}});const Tg=Dd({tile_:function(e,t){const n=Rd(e,"x","tile","string_or_numeric");go(n.rank===t.length,(()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${t}.`));const s={x:n},r={reps:t};return kd.runKernel(Qc,s,r)}});const _g=Dd({eye_:function(e,t,n){null==t&&(t=e);const s=Tp([e,t],arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32"),r=e<=t?e:t;for(let a=0;a<r;++a)s.set(1,a,a);const i=Jf(s.toTensor(),[e,t]);if(null==n)return i;if(1===n.length)return Tg(Ng(i,0),[n[0],1,1]);if(2===n.length)return Tg(Ng(Ng(i,0),0),[n[0],n[1],1,1]);if(3===n.length)return Tg(Ng(Ng(Ng(i,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}});const Eg=Dd({floor_:function(e){const t={x:Rd(e,"x","floor","float32")};return kd.runKernel(lu,t)}});const $g=Dd({gather_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const r={x:Rd(e,"x","gather"),indices:Rd(t,"indices","gather","int32")},i={axis:n,batchDims:s};return kd.runKernel(hu,r,i)}});const Rg=Dd({greater_:function(e,t){let n=Rd(e,"a","greater","string_or_numeric"),s=Rd(t,"b","greater","string_or_numeric");[n,s]=fd(n,s),ef(n.shape,s.shape);const r={a:n,b:s};return kd.runKernel(pu,r)}});const Ag=Dd({greaterEqual_:function(e,t){let n=Rd(e,"a","greaterEqual","string_or_numeric"),s=Rd(t,"b","greaterEqual","string_or_numeric");[n,s]=fd(n,s),ef(n.shape,s.shape);const r={a:n,b:s};return kd.runKernel(fu,r)}});const Dg=Dd({leakyRelu_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.2;const n={x:Rd(e,"x","leakyRelu")},s={alpha:t};return kd.runKernel(wu,n,s)}});const Fg=Dd({log_:function(e){const t={x:Rd(e,"x","log","float32")};return kd.runKernel(Cu,t)}});const Mg=Dd({log1p_:function(e){const t={x:Rd(e,"x","log1p")};return kd.runKernel(Nu,t)}});const Og=Dd({max_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const s={x:Rd(e,"x","max")},r={reductionIndices:t,keepDims:n};return kd.runKernel(Au,s,r)}});const Lg=Dd({sum_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],s=Rd(e,"x","sum");"bool"===s.dtype&&(s=_p(s,"int32"));const r={x:s},i={axis:t,keepDims:n};return kd.runKernel(Ac,r,i)}});const Pg=Dd({logSoftmax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=Rd(e,"logits","logSoftmax");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${t}`);const s=Lp(((e,n)=>{const s=Og(e,t,!0),r=qp(e,s),i=qp(_p(r,"float32"),Fg(Lg(Cg(r),t,!0)));n([i]);return{value:i,gradFunc:(e,n)=>{const[s]=n,r=Cg(s);return qp(e,Dp(Lg(e,t,!0),r))}}}));return s(n)}});function zg(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function Bg(e,t,n){const s=e.length+t.length,r=[];let i=0,a=0;for(let o=0;o<s;o++)-1===n.indexOf(o)?r.push(e[i++]):r.push(t[a++]);return r}function Wg(e,t){const n=[],s=e.length;for(let r=0;r<s;r++)-1===t.indexOf(r)&&n.push(e[r]);return[n,t.map((t=>e[t]))]}function Vg(e,t){return Bg(e,t.map((e=>1)),t)}function Ug(e,t,n){go(zg(t,n),(()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`))}function Gg(e,t){if(zg(e,t))return null;const n=[];for(let s=0;s<t;++s)-1===e.indexOf(s)&&n.push(s);return e.forEach((e=>n.push(e))),n}function Hg(e){return e.map(((e,t)=>[t,e])).sort(((e,t)=>e[1]-t[1])).map((e=>e[0]))}function jg(e,t){const n=[];for(let s=t-e;s<t;++s)n.push(s);return n}const Kg=Dd({logSumExp_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const s=Rd(e,"x","logSumExp"),r=Co(t,s.shape),i=Og(s,r,!0),a=qp(s,i),o=Cg(a),l=Lg(o,r),u=Fg(l),c=$p(Jf(i,u.shape),u);if(n){const e=Vg(c.shape,r);return Jf(c,e)}return c}});const Xg=Dd({logicalAnd_:function(e,t){const n=Rd(e,"a","logicalAnd","bool"),s=Rd(t,"b","logicalAnd","bool");ef(n.shape,s.shape);const r={a:n,b:s};return kd.runKernel(Tu,r)}});const qg=Dd({matMul_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],s=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=Rd(e,"a","matMul"),i=Rd(t,"b","matMul");[r,i]=fd(r,i);const a={a:r,b:i},o={transposeA:n,transposeB:s};return kd.runKernel(xl,a,o)}});const Yg=Dd({maxPool_:function(e,t,n,s,r){const i=Rd(e,"x","maxPool");let a=i,o=!1;3===i.rank&&(o=!0,a=Jf(i,[1,i.shape[0],i.shape[1],i.shape[2]])),go(4===a.rank,(()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`)),go(qf(n,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '1'`)),Zf("maxPool",s,r);const l={x:a},u={filterSize:t,strides:n,pad:s,dimRoundingMode:r},c=kd.runKernel(Fu,l,u);return o?Jf(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});const Qg=Dd({maxPool3d_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[1,1,1],n=arguments.length>2?arguments[2]:void 0,s=arguments.length>3?arguments[3]:void 0,r=arguments.length>4?arguments[4]:void 0,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC";const a=Rd(e,"x","maxPool3d");let o=a,l=!1;4===a.rank&&(l=!0,o=Jf(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),go(5===o.rank,(()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`)),go("NDHWC"===i,(()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`)),Zf("maxPool3d",s,r);const u={x:o},c={filterSize:t,strides:n,pad:s,dimRoundingMode:r,dataFormat:i},h=kd.runKernel(Ou,u,c);return l?Jf(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});const Zg=Dd({mean_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const s={x:Rd(e,"x","mean")},r={axis:t,keepDims:n};return kd.runKernel(zu,s,r)}});const Jg=Dd({min_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const s={x:Rd(e,"x","min")},r={axis:t,keepDims:n};return kd.runKernel(Bu,s,r)}});const em=Dd({minimum_:function(e,t){let n=Rd(e,"a","minimum"),s=Rd(t,"b","minimum");[n,s]=fd(n,s),"bool"===n.dtype&&(n=_p(n,"int32"),s=_p(s,"int32")),ef(n.shape,s.shape);const r={a:n,b:s};return kd.runKernel(Wu,r)}});const tm=Dd({moments_:function(e){let t=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const n=Co(arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,(e=Rd(e,"x","moments")).shape),s=Zg(e,n,t);let r=s.shape;t||(r=Vg(s.shape,n));const i=Mp(qp(_p(e,"float32"),Jf(s,r)));return{mean:s,variance:Zg(i,n,t)}}});const nm=Dd({neg_:function(e){const t={x:Rd(e,"x","neg")};return kd.runKernel(ju,t)}});const sm=Dd({notEqual_:function(e,t){let n=Rd(e,"a","notEqual","string_or_numeric"),s=Rd(t,"b","notEqual","string_or_numeric");[n,s]=fd(n,s),ef(n.shape,s.shape);const r={a:n,b:s};return kd.runKernel(Ku,r)}});const rm=Dd({oneHot_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"int32";if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);const i={indices:Rd(e,"indices","oneHot","int32")},a={dtype:r,depth:t,onValue:n,offValue:s};return kd.runKernel(Zu,i,a)}});function im(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if(Vo(e),"complex64"===t){const t=im(e,"float32"),n=im(e,"float32");return Fd(t,n)}const n=Bo(xo(e),t);return kd.makeTensor(n,e,t)}function am(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if(Vo(e),"complex64"===t){const t=am(e,"float32"),n=im(e,"float32");return Fd(t,n)}const n=zo(xo(e),t);return kd.makeTensor(n,e,t)}const om=Dd({onesLike_:function(e){const t={x:Rd(e,"x","onesLike")};return kd.runKernel(Qu,t)}});const lm=Dd({pad_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const s=Rd(e,"x","pad");if(0===s.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const r={paddings:t,constantValue:n},i={x:s};return kd.runKernel(ec,i,r)}});const um=Dd({prelu_:function(e,t){const n={x:Rd(e,"x","prelu"),alpha:Rd(t,"alpha","prelu")};return kd.runKernel(nc,n)}});var cm=n(334);class hm{constructor(e,t,n,s,r){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=s,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const i=r||Math.random();this.random=cm.alea(i.toString())}nextValue(){if(!isNaN(this.nextVal)){const e=this.nextVal;return this.nextVal=NaN,e}let e,t,n=!1;for(;!n;){let s,r,i;do{s=2*this.random()-1,r=2*this.random()-1,i=s*s+r*r}while(i>=1||0===i);const a=Math.sqrt(-2*Math.log(i)/i);e=this.mean+this.stdDev*s*a,t=this.mean+this.stdDev*r*a,this.truncated&&!this.isValidTruncated(e)||(n=!0)}return this.truncated&&!this.isValidTruncated(t)||(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return null==this.dtype||"float32"===this.dtype?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class dm{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2?arguments[2]:void 0,s=arguments.length>3?arguments[3]:void 0;if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=e,this.range=t-e,this.dtype=n,null==s&&(s=Math.random()),"number"===typeof s&&(s=s.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=cm.alea(s)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const pm=Dd({randomNormal_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,s=arguments.length>3?arguments[3]:void 0,r=arguments.length>4?arguments[4]:void 0;if(Vo(e),null!=s&&"bool"===s)throw new Error(`Unsupported data type ${s}`);const i=new hm(t,n,s,!1,r),a=Tp(e,s);for(let o=0;o<a.values.length;o++)a.values[o]=i.nextValue();return a.toTensor()}});const fm=Dd({randomUniform_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32",r=arguments.length>4?arguments[4]:void 0;Vo(e);const i=Tp(e,s),a=new dm(t,n,null,r);for(let o=0;o<i.values.length;o++)i.values[o]=a.nextValue();return i.toTensor()}});function gm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32";if(0===n)throw new Error("Cannot have a step of zero");const r={start:e,stop:t,step:n,dtype:s};return kd.runKernel(oc,{},r)}const mm=Dd({relu_:function(e){const t={x:Rd(e,"x","relu")};return kd.runKernel(cc,t)}});const bm=Dd({reverse_:function(e,t){const n={x:Rd(e,"x","reverse")},s={dims:t};return kd.runKernel(bc,n,s)}});const xm=Dd({selu_:function(e){const t={x:Rd(e,"x","selu")};return kd.runKernel(Ic,t)}});const ym=Dd({separableConv2d_:function(e,t,n,s,r){let i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],a=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NHWC";const o=Rd(e,"x","separableConv2d"),l=Rd(t,"depthwiseFilter","separableConv2d"),u=Rd(n,"pointwiseFilter","separableConv2d");let c=o,h=!1;if(3===o.rank&&(h=!0,c=Jf(o,[1,o.shape[0],o.shape[1],o.shape[2]])),"NCHW"===a)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");go(4===c.rank,(()=>`Error in separableConv2d: input must be rank 4, but got rank ${c.rank}.`)),go(4===l.rank,(()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`)),go(4===u.rank,(()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`)),go(1===u.shape[0],(()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${u.shape[0]}.`)),go(1===u.shape[1],(()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${u.shape[1]}.`));const d=l.shape[2],p=l.shape[3];go(u.shape[2]===d*p,(()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*p}, but got ${u.shape[2]}.`));const f=wg(c,l,s,r,a,i),g=pg(f,u,1,"valid",a);return h?Jf(g,[g.shape[1],g.shape[2],g.shape[3]]):g}});const vm=Dd({sigmoid_:function(e){const t={x:Rd(e,"x","sigmoid","float32")};return kd.runKernel(Ec,t)}});const wm=Dd({slice_:function(e,t,n){const s=Rd(e,"x","slice","string_or_numeric");if(0===s.rank)throw new Error("Slicing scalar is not possible");const r={x:s},i={begin:t,size:n};return kd.runKernel(Cc,r,i)}});const km=Dd({slice1d_:function(e,t,n){const s=Rd(e,"x","slice1d");return go(1===s.rank,(()=>`slice1d expects a rank-1 tensor, but got a rank-${s.rank} tensor`)),wm(s,[t],[n])}});const Sm=Dd({slice2d_:function(e,t,n){const s=Rd(e,"x","slice2d");return go(2===s.rank,(()=>`slice2d expects a rank-2 tensor, but got a rank-${s.rank} tensor`)),wm(s,t,n)}});const Im=Dd({slice3d_:function(e,t,n){const s=Rd(e,"x","slice3d");return go(3===s.rank,(()=>`slice3d expects a rank-3 tensor, but got a rank-${s.rank} tensor`)),wm(s,t,n)}});const Cm=Dd({slice4d_:function(e,t,n){const s=Rd(e,"x","slice4d");return go(4===s.rank,(()=>`slice4d expects a rank-4 tensor, but got a rank-${s.rank} tensor`)),wm(s,t,n)}});const Nm=Dd({softmax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=Rd(e,"logits","softmax","float32");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${t}`);const s={logits:n},r={dim:t};return kd.runKernel(Mc,s,r)}});const Tm=Dd({softplus_:function(e){const t={x:Rd(e,"x","softplus")};return kd.runKernel($c,t)}});const _m=Dd({split_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const s={x:Rd(e,"x","split")},r={numOrSizeSplits:t,axis:n};return kd.runKernel(Fc,s,r)}});const Em=Dd({squeeze_:function(e,t){const n=Rd(e,"x","squeeze","string_or_numeric");return Jf(n,No(n.shape,t).newShape)}});const $m=Dd({stack_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=Ad(e,"tensors","stack","string_or_numeric");go(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),n.length>0&&go(t<=n[0].rank,(()=>"Axis must be <= rank of the tensor"));const s=n,r={axis:t};return kd.runKernel(Ju,s,r)}});const Rm=Dd({tanh_:function(e){const t={x:Rd(e,"x","tanh","float32")};return kd.runKernel(Yc,t)}});function Am(e,t){bo(e);const n=_d(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Md(e,null,n,t)}function Dm(e,t,n){if(bo(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const s=_d(e,n);if(2!==s.length&&1!==s.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===s.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Md(e,t,s,n)}const Fm=Dd({truncatedNormal_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,s=arguments.length>3?arguments[3]:void 0,r=arguments.length>4?arguments[4]:void 0;if(Vo(e),null!=s&&"bool"===s)throw new Error("Unsupported data type $ { dtype }");const i=new hm(t,n,s,!0,r),a=Tp(e,s);for(let o=0;o<a.values.length;o++)a.values[o]=i.nextValue();return a.toTensor()}});const Mm=Dd({unstack_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=Rd(e,"x","unstack","string_or_numeric");go(t>=-n.shape.length&&t<n.shape.length,(()=>`Axis = ${t} is not in [-${n.shape.length}, ${n.shape.length})`));const s={value:n},r={axis:t};return kd.runKernel(nh,s,r)}});const Om=Dd({where_:function(e,t,n){const s=Rd(t,"a","where"),r=Rd(n,"b","where"),i=Rd(e,"condition","where","bool"),a=ef(ef(i.shape,s.shape),r.shape),o={condition:ag(i,a),t:ag(s,a),e:ag(r,a)};return kd.runKernel(Sc,o)}});const Lm=Dd({imag_:function(e){const t={input:Rd(e,"input","imag")};return kd.runKernel(bu,t)}});const Pm=Dd({real_:function(e){const t={input:Rd(e,"input","real")};return kd.runKernel(lc,t)}});const zm=Dd({transpose_:function(e,t,n){const s=Rd(e,"x","transpose");if(null==t&&(t=s.shape.map(((e,t)=>t)).reverse()),go(s.rank===t.length,(()=>`Error in transpose: rank of input ${s.rank} must match length of perm ${t}.`)),t.forEach((e=>{go(e>=0&&e<s.rank,(()=>"All entries in 'perm' must be between 0 and "+(s.rank-1)+` but got ${t}`))})),s.rank<=1)return s.clone();const r={x:s},i={perm:t};return"complex64"===s.dtype?Bd((()=>{let e=Pm(s),t=Lm(s);return e=kd.runKernel(eh,{x:e},i),t=kd.runKernel(eh,{x:t},i),n&&(t=nm(t)),Fd(e,t)})):kd.runKernel(eh,r,i)}});const Bm=Dd({dropout_:function(e,t,n,s){const r=Rd(e,"x","dropout");if(go("float32"===r.dtype,(()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${r.dtype} tensor instead.`)),go(t>=0&&t<1,(()=>`rate must be a float in the range [0, 1), but got ${t}.`)),0===t)return e instanceof td?r.clone():r;const i=function(e,t){if(null==t)return e.shape.slice();if(yo(e.shape,t))return t;if(e.shape.length===t.length){const n=[];for(let s=0;s<e.shape.length;s++)null==t[s]&&null!=e.shape[s]?n.push(e.shape[s]):n.push(t[s]);return n}return t}(r,n),a=1-t,o=Ap(Eg($p(fm(i,0,1,"float32",s),a)),a);return Dp(r,o)}});const Wm=Dd({fft_:function(e){go("complex64"===e.dtype,(()=>`The dtype for tf.spectral.fft() must be complex64 but got ${e.dtype}.`));const t={input:e};return kd.runKernel(iu,t)}});const Vm=Dd({rfft_:function(e,t){go("float32"===e.dtype,(()=>`The dtype for rfft() must be real value but got ${e.dtype}`));let n=e.shape[e.shape.length-1];const s=e.size/n;let r;if(null!=t&&t<n){const s=e.shape.map((e=>0)),i=e.shape.map((e=>e));i[e.shape.length-1]=t,r=wm(e,s,i),n=t}else if(null!=t&&t>n){const s=e.shape.map((e=>e));s[e.shape.length-1]=t-n,r=lg([e,im(s)],e.shape.length-1),n=t}else r=e;const i=Op(r),a=Jf(Fd(r,i),[s,n]),o=Wm(a),l=Math.floor(n/2)+1,u=Pm(o),c=Lm(o),h=_m(u,[l,n-l],u.shape.length-1),d=_m(c,[l,n-l],c.shape.length-1),p=r.shape.slice();return p[r.shape.length-1]=l,Jf(Fd(h[0],d[0]),p)}});const Um=Dd({ifft_:function(e){go("complex64"===e.dtype,(()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${e.dtype}.`));const t={input:e};return kd.runKernel(mu,t)}});const Gm=Dd({irfft_:function(e){const t=e.shape[e.shape.length-1],n=e.size/t;let s;if(t<=2){const r=Jf(e,[n,t]);s=Um(r)}else{const r=[n,2*(t-1)],i=Jf(Pm(e),[n,t]),a=Jf(Lm(e),[n,t]),o=bm(wm(i,[0,1],[n,t-2]),1),l=Dp(bm(wm(a,[0,1],[n,t-2]),1),Pp(-1)),u=lg([i,o],1),c=lg([a,l],1),h=Jf(Fd(u,c),[r[0],r[1]]);s=Um(h)}if(s=Pm(s),3===e.rank&&0!==e.shape[0]){const t=s,n=e.shape[0];s=Jf(s,[n,s.shape[0]/n,s.shape[1]]),t.dispose()}return s}});const Hm=Dd({conv2DBackpropFilter_:function(e,t,n,s,r){let i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",a=arguments.length>6?arguments[6]:void 0,o=e;3===e.rank&&(o=Jf(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;3===l.rank&&(l=Jf(t,[1,t.shape[0],t.shape[1],t.shape[2]])),go(4===o.rank,(()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`)),go(4===l.rank,(()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`)),go(4===n.length,(()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`));const u="NHWC"===i?o.shape[3]:o.shape[1],c="NHWC"===i?l.shape[3]:l.shape[1];go(u===n[2],(()=>`Error in conv2dDerFilter: depth of input ${u}) must match input depth in filter (${n[2]}.`)),go(c===n[3],(()=>`Error in conv2dDerFilter: depth of dy (${c}) must match output depth for filter (${n[3]}).`)),Zf("conv2dDerFilter",r,a);const h={x:o,dy:l},d={strides:s,pad:r,dataFormat:i,dimRoundingMode:a,filterShape:n};return kd.runKernel($l,h,d)}});const jm=Dd({relu6_:function(e){const t={x:Rd(e,"x","relu6")};return kd.runKernel(mc,t)}});const Km=Dd({step_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:Rd(e,"x","step")},s={alpha:t};return kd.runKernel(ih,n,s)}});function Xm(e,t,n){if(null==n||"linear"===n)return e;if("relu"===n)return Dp(e,Km(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function qm(e,t){let n=t;const s=Jp(e.shape,t.shape);return s.length>0&&(n=Lg(n,s)),Jf(n,e.shape)}function Ym(e,t,n,s){if("linear"===t)return e;if("relu"===t)return mm(e);if("elu"===t)return kg(e);if("relu6"===t)return jm(e);if("prelu"===t)return um(e,n);if("leakyrelu"===t)return Dg(e,s);if("sigmoid"===t)return vm(e);throw new Error(`Unknown fused activation ${t}.`)}const Qm=(e,t)=>!(e>0)||"linear"===t;const Zm=Dd({fusedConv2d_:function(e){let{x:t,filter:n,strides:s,pad:r,dataFormat:i="NHWC",dilations:a=[1,1],dimRoundingMode:o,bias:l,activation:u="linear",preluActivationWeights:c,leakyreluAlpha:h}=e;if(u=u||"linear",!1===Qm(kd.state.gradientDepth,u)){go("NHWC"===i,(()=>`Error in fused conv2d: got dataFormat of ${i} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`));let e=pg(t,n,s,r,i,a,o);return null!=l&&(e=$p(e,l)),Ym(e,u,c,h)}const d=Rd(t,"x","conv2d","float32"),p=Rd(n,"filter","conv2d","float32");let f=d,g=!1;3===d.rank&&(g=!0,f=Jf(d,[1,d.shape[0],d.shape[1],d.shape[2]])),go(4===f.rank,(()=>`Error in fused conv2d: input must be rank 4, but got rank ${f.rank}.`)),go(4===p.rank,(()=>`Error in fused conv2d: filter must be rank 4, but got rank ${p.rank}.`)),Zf("fused conv2d",r,o);const m="NHWC"===i?f.shape[3]:f.shape[1];go(p.shape[2]===m,(()=>`Error in conv2d: depth of input (${m}) must match input depth for filter ${p.shape[2]}.`)),go(qf(s,a),(()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${s} and dilations '${a}'`));const b=Wf(f.shape,p.shape,s,a,r,o);let x,y;if(null!=l&&(x=Rd(l,"bias","fused conv2d"),[x]=fd(x,d),"NHWC"===i?ef(b.outShape,x.shape):(go(x.shape.length<=1,(()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${x.shape.length}.`)),go(0===x.shape.length||x.shape[0]===b.outChannels||1===x.shape[0],(()=>`Error in fused conv2d: bias shape (${x.shape}) is not compatible with the number of output channels (${b.outChannels})`)))),null!=c){const e=c.shape;if(go(e.length<=1||3===e.length,(()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${e.length}.`)),1===e.length)go(1===e[0]||e[0]===b.outChannels,(()=>`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the number of output channels (${b.outChannels}).`));else if(3===e.length)try{ef(e,b.outShape)}catch(S){const t=`Error in fused conv2d: PReLU activation weights (${e}) is not compatible with the output shape of the conv2d (${b.outShape}).`;throw Error(t)}y=Rd(c,"prelu weights","fused conv2d")}const v=(e,t)=>{go("NHWC"===i,(()=>`Error in gradient of fused conv2D: got dataFormat of ${i} but only NHWC is currently supported.`));const[n,o,l,c]=t,h=Xm(e,l,u);go(Xf(a),(()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`));const d=[gg(o.shape,h,n,s,r),Hm(o,h,n.shape,s,r)];if(null!=c){const e=qm(c,h);d.push(e)}return d},w={x:f,filter:p,bias:x,preluActivationWeights:y},k={strides:s,pad:r,dataFormat:i,dilations:a,dimRoundingMode:o,activation:u,leakyreluAlpha:h};if(null==l){const e=Lp(((e,t,n)=>{let s=kd.runKernel(uh,w,k);return n([t,e,s]),g&&(s=Jf(s,[s.shape[1],s.shape[2],s.shape[3]])),{value:s,gradFunc:v}}));return e(f,p)}{const e=Lp(((e,t,n,s)=>{let r=kd.runKernel(uh,w,k);return s([t,e,r,n]),g&&(r=Jf(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:v}}));return e(f,p,x)}}});const Jm=Dd({depthwiseConv2dNativeBackpropFilter_:function(e,t,n,s,r){let i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],a=arguments.length>6?arguments[6]:void 0,o=e;3===e.rank&&(o=Jf(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let l=t;3===l.rank&&(l=Jf(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const u={x:o,dy:l},c={strides:s,pad:r,dimRoundingMode:a,dilations:i,filterShape:n};return kd.runKernel(Ul,u,c)}});const eb=Dd({depthwiseConv2dNativeBackpropInput_:function(e,t,n,s,r){let i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],a=arguments.length>6?arguments[6]:void 0,o=t,l=!1;3===t.rank&&(l=!0,o=Jf(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const u={dy:o,filter:n},c={strides:s,pad:r,dimRoundingMode:a,dilations:i,inputShape:e},h=kd.runKernel(Gl,u,c);return l?Jf(h,[h.shape[1],h.shape[2],h.shape[3]]):h}});const tb=Dd({fusedMatMul_:function(e){let{a:t,b:n,transposeA:s=!1,transposeB:r=!1,bias:i,activation:a="linear",preluActivationWeights:o,leakyreluAlpha:l=.2}=e;if(!1===Qm(kd.state.gradientDepth,a)){let e=qg(t,n,s,r);return null!=i&&(e=$p(e,i)),Ym(e,a,o,l)}let u=Rd(t,"a","fused matMul"),c=Rd(n,"b","fused matMul");[u,c]=fd(u,c);const h=s?u.shape[u.rank-2]:u.shape[u.rank-1],d=r?c.shape[c.rank-1]:c.shape[c.rank-2],p=s?u.shape[u.rank-1]:u.shape[u.rank-2],f=r?c.shape[c.rank-2]:c.shape[c.rank-1],g=u.shape.slice(0,-2),m=c.shape.slice(0,-2),b=xo(g),x=xo(m);go(h===d,(()=>`Error in fused matMul: inner shapes (${h}) and (${d}) of Tensors with shapes ${u.shape} and ${c.shape} and transposeA=${s} and transposeB=${r} must match.`));const y=ef(u.shape.slice(0,-2),c.shape.slice(0,-2)).concat([p,f]),v=Jf(u,s?[b,h,p]:[b,p,h]),w=Jf(c,r?[x,f,d]:[x,d,f]);let k,S;null!=i&&(k=Rd(i,"bias","fused matMul"),[k]=fd(k,u),ef(y,k.shape)),null!=o&&(S=Rd(o,"prelu weights","fused matMul"));const I=(e,t)=>{const[n,o,l,u]=t,c=Xm(Jf(e,l.shape),l,a);let h,d;if(s||r?!s&&r?(h=qg(c,o,!1,!1),d=qg(c,n,!0,!1)):s&&!r?(h=qg(o,c,!1,!0),d=qg(n,c,!1,!1)):(h=qg(o,c,!0,!0),d=qg(c,n,!0,!0)):(h=qg(c,o,!1,!0),d=qg(n,c,!0,!1)),null!=i){return[h,d,qm(u,c)]}return[h,d]},C={a:v,b:w,bias:k,preluActivationWeights:S},N={transposeA:s,transposeB:r,activation:a,leakyreluAlpha:l};if(null==i){const e=Lp(((e,t,n)=>{const s=kd.runKernel(lh,C,N);return n([e,t,s]),{value:Jf(s,y),gradFunc:I}}));return e(v,w)}{const e=Lp(((e,t,n,s)=>{const r=kd.runKernel(lh,C,N);return s([e,t,r,n]),{value:Jf(r,y),gradFunc:I}}));return e(v,w,k)}}});const nb=Dd({cropAndResize_:function(e,t,n,s){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"bilinear",i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const a=Rd(e,"image","cropAndResize"),o=Rd(t,"boxes","cropAndResize","float32"),l=Rd(n,"boxInd","cropAndResize","int32"),u=o.shape[0];go(4===a.rank,(()=>`Error in cropAndResize: image must be rank 4,but got rank ${a.rank}.`)),go(2===o.rank&&4===o.shape[1],(()=>`Error in cropAndResize: boxes must be have size [${u},4] but had shape ${o.shape}.`)),go(1===l.rank&&l.shape[0]===u,(()=>`Error in cropAndResize: boxInd must be have size [${u}] but had shape ${o.shape}.`)),go(2===s.length,(()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`)),go(s[0]>=1&&s[1]>=1,(()=>`cropSize must be atleast [1,1], but was ${s}`)),go("bilinear"===r||"nearest"===r,(()=>`method must be bilinear or nearest, but was ${r}`));const c={image:a,boxes:o,boxInd:l},h={method:r,extrapolationValue:i,cropSize:s};return kd.runKernel(zl,c,h)}});const sb=Dd({flipLeftRight_:function(e){const t=Rd(e,"image","flipLeftRight","float32");go(4===t.rank,(()=>`Error in flipLeftRight: image must be rank 4,but got rank ${t.rank}.`));const n={image:t};return kd.runKernel(ou,n,{})}});const rb=Dd({grayscaleToRGB_:function(e){const t=Rd(e,"image","grayscaleToRGB"),n=t.rank-1,s=t.shape[n];go(t.rank>=2,(()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${t.rank}.`)),go(1===s,(()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${s}.`));const r=new Array(t.rank);return r.fill(1,0,n),r[n]=3,Tg(t,r)}});const ib=Dd({einsum_:function(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),s=1;s<t;s++)n[s-1]=arguments[s];const r=n.map(((e,t)=>Rd(e,`tensors${t}`,"einsum"))),i={equation:e};return kd.runKernel(Ql,r,i)}});const ab=Dd({rgbToGrayscale_:function(e){const t=Rd(e,"image","RGBToGrayscale"),n=t.rank-1,s=t.shape[n];go(t.rank>=2,(()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${t.rank}.`)),go(3===s,(()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${s}.`));const r=t.dtype,i=_p(t,"float32"),a=Am([.2989,.587,.114]);let o;switch(t.rank){case 2:o=ib("ij,j->i",i,a);break;case 3:o=ib("ijk,k->ij",i,a);break;case 4:o=ib("ijkl,l->ijk",i,a);break;case 5:o=ib("ijklm,m->ijkl",i,a);break;case 6:o=ib("ijklmn,n->ijklm",i,a);break;default:throw new Error("Not a valid tensor rank.")}return o=Ng(o,-1),_p(o,r)}});const ob=Dd({rotateWithOffset_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5;const r=Rd(e,"image","rotateWithOffset","float32");go(4===r.rank,(()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`));const i={image:r},a={radians:t,fillValue:n,center:s};return kd.runKernel(oh,i,a)}});function lb(e,t,n,s,r,i){null==s&&(s=.5),null==r&&(r=Number.NEGATIVE_INFINITY),null==i&&(i=0);const a=e.shape[0];return n=Math.min(n,a),go(0<=s&&s<=1,(()=>`iouThreshold must be in [0, 1], but was '${s}'`)),go(2===e.rank,(()=>`boxes must be a 2D tensor, but was of rank '${e.rank}'`)),go(4===e.shape[1],(()=>`boxes must have 4 columns, but 2nd dimension was ${e.shape[1]}`)),go(1===t.rank,(()=>"scores must be a 1D tensor")),go(t.shape[0]===a,(()=>`scores has incompatible shape with boxes. Expected ${a}, but was ${t.shape[0]}`)),go(0<=i&&i<=1,(()=>`softNmsSigma must be in [0, 1], but was '${i}'`)),{maxOutputSize:n,iouThreshold:s,scoreThreshold:r,softNmsSigma:i}}const ub=Dd({nonMaxSuppression_:function(e,t,n){let s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY;const i=Rd(e,"boxes","nonMaxSuppression","float32"),a=Rd(t,"scores","nonMaxSuppression","float32"),o=lb(i,a,n,s,r);n=o.maxOutputSize,s=o.iouThreshold,r=o.scoreThreshold;const l={maxOutputSize:n,iouThreshold:s,scoreThreshold:r};return kd.runKernel(Xu,{boxes:i,scores:a},l)}});function cb(e,t,n){const s=function(e,t,n){return function(e,t,n){let s=0,r=e.length,i=0,a=!1;for(;s<r;){i=s+(r-s>>>1);const o=n(t,e[i]);o>0?s=i+1:(r=i,a=!o)}return a?s:-s-1}(e,t,n||hb)}(e,t,n),r=s<0?-(s+1):s;e.splice(r,0,t)}function hb(e,t){return e>t?1:e<t?-1:0}function db(e,t,n,s,r){return gb(e,t,n,s,r,0)}function pb(e,t,n,s,r,i){return gb(e,t,n,s,r,0,!1,i,!0)}function fb(e,t,n,s,r,i){return gb(e,t,n,s,r,i,!0)}function gb(e,t,n,s,r,i){let a=arguments.length>6&&void 0!==arguments[6]&&arguments[6],o=arguments.length>7&&void 0!==arguments[7]&&arguments[7],l=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const u=[];for(let m=0;m<t.length;m++)t[m]>r&&u.push({score:t[m],boxIndex:m,suppressBeginIndex:0});u.sort(xb);const c=i>0?-.5/i:0,h=[],d=[];for(;h.length<n&&u.length>0;){const t=u.pop(),{score:n,boxIndex:i,suppressBeginIndex:a}=t;if(n<r)break;let o=!1;for(let l=h.length-1;l>=a;--l){const n=mb(e,i,h[l]);if(n>=s){o=!0;break}if(t.score=t.score*bb(s,c,n),t.score<=r)break}t.suppressBeginIndex=h.length,o||(t.score===n?(h.push(i),d.push(t.score)):t.score>r&&cb(u,t,xb))}const p=h.length,f=n-p;o&&f>0&&(h.push(...new Array(f).fill(0)),d.push(...new Array(f).fill(0)));const g={selectedIndices:h};return a&&(g.selectedScores=d),l&&(g.validOutputs=p),g}function mb(e,t,n){const s=e.subarray(4*t,4*t+4),r=e.subarray(4*n,4*n+4),i=Math.min(s[0],s[2]),a=Math.min(s[1],s[3]),o=Math.max(s[0],s[2]),l=Math.max(s[1],s[3]),u=Math.min(r[0],r[2]),c=Math.min(r[1],r[3]),h=Math.max(r[0],r[2]),d=Math.max(r[1],r[3]),p=(o-i)*(l-a),f=(h-u)*(d-c);if(p<=0||f<=0)return 0;const g=Math.max(i,u),m=Math.max(a,c),b=Math.min(o,h),x=Math.min(l,d),y=Math.max(b-g,0)*Math.max(x-m,0);return y/(p+f-y)}function bb(e,t,n){const s=Math.exp(t*n*n);return n<=e?s:0}function xb(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}const yb=async function(e,t,n){let s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY;const i=Rd(e,"boxes","nonMaxSuppressionAsync"),a=Rd(t,"scores","nonMaxSuppressionAsync"),o=lb(i,a,n,s,r);n=o.maxOutputSize,s=o.iouThreshold,r=o.scoreThreshold;const l=await Promise.all([i.data(),a.data()]),u=l[0],c=l[1],{selectedIndices:h}=db(u,c,n,s,r);return i!==e&&i.dispose(),a!==t&&a.dispose(),Am(h,"int32")};const vb=Dd({nonMaxSuppressionWithScore_:function(e,t,n){let s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const a=Rd(e,"boxes","nonMaxSuppression"),o=Rd(t,"scores","nonMaxSuppression"),l=lb(a,o,n,s,r,i);n=l.maxOutputSize,s=l.iouThreshold,r=l.scoreThreshold,i=l.softNmsSigma;const u={boxes:a,scores:o},c={maxOutputSize:n,iouThreshold:s,scoreThreshold:r,softNmsSigma:i},h=kd.runKernel(Yu,u,c);return{selectedIndices:h[0],selectedScores:h[1]}}});const wb=async function(e,t,n){let s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const a=Rd(e,"boxes","nonMaxSuppressionAsync"),o=Rd(t,"scores","nonMaxSuppressionAsync"),l=lb(a,o,n,s,r,i);n=l.maxOutputSize,s=l.iouThreshold,r=l.scoreThreshold,i=l.softNmsSigma;const u=await Promise.all([a.data(),o.data()]),c=u[0],h=u[1],{selectedIndices:d,selectedScores:p}=fb(c,h,n,s,r,i);return a!==e&&a.dispose(),o!==t&&o.dispose(),{selectedIndices:Am(d,"int32"),selectedScores:Am(p)}};const kb=Dd({nonMaxSuppressionPadded_:function(e,t,n){let s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,i=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const a=Rd(e,"boxes","nonMaxSuppression"),o=Rd(t,"scores","nonMaxSuppression"),l=lb(a,o,n,s,r,null),u={boxes:a,scores:o},c={maxOutputSize:l.maxOutputSize,iouThreshold:l.iouThreshold,scoreThreshold:l.scoreThreshold,padToMaxOutputSize:i},h=kd.runKernel(qu,u,c);return{selectedIndices:h[0],validOutputs:h[1]}}});const Sb=async function(e,t,n){let s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,i=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const a=Rd(e,"boxes","nonMaxSuppressionAsync"),o=Rd(t,"scores","nonMaxSuppressionAsync"),l=lb(a,o,n,s,r,null),u=l.maxOutputSize,c=l.iouThreshold,h=l.scoreThreshold,[d,p]=await Promise.all([a.data(),o.data()]),{selectedIndices:f,validOutputs:g}=pb(d,p,u,c,h,i);return a!==e&&a.dispose(),o!==t&&o.dispose(),{selectedIndices:Am(f,"int32"),validOutputs:Pp(g,"int32")}};const Ib=Dd({resizeBilinear_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],s=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=Rd(e,"images","resizeBilinear");go(3===r.rank||4===r.rank,(()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`)),go(2===t.length,(()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`)),go(!1===s||!1===n,(()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false."));let i=r,a=!1;3===r.rank&&(a=!0,i=Jf(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const[]=t,o={images:i},l={alignCorners:n,halfPixelCenters:s,size:t},u=kd.runKernel(fc,o,l);return a?Jf(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});const Cb=Dd({resizeNearestNeighbor_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],s=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=Rd(e,"images","resizeNearestNeighbor");go(3===r.rank||4===r.rank,(()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`)),go(2===t.length,(()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`)),go("float32"===r.dtype||"int32"===r.dtype,(()=>"`images` must have `int32` or `float32` as dtype")),go(!1===s||!1===n,(()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false."));let i=r,a=!1;3===r.rank&&(a=!0,i=Jf(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const[]=t,o={images:i},l={alignCorners:n,halfPixelCenters:s,size:t},u=kd.runKernel(dc,o,l);return a?Jf(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});const Nb=Dd({bincount_:function(e,t,n){const s=Rd(e,"x","bincount"),r=Rd(t,"weights","bincount");go("int32"===s.dtype,(()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`)),go(n>=0,(()=>`size must be non-negative, but got ${n}.`)),go(r.size===s.size||0===r.size,(()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${r.shape}.`));const i={x:s,weights:r},a={size:n};return kd.runKernel(vl,i,a)}});const Tb=Dd({lessEqual_:function(e,t){let n=Rd(e,"a","lessEqual","string_or_numeric"),s=Rd(t,"b","lessEqual","string_or_numeric");[n,s]=fd(n,s),ef(n.shape,s.shape);const r={a:n,b:s};return kd.runKernel(Su,r)}});const _b=Dd({round_:function(e){const t={x:Rd(e,"x","round")};return kd.runKernel(xc,t)}});const Eb=Dd({threshold_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"binary",n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5;const r=Rd(e,"image","threshold"),i=r.shape[0]*r.shape[1];let a,o,l,u,c=Dp(Am([s]),255);if(go(3===r.rank,(()=>`Error in threshold: image must be rank 3,but got rank ${r.rank}.`)),go(3===r.shape[2]||1===r.shape[2],(()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${r.shape[2]}.`)),go("int32"===r.dtype||"float32"===r.dtype,(()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${r.dtype}.`)),go("otsu"===t||"binary"===t,(()=>`Method must be binary or otsu, but was ${t}`)),3===r.shape[2]){[a,o,l]=_m(r,[1,1,1],-1);const e=Dp(a,.2989),t=Dp(o,.587),n=Dp(l,.114);u=$p($p(e,t),n)}else u=e;if("otsu"===t){c=function(e,t){let n,s,r,i,a,o,l=Am([-1]),u=Am([0]),c=Am([0]);for(let h=0;h<e.size-1;h++){n=wm(e,0,h+1),s=wm(e,h+1),a=Ap(Lg(n),t),o=Ap(Lg(s),t);const d=Lg(Dp(n,gm(0,n.size)));r=Ap(d,Lg(n));const p=jp(s.shape,n.size),f=$p(gm(0,s.size),p),g=Dp(s,f);i=Ap(Lg(g),Lg(s));const m=qp(r,i),b=qp(r,i),x=Dp(a,o);c=Dp(Dp(x,m),b);const y=Rg(c,u);u=Om(y,c,u),l=Om(y,Am([h]),l)}return l}(Nb(_p(_b(u),"int32"),Od([]),256),i)}const h=n?Tb(u,c):Rg(u,c);return _p(Dp(h,255),"int32")}});const $b=Dd({transform_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"nearest",s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"constant",r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,i=arguments.length>5?arguments[5]:void 0;const a=Rd(e,"image","transform","float32"),o=Rd(t,"transforms","transform","float32");go(4===a.rank,(()=>`Error in transform: image must be rank 4,but got rank ${a.rank}.`)),go(2===o.rank&&(o.shape[0]===a.shape[0]||1===o.shape[0])&&8===o.shape[1],(()=>"Error in transform: Input transform should be batch x 8 or 1 x 8")),go(null==i||2===i.length,(()=>`Error in transform: outputShape must be [height, width] or null, but got ${i}.`));const l={image:a,transforms:o},u={interpolation:n,fillMode:s,fillValue:r,outputShape:i};return kd.runKernel(Jc,l,u)}});const Rb=Dd({less_:function(e,t){let n=Rd(e,"a","less","string_or_numeric"),s=Rd(t,"b","less","string_or_numeric");[n,s]=fd(n,s),ef(n.shape,s.shape);const r={a:n,b:s};return kd.runKernel(ku,r)}});const Ab=Dd({bandPart_:function(e,t,n){const s=Rd(e,"a","bandPart");go(s.rank>=2,(()=>`bandPart(): Rank must be at least 2, got ${s.rank}.`));const r=s.shape,[i,a]=s.shape.slice(-2);let o,l;"number"===typeof t?(go(t%1===0,(()=>`bandPart(): numLower must be an integer, got ${t}.`)),go(t<=i,(()=>`bandPart(): numLower (${t}) must not be greater than the number of rows (${i}).`)),o=Rd(t<0?i:t,"numLower","bandPart")):(go("int32"===t.dtype,(()=>"bandPart(): numLower's dtype must be an int32.")),o=Om(Rb(t,0),i,em(t,i))),"number"===typeof n?(go(n%1===0,(()=>`bandPart(): numUpper must be an integer, got ${n}.`)),go(n<=a,(()=>`bandPart(): numUpper (${n}) must not be greater than the number of columns (${a}).`)),l=Rd(n<0?a:n,"numUpper","bandPart")):(go("int32"===n.dtype,(()=>"bandPart(): numUpper's dtype must be an int32.")),l=Om(Rb(n,0),a,em(n,a)));const u=Jf(gm(0,i,1,"int32"),[-1,1]),c=gm(0,a,1,"int32"),h=qp(u,c),d=Xg(Tb(h,o),Ag(h,nm(l))),p=im([i,a],s.dtype);return Jf($m(Mm(Jf(s,[-1,i,a])).map((e=>Om(d,e,p)))),r)}});function Db(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;if(0===e.rank)return Qp(e);if(1!==e.rank&&null===n)return Db(Jf(e,[-1]),t,n);if(1===e.rank||"number"===typeof n||Array.isArray(n)&&1===n.length){if(1===t)return Lg(Qp(e),n);if(t===1/0)return Og(Qp(e),n);if(t===-1/0)return Jg(Qp(e),n);if("euclidean"===t||2===t)return Fp(Lg(Xp(Qp(e),Pp(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(n)&&2===n.length){if(1===t)return Og(Lg(Qp(e),n[0]),n[1]-1);if(t===1/0)return Og(Lg(Qp(e),n[1]),n[0]);if(t===-1/0)return Jg(Lg(Qp(e),n[1]),n[0]);if("fro"===t||"euclidean"===t)return Fp(Lg(Mp(e),n));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const Fb=Dd({norm_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"euclidean",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,s=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=Db(e=Rd(e,"x","norm"),t,n);let i=r.shape;if(s){const t=Co(n,e.shape);i=Vg(r.shape,t)}return Jf(r,i)}});const Mb=Dd({gramSchmidt_:function(e){let t;if(Array.isArray(e)){t=!1,go(null!=e&&e.length>0,(()=>"Gram-Schmidt process: input must not be null, undefined, or empty"));const n=e[0].shape[0];for(let t=1;t<e.length;++t)go(e[t].shape[0]===n,(()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${e[t].shape[0]} vs. ${n})`))}else t=!0,e=_m(e,e.shape[0],0).map((e=>Em(e,[0])));go(e.length<=e[0].shape[0],(()=>`Gram-Schmidt: Number of vectors (${e.length}) exceeds number of dimensions (${e[0].shape[0]}).`));const n=[],s=e;for(let r=0;r<e.length;++r)n.push(kd.tidy((()=>{let e=s[r];if(r>0)for(let t=0;t<r;++t){const s=Dp(Lg(Dp(n[t],e)),n[t]);e=qp(e,s)}return Ap(e,Fb(e,"euclidean"))})));return t?$m(n,0):n}});function Ob(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return kd.tidy((()=>{go(2===e.shape.length,(()=>`qr2d() requires a 2D Tensor, but got a ${e.shape.length}D Tensor.`));const n=e.shape[0],s=e.shape[1];let r=_g(n),i=Ep(e);const a=Dm([[1]],[1,1]);let o=Ep(a);const l=n>=s?s:n;for(let e=0;e<l;++e){const t=i,l=o,u=r;[o,i,r]=kd.tidy((()=>{const t=wm(i,[e,e],[n-e,1]),l=Fb(t),u=wm(i,[e,e],[1,1]),c=Om(Rg(u,0),Dm([[-1]]),Dm([[1]])),h=qp(u,Dp(c,l)),d=Ap(t,h);o=1===d.shape[0]?Ep(a):lg([a,wm(d,[1,0],[d.shape[0]-1,d.shape[1]])],0);const p=nm(Ap(qg(c,h),l)),f=wm(i,[e,0],[n-e,s]),g=Dp(p,o),m=zm(o);if(0===e)i=qp(f,qg(g,qg(m,f)));else{const t=qp(f,qg(g,qg(m,f)));i=lg([wm(i,[0,0],[e,s]),t],0)}const b=zm(g),x=wm(r,[0,e],[n,r.shape[1]-e]);if(0===e)r=qp(x,qg(qg(x,o),b));else{const t=qp(x,qg(qg(x,o),b));r=lg([wm(r,[0,0],[n,e]),t],1)}return[o,i,r]})),Wd([t,l,u])}return!t&&n>s&&(r=wm(r,[0,0],[n,s]),i=wm(i,[0,0],[s,s])),[r,i]}))}const Lb=Dd({qr_:function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(go(e.rank>=2,(()=>`qr() requires input tensor to have a rank >= 2, but got rank ${e.rank}`)),2===e.rank)return Ob(e,t);{const n=e.shape.slice(0,e.shape.length-2).reduce(((e,t)=>e*t)),s=Mm(Jf(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),r=[],i=[];s.forEach((e=>{const[n,s]=Ob(e,t);r.push(n),i.push(s)}));return[Jf($m(r,0),e.shape),Jf($m(i,0),e.shape)]}}});var Pb;!function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(Pb||(Pb={}));const zb=Dd({squaredDifference_:function(e,t){let n=Rd(e,"a","squaredDifference"),s=Rd(t,"b","squaredDifference");[n,s]=fd(n,s),ef(n.shape,s.shape);const r={a:n,b:s};return kd.runKernel(Wc,r,{})}});const Bb={flipLeftRight:sb,grayscaleToRGB:rb,resizeNearestNeighbor:Cb,resizeBilinear:Ib,rgbToGrayscale:ab,rotateWithOffset:ob,cropAndResize:nb,nonMaxSuppression:ub,nonMaxSuppressionAsync:yb,nonMaxSuppressionWithScore:vb,nonMaxSuppressionWithScoreAsync:wb,nonMaxSuppressionPadded:kb,nonMaxSuppressionPaddedAsync:Sb,threshold:Eb,transform:$b},Wb={bandPart:Ab,gramSchmidt:Mb,qr:Lb};const Vb=class{static sgd(e){return new sf(e)}static momentum(e,t){return new rf(e,t,arguments.length>2&&void 0!==arguments[2]&&arguments[2])}static rmsprop(e){return new af(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,arguments.length>4&&void 0!==arguments[4]&&arguments[4])}static adam(){return new Yp(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.001,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:.999,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null)}static adadelta(){return new Hp(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.001,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.95,arguments.length>2&&void 0!==arguments[2]?arguments[2]:null)}static adamax(){return new nf(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.002,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:.999,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,arguments.length>4&&void 0!==arguments[4]?arguments[4]:0)}static adagrad(e){return new Kp(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1)}},Ub="undefined"!==typeof requestAnimationFrame?requestAnimationFrame:"undefined"!==typeof setImmediate?setImmediate:e=>e();function Gb(){return new Promise((e=>Ub((()=>e()))))}function Hb(e,t){const n=e[0].length;e.forEach(((e,t)=>{go(e.length===n,(()=>`Error in concat${n}D: rank of tensors[${t}] must be the same as the rank of the rest (${n})`))})),go(t>=0&&t<n,(()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`));const s=e[0];e.forEach(((e,r)=>{for(let i=0;i<n;i++)go(i===t||e[i]===s[i],(()=>`Error in concat${n}D: Shape of tensors[${r}] (${e}) does not match the shape of the rest (${s}) along the non-concatenated axis ${r}.`))}))}function jb(e,t){const n=e[0].slice();for(let s=1;s<e.length;s++)n[t]+=e[s][t];return n}var Kb;function Xb(e,t,n){let s=new Array;if(null==n&&null==t)return s;if(null==t)for(;s.length<e+n.length;)s.push(-1);else s=t.slice();if(null==n)return s;if(e+n.length!==s.length)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.rank = ${e+n.length}, but shape.rank = ${s.length}`);for(let r=1;r<n.length;++r){const i=n[r],a=s[s.length-n.length+r],o=s[a];if(i>=0)if(o>=0){if(o!==i)throw new Error(`rt input.shape and shape=${t} are incompatible: rt input.shape[${r+e}] = ${i} but shape[${r+e}] = ${o}`)}else s[a]=i}return s}function qb(e){const t={FIRST_DIM_SIZE:Kb.FIRST_DIM_SIZE,VALUE_ROWIDS:Kb.VALUE_ROWIDS,ROW_LENGTHS:Kb.ROW_LENGTHS,ROW_SPLITS:Kb.ROW_SPLITS,ROW_LIMITS:Kb.ROW_LIMITS,ROW_STARTS:Kb.ROW_STARTS},n=[];for(const s of e){if(!(s in t))break;n.push(t[s])}return n}function Yb(e){return 0===e.length?0:e[0]===Kb.FIRST_DIM_SIZE?e.length-1:e.length}function Qb(e,t){if(null==e||null==t)return;const n=e.length,s=t.length;if(n>=s)throw new Error(`defaultValue.shape=${e} and ragged tensor flatValues.shape=${t}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${s})`);for(let r=0;r<Math.min(n,s-1);++r){const n=e[r],s=t[r+1];if(n>=0&&s>=0&&1!==n&&n!==s)throw new Error(`defaultValue.shape=${e}, and ragged tensor input flatValues.shape=${t} are incompatible: defaultValue.shape[${r-e.length}] = ${n} but ragged tensor input.flatValues.shape[${r-e.length}] = ${s}`)}}!function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"}(Kb||(Kb={}));const Zb=30;function Jb(e){return e<=Zb?e:Mo(e,Math.floor(Math.sqrt(e)))}function ex(e,t,n){return[n*("number"===typeof e?e:e[0]),t*("number"===typeof e?e:e[1])]}function tx(e,t,n){let s=[];if(!(arguments.length>3&&void 0!==arguments[3])||arguments[3])s=s.concat(t.slice(0)),s.push(e[0]/n),s=s.concat(e.slice(1));else{s=s.concat(e[0]);const n=t.length;for(let r=0;r<n;++r)s=s.concat([e[r+1]/t[r],t[r]]);s=s.concat(e.slice(n+1))}return s}function nx(e,t){const n=[];if(!(arguments.length>2&&void 0!==arguments[2])||arguments[2]){n.push(t);for(let s=t+1;s<e;++s)s<=2*t?(n.push(s),n.push(s-(t+1))):n.push(s)}else{const s=[],r=[];for(let n=1;n<e;++n)n>=2*t+1||n%2===1?r.push(n):s.push(n);n.push(...s),n.push(0),n.push(...r)}return n}function sx(e,t,n){let s=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const r=[];s?r.push(e[0]/n):r.push(e[0]*n);for(let i=1;i<e.length;++i)i<=t.length?s?r.push(t[i-1]*e[i]):r.push(e[i]/t[i-1]):r.push(e[i]);return r}function rx(e,t){const n=[0];for(let s=0;s<t;++s)n.push(e[s][0]);return n}function ix(e,t,n){const s=e.slice(0,1);for(let r=0;r<n;++r)s.push(e[r+1]-t[r][0]-t[r][1]);return s}function ax(e,t){const n=e.shape.length,s=t.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(s<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${s}.`);if("int32"!==t.dtype)throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[s-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[s-1]} vs. ${n}`);if(0===xo(e.shape))throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${e.shape}.`);const r=t.shape,i=r[r.length-1];let a=1;for(let h=0;h<r.length-1;++h)a*=r[h];const o=e.shape,l=r.slice();l.pop();let u=1;for(let h=i;h<n;++h)u*=o[h],l.push(o[h]);const c=[...Oo(e.shape).map((e=>e/u)),1].slice(0,i);return[l,a,u,c]}function ox(e,t,n){const s=t.rank>1?t.shape[t.rank-1]:1,r=t.rank>1?t.rank-1:1,i=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${s}, and batchDim: ${r}.`;if(n.rank<r)throw new Error(i+` update.rank < ${r}. `);if(e.length<s+(n.rank-r))throw new Error(i+` Output shape length < ${s+(n.rank-r)}`);if(n.rank!==r+e.length-s)throw new Error(i+" update.rank != "+(r+e.length-s));for(let a=0;a<r;++a)if(n.shape[a]!==t.shape[a])throw new Error(i+` updates.shape[${a}] (${n.shape[a]}) != indices.shape[${a}] (${t.shape[a]}).`);for(let a=0;a<n.rank-r;++a)if(n.shape[a+r]!==e[a+s])throw new Error(i+` updates.shape[${a+r}] (${n.shape[a+r]}) != shape[${a+r}] (${e[a+r]})`)}function lx(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if("int32"!==t.dtype)throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(0===n.length){if(0===t.size)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(0===e.size)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}ox(n,t,e)}function ux(e,t,n){const s=t.shape.length,r=s>1?t.shape[s-1]:1,i=n.length;let a=1;for(let l=r;l<i;++l)a*=n[l];const o=r<1?1:r;return{sliceRank:r,numUpdates:xo(t.shape)/o,sliceSize:a,strides:[...Oo(n.slice(0,r)),1],outputSize:xo(n)}}const cx=1.7580993408473768,hx=1.0507009873554805,dx=.3275911,px=.254829592,fx=-.284496736,gx=1.421413741,mx=-1.453152027,bx=1.061405429;function xx(e,t){if(e.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${e.length}, imag: ${t.length}.`);const n=new Float32Array(2*e.length);for(let s=0;s<n.length;s+=2)n[s]=e[s/2],n[s+1]=t[s/2];return n}function yx(e){const t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let s=0;s<e.length;s+=2)t[s/2]=e[s],n[s/2]=e[s+1];return{real:t,imag:n}}function vx(e){const t=Math.ceil(e.length/4),n=new Float32Array(t),s=new Float32Array(t);for(let r=0;r<e.length;r+=4)n[Math.floor(r/4)]=e[r],s[Math.floor(r/4)]=e[r+1];return{real:n,imag:s}}function wx(e){const t=Math.floor(e.length/4),n=new Float32Array(t),s=new Float32Array(t);for(let r=2;r<e.length;r+=4)n[Math.floor(r/4)]=e[r],s[Math.floor(r/4)]=e[r+1];return{real:n,imag:s}}function kx(e,t){return{real:e[2*t],imag:e[2*t+1]}}function Sx(e,t,n,s){e[2*s]=t,e[2*s+1]=n}function Ix(e,t){const n=new Float32Array(e/2),s=new Float32Array(e/2);for(let r=0;r<Math.ceil(e/2);r++){const i=(t?2:-2)*Math.PI*(r/e);n[r]=Math.cos(i),s[r]=Math.sin(i)}return{real:n,imag:s}}function Cx(e,t,n){const s=(n?2:-2)*Math.PI*(e/t);return{real:Math.cos(s),imag:Math.sin(s)}}const Nx="->",Tx=/->/g,_x=",",Ex="...";function $x(e,t){const n=((e=e.replace(/\s/g,"")).length-e.replace(Tx,"").length)/Nx.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${Nx}").`);const[s,r]=e.split(Nx);go(-1===s.indexOf(Ex),(()=>`The ellipsis notation ("${Ex}") is not supported yet.`));const i=s.split(_x),a=i.length;if(t!==a)throw new Error(`Expected ${a} input tensors, received ${t}`);if(a>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const o=[];for(let h=0;h<r.length;++h){const e=r[h];if(!i.some((t=>-1!==t.indexOf(e))))throw new Error(`Output subscripts contain the label ${e} not present in the input subscripts.`);-1===o.indexOf(e)&&o.push(e)}for(let h=0;h<s.length;++h){const e=s[h];-1===o.indexOf(e)&&e!==_x&&o.push(e)}const l=new Array(i.length);for(let h=0;h<a;++h){if(new Set(i[h].split("")).size!==i[h].length)throw new Error(`Found duplicate axes in input component ${i[h]}. Support for duplicate axes in input is not implemented yet.`);l[h]=[];for(let e=0;e<i[h].length;++e)l[h].push(o.indexOf(i[h][e]))}const u=o.length,c=[];for(let h=r.length;h<u;++h)c.push(h);return{allDims:o,summedDims:c,idDims:l}}function Rx(e,t){let n=new Array(e);n.fill(-1);for(let r=0;r<t.length;++r)n[t[r]]=r;const s=[];for(let r=0;r<e;++r)-1===n[r]&&s.push(r);return n=n.filter((e=>-1!==e)),{permutationIndices:n,expandDims:s}}function Ax(e,t,n){const s=new Array(e);for(let r=0;r<n.length;++r){const e=n[r].shape;for(let n=0;n<t[r].length;++n)void 0===s[t[r][n]]?s[t[r][n]]=e[n]:go(s[t[r][n]]===e[n],(()=>`Expected dimension ${s[t[r][n]]} at axis ${n} of input shaped ${JSON.stringify(e)}, but got dimension ${e[n]}`))}}function Dx(e,t){const n=e,s=[];let r=0;0===e.length&&n.push(-1),r=e.length+1;for(let a=0;a<r;++a)s.push([]);const i=[];for(let a=0;a<n.length;++a){const e=Mx(t,n[a]);for(const t of e)-1===i.indexOf(t)&&(s[a].push(t),i.push(t))}return{path:n,steps:s}}function Fx(e){return e.every(((e,t)=>e===t))}function Mx(e,t){const n=[];for(let s=0;s<e.length;++s)0!==e[s].length&&-1===e[s].indexOf(t)&&-1!==t||n.push(s);return n}function Ox(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,s=[];if("number"===typeof t)go(e.shape[n]%t===0,(()=>"Number of splits must evenly divide the axis.")),s=new Array(t).fill(e.shape[n]/t);else{const r=t.reduce(((e,t)=>(-1===t&&(e+=1),e)),0);go(r<=1,(()=>"There should be only one negative value in split array."));const i=t.indexOf(-1);if(-1!==i){const s=t.reduce(((e,t)=>t>0?e+t:e));t[i]=e.shape[n]-s}go(e.shape[n]===t.reduce(((e,t)=>e+t)),(()=>"The sum of sizes must match the size of the axis dimension.")),s=t}return s}function Lx(e){return`Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ${e}`}function Px(e,t){return`indices(${e}, 0) is invalid: ${t} < 0`}function zx(e,t,n){return`indices(${e}, 0) is invalid: ${t} >= ${n}`}function Bx(e,t){return`only one output dimension may be -1, not both ${e} and ${t}`}function Wx(e,t){return`size ${e} must be non-negative, not ${t}`}function Vx(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function Ux(e,t){return`Input to reshape is a SparseTensor with ${xo(e)}\n  dense values, but the requested shape requires a multiple of ${xo(t)}. inputShape=${e} outputShape= ${t}`}function Gx(e,t){return`Input to reshape is a tensor with ${xo(e)} dense values, but the requested shape has ${xo(t)}. inputShape=${e} outputShape=${t}`}function Hx(){return"segment ids must be >= 0"}function jx(){return"segment ids are not increasing"}function Kx(e,t){return`Segment id ${e} out of range [0, ${t}), possibly because segmentIds input is not sorted.`}function Xx(e,t,n){return`Bad: indices[${e}] == ${t} out of range [0, ${n})`}function qx(e,t){let n,s=!1;for(e<=Zb?(n=e,s=!0):n=Mo(e,Math.floor(Math.sqrt(e)));!s;)n>t||n===e?s=!0:n=Mo(e,n+1);return n}function Yx(e,t,n){const s=[],r=e.length;for(let i=0;i<r;i++)i!==t?s.push(e[i]):s.push(n);return s}function Qx(e,t,n,s){const r=t.shape.length,i=e.shape.length;if(0!==s&&(s<-r||s>r))throw new Error(`Expect batchDims in the range of [-${r}, ${r}], but got ${s}`);if(s<0&&(s+=r),s>i)throw new Error(`batchDims (${s}) must be less than rank(x) (\n    ${i}).`);if(n<s)throw new Error(`batchDims (${s}) must be less than or equal to axis (${n}).`);for(let h=0;h<s;++h)if(e.shape[h]!==t.shape[h])throw new Error(`x.shape[${h}]: ${e.shape[h]} should be equal to indices.shape[${h}]: ${t.shape[h]}.`);const a=e.shape[n],o=[];let l=1,u=1,c=1;for(let h=0;h<s;++h)o.push(e.shape[h]),l*=e.shape[h];for(let h=s;h<n;h++)o.push(e.shape[h]),u*=e.shape[h];for(let h=s;h<r;h++)o.push(t.shape[h]);for(let h=n+1;h<i;h++)o.push(e.shape[h]),c*=e.shape[h];return{batchSize:l,sliceSize:c,outerSize:u,dimSize:a,outputShape:o}}function Zx(e){try{return e.map((e=>Bh(e)))}catch(SG){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${SG}`)}}function Jx(e){return e.map((e=>zh(e)))}function ey(e,t){const n=[];for(let i=0;i<t.length;i++)t[i]&&n.push(i);const s=Tp(e,"int32"),r=Tp([n.length,e.length],"int32");for(let i=0;i<n.length;i++){const t=s.indexToLoc(n[i]),a=i*e.length;r.values.set(t,a)}return r.toTensor()}!function(){for(const e of of)Up(e)}();const ty={kernelName:el,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Dp(e,Km(_p(n,"float32"),-1))}}},ny={kernelName:tl,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=Mp(_p(n,"float32")),s=Fp(qp(Pp(1),t));return nm(Ap(e,s))}}}},sy={kernelName:nl,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=Fp(qp(Mp(_p(n,"float32")),1));return Ap(e,t)}}}},ry={kernelName:sl,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,s]=t,r=ef(n.shape,s.shape);return{a:()=>{let t=e;const s=Jp(n.shape,r);return s.length>0&&(t=Lg(t,s)),Jf(t,n.shape)},b:()=>{let t=e;const n=Jp(s.shape,r);return n.length>0&&(t=Lg(t,n)),Jf(t,s.shape)}}}},iy={kernelName:rl,saveAllInputs:!0,gradFunc:(e,t)=>{const n={};return t.forEach(((t,s)=>{n[s]=()=>e.clone()})),n}},ay={kernelName:ol,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Op(n)}}},oy={kernelName:ll,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Op(n)}}},ly={kernelName:ul,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ap(e,Fp(qp(Pp(1),Mp(_p(n,"float32")))))}}},uy={kernelName:cl,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=Fp($p(Pp(1),Mp(_p(n,"float32"))));return Ap(e,t)}}}},cy={kernelName:pl,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,s]=t,r=ef(n.shape,s.shape);return{a:()=>{const t=$p(Mp(n),Mp(s));let i=Dp(e,Ap(s,t));const a=Jp(n.shape,r);return a.length>0&&(i=Lg(i,a)),Jf(i,n.shape)},b:()=>{const t=$p(Mp(n),Mp(s));let i=nm(Dp(e,Ap(n,t)));const a=Jp(s.shape,r);return a.length>0&&(i=Lg(i,a)),Jf(i,s.shape)}}}},hy={kernelName:hl,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ap(e,$p(Mp(_p(n,"float32")),1))}}},dy={kernelName:dl,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ap(e,qp(Pp(1),Mp(_p(n,"float32"))))}}};const py=Dd({avgPool3dGrad_:function(e,t,n,s,r,i){const a=Rd(e,"dy","avgPool3dGrad"),o=Rd(t,"input","avgPool3dGrad");let l=a,u=o,c=!1;4===o.rank&&(c=!0,l=Jf(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),u=Jf(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),go(5===l.rank,(()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`)),go(5===u.rank,(()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${u.rank}.`)),Zf("avgPool3dGrad",r,i);const h={dy:l,input:u},d={filterSize:n,strides:s,pad:r,dimRoundingMode:i},p=kd.runKernel(bl,h,d);return c?Jf(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}}),fy={kernelName:ml,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[s]=t,{filterSize:r,strides:i,pad:a,dimRoundingMode:o}=n;return{x:()=>py(e,s,r,i,a,o)}}};const gy=Dd({avgPoolGrad_:function(e,t,n,s,r){const i=Rd(e,"dy","avgPoolGrad"),a=Rd(t,"input","avgPoolGrad");go(a.rank===i.rank,(()=>`Rank of input (${a.rank}) does not match rank of dy (${i.rank})`));let o=a,l=i,u=!1;3===a.rank&&(u=!0,o=Jf(a,[1,a.shape[0],a.shape[1],a.shape[2]]),l=Jf(i,[1,i.shape[0],i.shape[1],i.shape[2]])),go(4===l.rank,(()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`)),go(4===o.rank,(()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`));const c={dy:l,input:o},h={filterSize:n,strides:s,pad:r},d=kd.runKernel(gl,c,h);return u?Jf(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),my={kernelName:fl,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[s]=t,{filterSize:r,strides:i,pad:a}=n;return{x:()=>gy(e,s,r,i,a)}}},by={kernelName:xl,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{const[s,r]=t,{transposeA:i,transposeB:a}=n;return i||a?!i&&a?{a:()=>qg(e,r,!1,!1),b:()=>qg(e,s,!0,!1)}:i&&!a?{a:()=>qg(r,e,!1,!0),b:()=>qg(s,e,!1,!1)}:{a:()=>qg(r,e,!0,!0),b:()=>qg(e,s,!0,!0)}:{a:()=>qg(e,r,!1,!0),b:()=>qg(s,e,!0,!1)}}};const xy=Dd({spaceToBatchND_:function(e,t,n){const s=Rd(e,"x","spaceToBatchND");go(s.rank>=1+t.length,(()=>`input rank ${s.rank} should be > than [blockShape] ${t.length}`)),go(n.length===t.length,(()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${t.length}`)),go(s.shape.reduce(((e,s,r)=>r>0&&r<=t.length?e&&(s+n[r-1][0]+n[r-1][1])%t[r-1]===0:e),!0),(()=>`input spatial dimensions ${s.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${t.toString()}`));const r={x:s},i={blockShape:t,paddings:n};return kd.runKernel(Dc,r,i)}}),yy={kernelName:yl,gradFunc:(e,t,n)=>{const{blockShape:s,crops:r}=n;return{x:()=>xy(e,s,r)}}},vy={kernelName:"BroadcastTo",gradFunc:(e,t,n)=>{const s=n,r=s.inputShape,i=s.shape,a=Array.from(i);for(let l=r.length-1;l>=0;l--)if(r[l]===i[l])a[l]=1;else if(1!==r[l])throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${i}].`);const o=[];for(let l=0;l<a.length;l++)a[l]>1&&o.push(l);return{x:()=>Lg(e,o,!0)}}},wy={kernelName:Sl,gradFunc:e=>({x:()=>e.clone()})},ky={kernelName:Il,gradFunc:e=>({x:()=>Op(e)})},Sy={kernelName:Cl,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[s]=t,{clipValueMin:r,clipValueMax:i}=n;return{x:()=>Om(Xg(Ag(s,r),Tb(s,i)),e,Op(e))}}},Iy={kernelName:Tl,inputsToSave:["x"],gradFunc:ty.gradFunc},Cy={kernelName:_l,saveAllInputs:!0,gradFunc:(e,t,n)=>{const s=t.map((e=>e.shape)),{axis:r}=n,i=Co(r,t[0].shape)[0],a=s.map((e=>e[i]));return _m(e,a,i).map((e=>()=>e))}},Ny={kernelName:El,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[s,r]=t,{dilations:i,strides:a,pad:o,dataFormat:l}=n;return go(Xf(i),(()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`)),{x:()=>gg(s.shape,e,r,a,o,l),filter:()=>Hm(s,e,r.shape,a,o,l)}}},Ty={kernelName:Rl,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{const[s,r]=t,{strides:i,pad:a,dataFormat:o,dimRoundingMode:l}=n;return{dy:()=>pg(e,r,i,a,o,1,l),filter:()=>Hm(e,s,r.shape,i,a,o,l)}}};const _y=Dd({conv3DBackpropFilter_:function(e,t,n,s,r){let i=e;4===e.rank&&(i=Jf(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let a=t;4===a.rank&&(a=Jf(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),go(5===i.rank,(()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${i.shape}.`)),go(5===a.rank,(()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${a.shape}.`)),go(5===n.length,(()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${n}.`)),go(i.shape[4]===n[3],(()=>`Error in conv3dDerFilter: depth of input ${i.shape[4]}) must match input depth in filter (${n[3]}.`)),go(a.shape[4]===n[4],(()=>`Error in conv3dDerFilter: depth of dy (${a.shape[4]}) must match output depth for filter (${n[4]}).`));const o={x:i,dy:a},l={strides:s,pad:r,filterShape:n};return kd.runKernel(Dl,o,l)}}),Ey={kernelName:Al,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:s,strides:r,pad:i}=n;go(Xf(s),(()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`));const[a,o]=t;return{x:()=>xg(a.shape,e,o,r,i),filter:()=>_y(a,e,o.shape,r,i)}}};const $y=Dd({sin_:function(e){const t={x:Rd(e,"x","sin","float32")};return kd.runKernel(Nc,t)}}),Ry={kernelName:Ml,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Dp(nm($y(_p(n,"float32"))),e)}}};const Ay=Dd({sinh_:function(e){const t={x:Rd(e,"x","sinh")};return kd.runKernel(Tc,t)}}),Dy={kernelName:Ol,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Dp(Ay(_p(n,"float32")),e)}}};const Fy=Dd({cumsum_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],s=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r={x:Rd(e,"x","cumsum")},i={axis:t,exclusive:n,reverse:s};return kd.runKernel(Pl,r,i)}}),My={kernelName:Pl,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[s]=t,{axis:r,exclusive:i,reverse:a}=n;return{x:()=>{const t=Gg([r],s.rank);let n=Fy(e,r,i,!a);return null!=t&&(n=zm(n,t)),n}}}},Oy={kernelName:Vl,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:s,strides:r,pad:i,dimRoundingMode:a}=n,o=null==s?[1,1]:s;go(Xf(o),(()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`));const[l,u]=t;return go(4===l.rank,(()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`)),go(4===u.rank,(()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${u.rank}.`)),go(l.shape[3]===u.shape[2],(()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`)),go(qf(r,o),(()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${r} and dilations '${o}'.`)),Zf("depthwiseConv2d",i,a),{x:()=>eb(l.shape,e,u,r,i,o,a),filter:()=>Jm(l,e,u.shape,r,i,o,a)}}},Ly={kernelName:jl,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[s,r]=t,i={x:s,filter:r,dy:e},a={x:s,filter:r,dy:e};return{x:()=>kd.runKernel(Kl,i,n),filter:()=>kd.runKernel(Xl,a,n)}}},Py={kernelName:Zl,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t,s={dy:e,y:n};return{x:()=>kd.runKernel(Jl,s)}}},zy={kernelName:eu,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,s=Dp(Cg(nm(Mp(n))),2/Math.sqrt(Math.PI));return{x:()=>Dp(e,s)}}},By={kernelName:nu,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Dp(e,n)}}},Wy={kernelName:su,inputsToSave:["input"],gradFunc:(e,t)=>{const[n]=t;return{input:()=>Jf(e,n.shape)}}},Vy={kernelName:ru,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Dp(e,Cg(n))}}},Uy={kernelName:lu,gradFunc:e=>({x:()=>Op(e)})},Gy={kernelName:uu,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,s]=t,r=ef(n.shape,s.shape);return{a:()=>{const t=Ap(e,_p(s,"float32")),i=Jp(n.shape,r);return i.length>0?Jf(Lg(t,i),n.shape):t},b:()=>{let t=Dp(e,_p(n,"float32"));const i=Jp(s.shape,r);i.length>0&&(t=Jf(Lg(t,i),s.shape));const a=Mp(s);return nm(Ap(t,_p(a,"float32")))}}}};const Hy=Dd({rsqrt_:function(e){const t={x:Rd(e,"x","rsqrt","float32")};return kd.runKernel(yc,t)}}),jy={kernelName:cu,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{const{varianceEpsilon:s}=n,[r,i,a,o]=t,l=null==o?Pp(1):o,u=Jp(i.shape,r.shape),c=[];if(1===i.rank){for(let e=0;e<r.shape.length-1;++e)c.push(r.shape[e]);c.push(1)}const h=qp(r,i),d=Dp(e,l),p=Hy($p(a,Pp(s))),f=Dp(Dp(Dp(p,p),p),Pp(-.5));return{x:()=>1===i.rank?Jf(Dp(Dp(e,Tg(Jf(p,[1,1,1,i.shape[0]]),c)),l),r.shape):Jf(Dp(Dp(e,p),l),r.shape),mean:()=>{let e=Dp(Dp(p,Pp(-1)),d);return 1===i.rank&&(e=Lg(e,u)),Jf(e,i.shape)},variance:()=>{let e=Dp(Dp(f,h),d);return 1===i.rank&&(e=Lg(e,u)),Jf(e,i.shape)},scale:()=>{const t=Dp(h,p);let n=Dp(e,t);return 1===i.rank&&(n=Lg(n,u)),Jf(n,i.shape)},offset:()=>{let t=e;return 1===i.rank&&(t=Lg(t,u)),Jf(t,i.shape)}}}};const Ky=Dd({unsortedSegmentSum_:function(e,t,n){const s=Rd(e,"x","unsortedSegmentSum"),r=Rd(t,"segmentIds","unsortedSegmentSum","int32");go(vo(n),(()=>"numSegments must be of dtype int"));const i={x:s,segmentIds:r},a={numSegments:n};return kd.runKernel(sh,i,a)}}),Xy={kernelName:hu,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{const[s,r]=t,{axis:i,batchDims:a}=n,o=Co(i,s.shape)[0],l=(e,t,n)=>()=>{const s=e.shape,r=t.size,a=s.slice(0,o),l=a.length,u=s.slice(i,s.length).slice(1),c=u.length,h=qy(0,l),d=qy(l+1,l+1+c),p=Yy([a,[r],u]),f=Jf(n,p),g=Jf(t,[r]),m=Yy([[l],h,d]),b=zm(f,m);let x=Ky(b,g,e.shape[o]);const y=Hg(m);return x=zm(x,y),x};if(1===a){const t=s.shape[0],n=s.split(t,0);return{x:()=>{const t=$m(n.map(((t,n)=>l(t,r.slice(n,1),e.slice(n,1))())));return t.reshape(s.shape)},indices:()=>r}}return{x:l(s,r,e),indices:()=>r}}};function qy(e,t){const n=[];for(let s=e;s<t;++s)n.push(s);return n}function Yy(e){const t=[];for(let n=0;n<e.length;++n)for(let s=0;s<e[n].length;++s)t.push(e[n][s]);return t}const Qy={kernelName:fu,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,s]=t;return{a:()=>Op(n),b:()=>Op(s)}}},Zy={kernelName:gu,gradFunc:e=>({x:()=>_p(e,"float32")})},Jy={kernelName:xu,gradFunc:e=>({x:()=>Op(e)})},ev={kernelName:yu,gradFunc:e=>({x:()=>Op(e)})},tv={kernelName:vu,gradFunc:e=>({x:()=>Op(e)})},nv={kernelName:wu,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[s]=t,{alpha:r}=n,i=Rg(s,0);return{x:()=>Om(i,e,Dp(e,r))}}},sv={kernelName:Nu,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ap(e,$p(n,1))}}},rv={kernelName:Cu,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ap(e,_p(n,"float32"))}}},iv={kernelName:"LogSoftmax",inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[s]=t,{axis:r}=n;return{logits:()=>{const t=Cg(s);return qp(e,Dp(Lg(e,r,!0),t))}}}};const av=Dd({localResponseNormalizationBackprop_:function(e,t,n){const s={x:e,y:t,dy:n},r={depthRadius:arguments.length>3&&void 0!==arguments[3]?arguments[3]:5,bias:arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,alpha:arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,beta:arguments.length>6&&void 0!==arguments[6]?arguments[6]:.5};return kd.runKernel(Ru,s,r)}}),ov={kernelName:$u,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[s,r]=t,{depthRadius:i,bias:a,alpha:o,beta:l}=n;return{x:()=>av(s,r,e,i,a,o,l)}}};function lv(e,t,n,s){return t.rank<n.rank&&(t=Jf(t,Vg(t.shape,s))),e.rank<n.rank&&(e=Jf(e,Vg(e.shape,s))),{x:()=>Dp(e,_p(Sg(n,t),e.dtype))}}const uv={kernelName:Au,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const s=n,{reductionIndices:r}=s,i=t[0],a=lv(e,t[1],i,Co(r,i.shape));return{x:()=>a.x()}}},cv={kernelName:Du,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,s]=t;return{a:()=>Dp(e,_p(Ag(n,s),"float32")),b:()=>Dp(e,_p(Rb(n,s),"float32"))}}};const hv=Dd({maxPool3dGrad_:function(e,t,n,s,r,i,a){const o=Rd(e,"dy","maxPool3dGrad"),l=Rd(t,"input","maxPool3dGrad"),u=Rd(n,"output","maxPool3dGrad");let c=o,h=l,d=u,p=!1;4===l.rank&&(p=!0,c=Jf(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),h=Jf(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),d=Jf(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),go(5===c.rank,(()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`)),go(5===h.rank,(()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${h.rank}.`)),go(5===d.rank,(()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${d.rank}.`)),Zf("maxPool3dGrad",i,a);const f={dy:c,input:h,output:d},g={filterSize:s,strides:r,pad:i,dimRoundingMode:a},m=kd.runKernel(Lu,f,g);return p?Jf(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}}),dv={kernelName:Ou,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[s,r]=t,{filterSize:i,strides:a,pad:o,dimRoundingMode:l}=n;return{x:()=>hv(e,s,r,i,a,o,l)}}};const pv=Dd({maxPoolGrad_:function(e,t,n,s,r,i,a){const o=Rd(e,"dy","maxPoolGrad"),l=Rd(t,"input","maxPoolGrad"),u=Rd(n,"output","maxPoolGrad");go(l.rank===o.rank,(()=>`Rank of input (${l.rank}) does not match rank of dy (${o.rank})`)),go(4===o.rank,(()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`)),go(4===l.rank,(()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`)),Zf("maxPoolGrad",i,a);const c={dy:o,input:l,output:u},h={filterSize:s,strides:r,pad:i,dimRoundingMode:a};return kd.runKernel(Mu,c,h)}}),fv={kernelName:Fu,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[s,r]=t,{filterSize:i,strides:a,pad:o}=n;return{x:()=>pv(e,s,r,i,a,o)}}},gv={kernelName:zu,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[s]=t,{axis:r}=n,i=Co(r,s.shape),a=xo(Wg(s.shape,i)[1]);return{x:()=>{const t=s.shape.slice();i.forEach((e=>{t[e]=1}));const n=Jf(e,t);return Ap(Dp(n,am(s.shape,"float32")),a)}}}},mv={kernelName:Bu,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const s=n,{axis:r}=s,[i,a]=t,o=lv(e,a,i,Co(r,i.shape));return{x:()=>o.x()}}},bv={kernelName:Wu,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,s]=t;return{a:()=>Dp(e,_p(Tb(n,s),"float32")),b:()=>Dp(e,_p(Rg(n,s),"float32"))}}},xv={kernelName:Vu,inputsToSave:["x"],gradFunc:(e,t,n)=>{const s=t[0],{paddings:r}=n,i=r.map((e=>e[0]));return{x:()=>wm(e,i,s.shape)}}},yv={kernelName:Uu,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,s]=t,r=ef(n.shape,s.shape);return{a:()=>{const t=Jp(n.shape,r);return t.length>0?Jf(Lg(e,t),n.shape):e},b:()=>{const t=Dp(e,nm(Eg(Ap(n,s)))),i=Jp(s.shape,r);return i.length>0?Jf(Lg(t,i),s.shape):t}}}},vv={kernelName:Hu,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,s]=t,r=ef(n.shape,s.shape);return{a:()=>{const t=Dp(e,_p(s,"float32")),i=Jp(n.shape,r);return i.length>0?Jf(Lg(t,i),n.shape):t},b:()=>{const t=Dp(e,_p(n,"float32")),i=Jp(s.shape,r);return i.length>0?Jf(Lg(t,i),s.shape):t}}}},wv={kernelName:ju,gradFunc:e=>({x:()=>nm(e)})},kv={kernelName:Zu,inputsToSave:["indices"],gradFunc:(e,t)=>{const n=t[0];return{indices:()=>im(n.shape,"float32")}}},Sv={kernelName:Qu,gradFunc:e=>({x:()=>Op(e)})},Iv={kernelName:Ju,saveAllInputs:!0,gradFunc:(e,t,n)=>{const{axis:s}=n;return Mm(e,s).map((e=>()=>e))}},Cv={kernelName:ec,inputsToSave:["x"],gradFunc:(e,t,n)=>{const s=t[0],{paddings:r}=n,i=r.map((e=>e[0]));return{x:()=>wm(e,i,s.shape)}}},Nv={kernelName:tc,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{const[n,s,r]=t,i=n,a=s,o=ef(i.shape,a.shape);return{a:()=>{const t=_p(a,"float32");let n=Dp(e,Dp(t,Xp(i,qp(t,Pp(1)))));const s=Jp(i.shape,o);return s.length>0&&(n=Lg(n,s)),Jf(n,i.shape)},b:()=>{const t=Rg(i,0),n=Om(t,Fg(i),Op(i));let s=Dp(e,Dp(r,n));const l=Jp(a.shape,o);return l.length>0&&(s=Lg(s,l)),Jf(s,a.shape)}}}},Tv={kernelName:nc,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{const[n,s]=t,r=Rg(n,0);return{x:()=>Om(r,e,Dp(e,s)),alpha:()=>{let t=Om(r,Op(e),Dp(e,n));const i=Jp(s.shape,e.shape);return i.length>0&&(t=Lg(t,i)),Jf(t,s.shape)}}}};const _v=Dd({cumprod_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],s=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r={x:Rd(e,"x","cumprod")},i={axis:t,exclusive:n,reverse:s};return kd.runKernel(Ll,r,i)}});function Ev(e,t,n){const s=e.shape.length,r=s-n.length,i=Gg(n,s);let a=e;null!=i&&(a=zm(e,i));const o=a.shape.slice(),l=o.splice(s-n.length,n.length).reduce(((e,t)=>e*t),1);o.push(l);let u=function(e,t,n){const s=e.shape.slice();s[n]=1;const r=Jf(t,s),i=_v(e,n,!0,!1),a=_v(e,n,!0,!0),o=Dp(i,a);return Dp(r,o)}(a.reshape(o),t,r);if(u=u.reshape(a.shape),null!=i){const e=Hg(i);u=zm(u,e)}return u}const $v={kernelName:sc,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[s]=t,{axis:r}=n;let i=[];return i=void 0===r||null===r?s.shape.map(((e,t)=>t)):"number"===typeof r?[r]:r,{x:()=>Ev(s,e,i)}}},Rv={kernelName:Yl,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,s]=t,r=ef(n.shape,s.shape);return{a:()=>{const t=Ap(e,_p(s,"float32")),i=Jp(n.shape,r);return i.length>0?Jf(Lg(t,i),n.shape):t},b:()=>{let t=Dp(e,_p(n,"float32"));const i=Jp(s.shape,r);i.length>0&&(t=Jf(Lg(t,i),s.shape));const a=Mp(s);return nm(Ap(t,_p(a,"float32")))}}}},Av={kernelName:uc,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ap(e,nm(Mp(n)))}}},Dv={kernelName:mc,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,s=Dp(Tb(n,6),Km(n));return{x:()=>Dp(e,_p(s,"float32"))}}},Fv={kernelName:cc,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Dp(e,_p(Km(n),"float32"))}}},Mv={kernelName:hc,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Jf(e,n.shape)}}},Ov={kernelName:fc,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[s]=t,r={dy:e,images:s};return{images:()=>kd.runKernel(gc,r,n)}}},Lv={kernelName:dc,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[s]=t,r={dy:e,images:s};return{images:()=>kd.runKernel(pc,r,n)}}},Pv={kernelName:bc,gradFunc:(e,t,n)=>{const{dims:s}=n,r=Co(s,e.shape);return{x:()=>bm(e,r)}}},zv={kernelName:xc,gradFunc:e=>({x:()=>Op(e)})},Bv={kernelName:yc,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>nm(Ap(e,Dp(Xp(n,1.5),2)))}}};const Wv=Dd({logicalNot_:function(e){const t={x:Rd(e,"x","logicalNot","bool")};return kd.runKernel(_u,t)}}),Vv={kernelName:Sc,inputsToSave:["condition"],gradFunc:(e,t)=>{const[n]=t;return{condition:()=>_p(Op(n),"float32"),t:()=>Dp(e,_p(n,e.dtype)),e:()=>Dp(e,_p(Wv(n),e.dtype))}}},Uv={kernelName:Ic,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=Rg(n,Pp(0)),s=Pp(cx),r=Pp(hx),i=Dp(e,r),a=Dp(Dp(e,s),Cg(_p(n,"float32")));return Om(t,i,a)}}}},Gv={kernelName:Ec,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Dp(e,Dp(n,qp(Pp(1),n)))}}},Hv={kernelName:_c,gradFunc:e=>({x:()=>Op(e)})};const jv=Dd({cos_:function(e){const t={x:Rd(e,"x","cos","float32")};return kd.runKernel(Ml,t)}}),Kv={kernelName:Nc,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Dp(jv(_p(n,"float32")),e)}}};const Xv=Dd({cosh_:function(e){const t={x:Rd(e,"x","cosh","float32")};return kd.runKernel(Ol,t)}}),qv={kernelName:Tc,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Dp(Xv(_p(n,"float32")),e)}}},Yv={kernelName:Cc,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[s]=t,{begin:r,size:i}=n,a=s.shape,[o,l]=Af(s,r,i),u=[];for(let c=0;c<e.rank;c++)u.push([o[c],a[c]-o[c]-l[c]]);return{x:()=>lm(e,u)}}},Qv={kernelName:Mc,outputsToSave:[!0],gradFunc:(e,t,n)=>{const[s]=t,{dim:r}=n,i=Dp(e,s);return{logits:()=>qp(i,Dp(Lg(i,[r],true),s))}}},Zv={kernelName:$c,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Dp(e,vm(n))}}};const Jv=Dd({batchToSpaceND_:function(e,t,n){const s=Rd(e,"x","batchToSpaceND"),r=t.reduce(((e,t)=>e*t));go(s.rank>=1+t.length,(()=>`input rank is ${s.rank} but should be > than blockShape.length ${t.length}`)),go(n.length===t.length,(()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${t.length}`)),go(s.shape[0]%r===0,(()=>`input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${r}`));const i={x:s},a={blockShape:t,crops:n};return kd.runKernel(yl,i,a)}}),ew={kernelName:Dc,gradFunc:(e,t,n)=>{const{blockShape:s,paddings:r}=n;return{x:()=>Jv(e,s,r)}}},tw={kernelName:Fc,gradFunc:(e,t,n)=>{const{axis:s}=n;return{x:()=>lg(e,s)}}};const nw=[ty,ny,sy,ry,iy,ay,oy,ly,uy,cy,hy,dy,fy,my,by,yy,vy,wy,ky,Sy,Iy,Cy,Ty,Ny,Ey,Ry,Dy,My,Oy,Ly,Rv,Py,zy,By,Wy,Vy,Gy,Uy,jy,Xy,Qy,Zy,Jy,ev,tv,nv,sv,rv,iv,ov,uv,uv,cv,dv,fv,gv,mv,bv,xv,yv,vv,wv,kv,Sv,Iv,Cv,Cv,Nv,Tv,$v,Av,Dv,Fv,Mv,Ov,Lv,Pv,zv,Bv,Vv,Uv,Gv,Hv,Kv,qv,Yv,Qv,Zv,ew,ew,tw,tw,{kernelName:Rc,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ap(e,Dp(Fp(_p(n,"float32")),2))}}},{kernelName:Wc,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,s]=t,r=Pp(2);return{a:()=>Dp(e,Dp(r,qp(n,s))),b:()=>Dp(e,Dp(r,qp(s,n)))}}},{kernelName:Vc,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Dp(e,Dp(_p(n,"float32"),2))}}},{kernelName:ih,gradFunc:e=>({x:()=>Op(e)})},{kernelName:Xc,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,s]=t,r=ef(n.shape,s.shape);return{a:()=>{let t=e;const s=Jp(n.shape,r);return s.length>0&&(t=Lg(t,s)),Jf(t,n.shape)},b:()=>{let t=e;const n=Jp(s.shape,r);return n.length>0&&(t=Lg(t,n)),Jf(nm(t),s.shape)}}}},{kernelName:Ac,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[s]=t,r=s.shape.slice(),{axis:i}=n;Co(i,s.shape).forEach((e=>{r[e]=1}));const a=Jf(e,r),o=Dp(a,am(s.shape,"float32"));return{x:()=>o}}},{kernelName:qc,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Ap(e,Mp(jv(n)))}}},{kernelName:Yc,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Dp(qp(Pp(1),Mp(n)),e)}}},{kernelName:Qc,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[s]=t,{reps:r}=n;return{x:()=>{let t=Op(s);if(1===s.rank)for(let n=0;n<r[0];++n)t=$p(t,wm(e,[n*s.shape[0]],[s.shape[0]]));else if(2===s.rank)for(let n=0;n<r[0];++n)for(let i=0;i<r[1];++i)t=$p(t,wm(e,[n*s.shape[0],i*s.shape[1]],[s.shape[0],s.shape[1]]));else if(3===s.rank)for(let n=0;n<r[0];++n)for(let i=0;i<r[1];++i)for(let a=0;a<r[2];++a)t=$p(t,wm(e,[n*s.shape[0],i*s.shape[1],a*s.shape[2]],[s.shape[0],s.shape[1],s.shape[2]]));else{if(4!==s.rank)throw new Error(`Gradient for tile operation is not implemented for rank-${s.rank} tensors yet.`);for(let n=0;n<r[0];++n)for(let i=0;i<r[1];++i)for(let a=0;a<r[2];++a)for(let o=0;o<r[3];++o)t=$p(t,wm(e,[n*s.shape[0],i*s.shape[1],a*s.shape[2],o*s.shape[3]],[s.shape[0],s.shape[1],s.shape[2],s.shape[3]]))}return t}}}},{kernelName:eh,gradFunc:(e,t,n)=>{const s=n,{perm:r}=s,i=Hg(r);return{x:()=>zm(e,i)}}},{kernelName:nh,gradFunc:(e,t,n)=>{const s=n,{axis:r}=s;return{value:()=>$m(e,r)}}},{kernelName:sh,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>function(e,t){const n=tf(t,Op(t)),s=$g(e,n);let r=Ag(t,Pp(0,"int32"));const i=s.rank-r.rank;for(let o=0;o<i;++o)r=Ng(r,o+1);r=Xg(r,am(s.shape,"bool"));const a=Op(s);return Om(r,s,a)}(e,n)}}},{kernelName:rh,gradFunc:e=>({x:()=>Op(e)})}];for(const n of nw)yh(n);nd().prototype.abs=function(){return this.throwIfDisposed(),Qp(this)};const sw=Dd({acos_:function(e){const t={x:Rd(e,"x","acos")};return kd.runKernel(tl,t)}});nd().prototype.acos=function(){return this.throwIfDisposed(),sw(this)};const rw=Dd({acosh_:function(e){const t={x:Rd(e,"x","acosh")};return kd.runKernel(nl,t)}});nd().prototype.acosh=function(){return this.throwIfDisposed(),rw(this)},nd().prototype.add=function(e){return this.throwIfDisposed(),$p(this,e)},nd().prototype.all=function(e,t){return this.throwIfDisposed(),Mf(this,e,t)},nd().prototype.any=function(e,t){return this.throwIfDisposed(),Of(this,e,t)},nd().prototype.argMax=function(e){return this.throwIfDisposed(),Lf(this,e)};const iw=Dd({argMin_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:Rd(e,"x","argMin")},s={axis:t};return kd.runKernel(ll,n,s)}});nd().prototype.argMin=function(e){return this.throwIfDisposed(),iw(this,e)},nd().prototype.asScalar=function(){return this.throwIfDisposed(),go(1===this.size,(()=>"The array must have only 1 element.")),Jf(this,[])},nd().prototype.asType=function(e){return this.throwIfDisposed(),_p(this,e)},nd().prototype.as1D=function(){return this.throwIfDisposed(),Jf(this,[this.size])},nd().prototype.as2D=function(e,t){return this.throwIfDisposed(),Jf(this,[e,t])},nd().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),Jf(this,[e,t,n])},nd().prototype.as4D=function(e,t,n,s){return this.throwIfDisposed(),Jf(this,[e,t,n,s])},nd().prototype.as5D=function(e,t,n,s,r){return this.throwIfDisposed(),Jf(this,[e,t,n,s,r])};const aw=Dd({asin_:function(e){const t={x:Rd(e,"x","asin")};return kd.runKernel(ul,t)}});nd().prototype.asin=function(){return this.throwIfDisposed(),aw(this)};const ow=Dd({asinh_:function(e){const t={x:Rd(e,"x","asinh")};return kd.runKernel(cl,t)}});nd().prototype.asinh=function(){return this.throwIfDisposed(),ow(this)};const lw=Dd({atan_:function(e){const t={x:Rd(e,"x","atan")};return kd.runKernel(hl,t)}});nd().prototype.atan=function(){return this.throwIfDisposed(),lw(this)};const uw=Dd({atan2_:function(e,t){let n=Rd(e,"a","atan2"),s=Rd(t,"b","atan2");[n,s]=fd(n,s);const r={a:n,b:s};return kd.runKernel(pl,r)}});nd().prototype.atan2=function(e){return this.throwIfDisposed(),uw(this,e)};const cw=Dd({atanh_:function(e){const t={x:Rd(e,"x","atanh")};return kd.runKernel(dl,t)}});nd().prototype.atanh=function(){return this.throwIfDisposed(),cw(this)},nd().prototype.avgPool=function(e,t,n,s){return this.throwIfDisposed(),eg(this,e,t,n,s)},nd().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),Jv(this,e,t)},nd().prototype.batchNorm=function(e,t,n,s,r){return this.throwIfDisposed(),ng(this,e,t,n,s,r)},nd().prototype.broadcastTo=function(e){return this.throwIfDisposed(),ag(this,e)},nd().prototype.cast=function(e){return this.throwIfDisposed(),_p(this,e)};const hw=Dd({ceil_:function(e){const t={x:Rd(e,"x","ceil","float32")};return kd.runKernel(Il,t)}});nd().prototype.ceil=function(){return this.throwIfDisposed(),hw(this)},nd().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),og(this,e,t)},nd().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof td&&(e=[e]),lg([this,...e],t)},nd().prototype.conv1d=function(e,t,n,s,r,i){return this.throwIfDisposed(),fg(this,e,t,n,s,r,i)},nd().prototype.conv2dTranspose=function(e,t,n,s,r){return this.throwIfDisposed(),mg(this,e,t,n,s,r)},nd().prototype.conv2d=function(e,t,n,s,r,i){return this.throwIfDisposed(),pg(this,e,t,n,s,r,i)},nd().prototype.cos=function(){return this.throwIfDisposed(),jv(this)},nd().prototype.cosh=function(){return this.throwIfDisposed(),Xv(this)},nd().prototype.cumprod=function(e,t,n){return this.throwIfDisposed(),_v(this,e,t,n)},nd().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),Fy(this,e,t,n)};const dw=Dd({depthToSpace_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"NHWC";const s=Rd(e,"x","depthToSpace","float32"),r="NHWC"===n?s.shape[1]:s.shape[2],i="NHWC"===n?s.shape[2]:s.shape[3],a="NHWC"===n?s.shape[3]:s.shape[1];go(t>1,(()=>`blockSize should be > 1 for depthToSpace, but was: ${t}`)),go(r*t>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${r} and ${t}  for depthToSpace with input shape\n    ${s.shape}`)),go(i*t>=0,(()=>`Negative dimension size caused by overflow when multiplying\n    ${i} and ${t} for depthToSpace with input shape\n        ${s.shape}`)),go(a%(t*t)===0,(()=>`Dimension size must be evenly divisible by ${t*t} but is ${a} for depthToSpace with input shape ${s.shape}`));const o={x:s},l={blockSize:t,dataFormat:n};return kd.runKernel(Wl,o,l)}});nd().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),dw(this,e,t)},nd().prototype.depthwiseConv2d=function(e,t,n,s,r,i){return this.throwIfDisposed(),wg(this,e,t,n,s,r,i)};const pw=Dd({dilation2d_:function(e,t,n,s){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:[1,1],i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC";const a=Rd(e,"x","dilation2d"),o=Rd(t,"filter","dilation2d");go(3===a.rank||4===a.rank,(()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${a.rank}.`)),go(3===o.rank,(()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`)),go("NHWC"===i,(()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${i}`));let l=a,u=!1;3===a.rank&&(l=Jf(a,[1,a.shape[0],a.shape[1],a.shape[2]]),u=!0),go(l.shape[3]===o.shape[2],(()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${o.shape[2]}`));const c={x:l,filter:o},h={strides:n,pad:s,dilations:r},d=kd.runKernel(jl,c,h);return u?Jf(d,[d.shape[1],d.shape[2],d.shape[3]]):d}});nd().prototype.dilation2d=function(e,t,n,s,r){return this.throwIfDisposed(),pw(this,e,t,n,s,r)};const fw=Dd({divNoNan_:function(e,t){let n=Rd(e,"a","div"),s=Rd(t,"b","div");[n,s]=fd(n,s);const r=Ap(n,s),i=Op(r),a=Sg(s,i);return Om(a,i,r)}});nd().prototype.divNoNan=function(e){return this.throwIfDisposed(),fw(this,e)},nd().prototype.div=function(e){return this.throwIfDisposed(),Ap(this,e)};const gw=Dd({dot_:function(e,t){const n=Rd(e,"t1","dot"),s=Rd(t,"t2","dot");go((1===n.rank||2===n.rank)&&(1===s.rank||2===s.rank),(()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${s.rank}.`));const r=1===n.rank?n.size:n.shape[1],i=1===s.rank?s.size:s.shape[0];if(go(r===i,(()=>`Error in dot: inner dimensions of inputs must match, but got ${r} and ${i}.`)),1===n.rank&&1===s.rank){const e=Jf(n,[1,-1]),t=Jf(s,[-1,1]),r=qg(e,t);return Jf(r,[])}if(1===n.rank&&2===s.rank){const e=Jf(n,[1,-1]),t=Jf(s,[s.shape[0],s.shape[1]]),r=qg(e,t);return Jf(r,[r.size])}if(2===n.rank&&1===s.rank){const e=Jf(s,[-1,1]),t=qg(n,e);return Jf(t,[t.size])}{const e=Jf(s,[s.shape[0],s.shape[1]]);return qg(n,e)}}});nd().prototype.dot=function(e){return this.throwIfDisposed(),gw(this,e)},nd().prototype.elu=function(){return this.throwIfDisposed(),kg(this)},nd().prototype.equal=function(e){return this.throwIfDisposed(),Sg(this,e)},nd().prototype.erf=function(){return this.throwIfDisposed(),Ig(this)};const mw=Dd({euclideanNorm_:function(e){return Fb(e,"euclidean",arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,arguments.length>2&&void 0!==arguments[2]&&arguments[2])}});nd().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),mw(this,e,t)},nd().prototype.exp=function(){return this.throwIfDisposed(),Cg(this)},nd().prototype.expandDims=function(e){return this.throwIfDisposed(),Ng(this,e)};const bw=Dd({expm1_:function(e){const t={x:Rd(e,"x","expm1")};return kd.runKernel(ru,t)}});nd().prototype.expm1=function(){return this.throwIfDisposed(),bw(this)},nd().prototype.fft=function(){return this.throwIfDisposed(),Wm(this)},nd().prototype.flatten=function(){return this.throwIfDisposed(),Jf(this,[this.size])},nd().prototype.floor=function(){return this.throwIfDisposed(),Eg(this)},nd().prototype.floorDiv=function(e){return this.throwIfDisposed(),Rp(this,e)},nd().prototype.gather=function(e,t,n){return this.throwIfDisposed(),$g(this,e,t,n)},nd().prototype.greaterEqual=function(e){return this.throwIfDisposed(),Ag(this,e)},nd().prototype.greater=function(e){return this.throwIfDisposed(),Rg(this,e)},nd().prototype.ifft=function(){return this.throwIfDisposed(),Um(this)},nd().prototype.irfft=function(){return this.throwIfDisposed(),Gm(this)};const xw=Dd({isFinite_:function(e){const t={x:Rd(e,"x","isFinite")};return kd.runKernel(xu,t)}});nd().prototype.isFinite=function(){return this.throwIfDisposed(),xw(this)};const yw=Dd({isInf_:function(e){const t={x:Rd(e,"x","isInf")};return kd.runKernel(yu,t)}});nd().prototype.isInf=function(){return this.throwIfDisposed(),yw(this)};const vw=Dd({isNaN_:function(e){const t={x:Rd(e,"x","isNaN")};return kd.runKernel(vu,t)}});nd().prototype.isNaN=function(){return this.throwIfDisposed(),vw(this)},nd().prototype.leakyRelu=function(e){return this.throwIfDisposed(),Dg(this,e)},nd().prototype.lessEqual=function(e){return this.throwIfDisposed(),Tb(this,e)},nd().prototype.less=function(e){return this.throwIfDisposed(),Rb(this,e)};const ww=Dd({localResponseNormalization_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:5,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5;const i=Rd(e,"x","localResponseNormalization");go(4===i.rank||3===i.rank,(()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ${i.rank}.`)),go(vo(t),(()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`));let a=i,o=!1;3===i.rank&&(o=!0,a=Jf(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const l={x:a},u={depthRadius:t,bias:n,alpha:s,beta:r},c=kd.runKernel($u,l,u);return o?Jf(c,[c.shape[1],c.shape[2],c.shape[3]]):c}});nd().prototype.localResponseNormalization=function(e,t,n,s){return this.throwIfDisposed(),ww(this,e,t,n,s)};const kw=Dd({logSigmoid_:function(e){const t=Rd(e,"x","logSigmoid");return Lp((e=>({value:nm(Tm(nm(e))),gradFunc:t=>Dp(t,vm(nm(e)))})))(t)}});nd().prototype.logSigmoid=function(){return this.throwIfDisposed(),kw(this)},nd().prototype.logSoftmax=function(e){return this.throwIfDisposed(),Pg(this,e)},nd().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),Kg(this,e,t)},nd().prototype.log=function(){return this.throwIfDisposed(),Fg(this)},nd().prototype.log1p=function(){return this.throwIfDisposed(),Mg(this)},nd().prototype.logicalAnd=function(e){return this.throwIfDisposed(),Xg(this,e)},nd().prototype.logicalNot=function(){return this.throwIfDisposed(),Wv(this)};const Sw=Dd({logicalOr_:function(e,t){const n=Rd(e,"a","logicalOr","bool"),s=Rd(t,"b","logicalOr","bool");ef(n.shape,s.shape);const r={a:n,b:s};return kd.runKernel(Eu,r)}});nd().prototype.logicalOr=function(e){return this.throwIfDisposed(),Sw(this,e)};const Iw=Dd({logicalXor_:function(e,t){const n=Rd(e,"a","logicalXor","bool"),s=Rd(t,"b","logicalXor","bool");return ef(n.shape,s.shape),Xg(Sw(e,t),Wv(Xg(e,t)))}});nd().prototype.logicalXor=function(e){return this.throwIfDisposed(),Iw(this,e)},nd().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),qg(this,e,t,n)},nd().prototype.maxPool=function(e,t,n,s){return this.throwIfDisposed(),Yg(this,e,t,n,s)},nd().prototype.max=function(e,t){return this.throwIfDisposed(),Og(this,e,t)},nd().prototype.maximum=function(e){return this.throwIfDisposed(),tf(this,e)},nd().prototype.mean=function(e,t){return this.throwIfDisposed(),Zg(this,e,t)},nd().prototype.min=function(e,t){return this.throwIfDisposed(),Jg(this,e,t)},nd().prototype.minimum=function(e){return this.throwIfDisposed(),em(this,e)};const Cw=Dd({mirrorPad_:function(e,t,n){go("reflect"===n||"symmetric"===n,(()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`));const s=Rd(e,"x","mirrorPad");if(0===s.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");go(t.length===s.rank,(()=>`Padding doesn't match input. Must be ${s.rank}. Got ${t.length}.`));const r="reflect"===n?1:0;for(let o=0;o<s.rank;o++)go(2===t[o].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),go(t[o][0]>=0&&t[o][0]<=s.shape[o]-r&&t[o][1]>=0&&t[o][1]<=s.shape[o]-r,(()=>`Padding in dimension ${o} cannot be greater than or equal to ${s.shape[o]-r} or less than 0 for input of shape ${s.shape}`));const i={paddings:t,mode:n},a={x:s};return kd.runKernel(Vu,a,i)}});nd().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),Cw(this,e,t)};const Nw=Dd({mod_:function(e,t){let n=Rd(e,"a","mod"),s=Rd(t,"b","mod");[n,s]=fd(n,s);const r={a:n,b:s};return kd.runKernel(Uu,r)}});nd().prototype.mod=function(e){return this.throwIfDisposed(),Nw(this,e)},nd().prototype.mul=function(e){return this.throwIfDisposed(),Dp(this,e)},nd().prototype.neg=function(){return this.throwIfDisposed(),nm(this)},nd().prototype.norm=function(e,t,n){return this.throwIfDisposed(),Fb(this,e,t,n)},nd().prototype.notEqual=function(e){return this.throwIfDisposed(),sm(this,e)},nd().prototype.oneHot=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return this.throwIfDisposed(),rm(this,e,t,n)},nd().prototype.onesLike=function(){return this.throwIfDisposed(),om(this)},nd().prototype.pad=function(e,t){return this.throwIfDisposed(),lm(this,e,t)};const Tw=Dd({pool_:function(e,t,n,s,r,i,a){null==r&&(r=[1,1]),null==i&&(i=1),0===s&&(s="valid");const o=Rd(e,"x","maxPool");let l=o,u=!1;3===o.rank&&(u=!0,l=Jf(o,[1,o.shape[0],o.shape[1],o.shape[2]])),go(qf(i,r),(()=>`Error in pool: Either strides or dilations must be 1. Got strides ${i} and dilations '${r}'`));const c=zf(l.shape,t,i,r,s),h=[c.dilationHeight,c.dilationWidth];let d;d="same"===s?function(e,t){const n=e.map(((e,n)=>e+(e-1)*(t[n]-1))),s=n.map((e=>e-1)),r=s.map((e=>Math.floor(e/2))),i=s.map(((e,t)=>e-r[t]));return s.map(((e,t)=>[r[t],i[t]]))}([c.filterHeight,c.filterWidth],h):[[0,0],[0,0]];const p=1===h[0]&&1===h[1],[f,g]=function(e,t,n){const s=n.map((e=>e[0])),r=n.map((e=>e[1])),i=e.concat(s,r),a=t.map(((e,t)=>(e-i[t]%e)%e)),o=r.map(((e,t)=>e+a[t])),l=t.map(((e,t)=>[s[t],o[t]])),u=t.map(((e,t)=>[0,a[t]]));return[l,u]}([c.inHeight,c.inWidth],h,d),m=p?s:"valid",b=p?l:xy(l,h,f),x=("avg"===n?()=>eg(b,t,i,m,a):()=>Yg(b,t,i,m,a))(),y=p?x:Jv(x,h,g);return u?Jf(y,[y.shape[1],y.shape[2],y.shape[3]]):y}});nd().prototype.pool=function(e,t,n,s,r,i){return this.throwIfDisposed(),Tw(this,e,t,n,s,r,i)},nd().prototype.pow=function(e){return this.throwIfDisposed(),Xp(this,e)},nd().prototype.prelu=function(e){return this.throwIfDisposed(),um(this,e)};const _w=Dd({prod_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],s=Rd(e,"x","prod");"bool"===s.dtype&&(s=_p(s,"int32"));const r={x:s},i={axis:t,keepDims:n};return kd.runKernel(sc,r,i)}});nd().prototype.prod=function(e,t){return this.throwIfDisposed(),_w(this,e,t)};const Ew=Dd({reciprocal_:function(e){const t={x:Rd(e,"x","reciprocal")};return kd.runKernel(uc,t)}});nd().prototype.reciprocal=function(){return this.throwIfDisposed(),Ew(this)},nd().prototype.relu=function(){return this.throwIfDisposed(),mm(this)},nd().prototype.relu6=function(){return this.throwIfDisposed(),jm(this)},nd().prototype.reshapeAs=function(e){return this.throwIfDisposed(),Jf(this,e.shape)},nd().prototype.reshape=function(e){return this.throwIfDisposed(),Jf(this,e)},nd().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),Ib(this,e,t,n)},nd().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),Cb(this,e,t,n)},nd().prototype.reverse=function(e){return this.throwIfDisposed(),bm(this,e)},nd().prototype.rfft=function(){return this.throwIfDisposed(),Vm(this)},nd().prototype.round=function(){return this.throwIfDisposed(),_b(this)},nd().prototype.rsqrt=function(){return this.throwIfDisposed(),Hy(this)},nd().prototype.selu=function(){return this.throwIfDisposed(),xm(this)},nd().prototype.separableConv2d=function(e,t,n,s,r,i){return this.throwIfDisposed(),ym(this,e,t,n,s,r,i)},nd().prototype.sigmoid=function(){return this.throwIfDisposed(),vm(this)};const $w=Dd({sign_:function(e){const t={x:Rd(e,"x","sign")};return kd.runKernel(_c,t)}});nd().prototype.sign=function(){return this.throwIfDisposed(),$w(this)},nd().prototype.sin=function(){return this.throwIfDisposed(),$y(this)},nd().prototype.sinh=function(){return this.throwIfDisposed(),Ay(this)},nd().prototype.slice=function(e,t){return this.throwIfDisposed(),wm(this,e,t)},nd().prototype.softmax=function(e){return this.throwIfDisposed(),Nm(this,e)},nd().prototype.softplus=function(){return this.throwIfDisposed(),Tm(this)},nd().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),xy(this,e,t)},nd().prototype.split=function(e,t){return this.throwIfDisposed(),_m(this,e,t)},nd().prototype.sqrt=function(){return this.throwIfDisposed(),Fp(this)},nd().prototype.square=function(){return this.throwIfDisposed(),Mp(this)},nd().prototype.squaredDifference=function(e){return this.throwIfDisposed(),zb(this,e)},nd().prototype.squeeze=function(e){return this.throwIfDisposed(),Em(this,e)},nd().prototype.stack=function(e,t){this.throwIfDisposed();const n=e instanceof td?[this,e]:[this,...e];return $m(n,t)},nd().prototype.step=function(e){return this.throwIfDisposed(),Km(this,e)};const Rw=Dd({stridedSlice_:function(e,t,n,s){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,a=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0,o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,l=arguments.length>8&&void 0!==arguments[8]?arguments[8]:0;const u={x:Rd(e,"x","stridedSlice","string_or_numeric")},c={begin:t,end:n,strides:s,beginMask:r,endMask:i,ellipsisMask:a,newAxisMask:o,shrinkAxisMask:l};return kd.runKernel(Gc,u,c)}});nd().prototype.stridedSlice=function(e,t,n,s,r,i,a,o){return this.throwIfDisposed(),Rw(this,e,t,n,s,r,i,a,o)},nd().prototype.sub=function(e){return this.throwIfDisposed(),qp(this,e)},nd().prototype.sum=function(e,t){return this.throwIfDisposed(),Lg(this,e,t)};const Aw=Dd({tan_:function(e){const t={x:Rd(e,"x","tan","float32")};return kd.runKernel(qc,t)}});nd().prototype.tan=function(){return this.throwIfDisposed(),Aw(this)},nd().prototype.tanh=function(){return this.throwIfDisposed(),Rm(this)},nd().prototype.tile=function(e){return this.throwIfDisposed(),Tg(this,e)},nd().prototype.toBool=function(){return this.throwIfDisposed(),_p(this,"bool")},nd().prototype.toFloat=function(){return this.throwIfDisposed(),_p(this,"float32")},nd().prototype.toInt=function(){return this.throwIfDisposed(),_p(this,"int32")};const Dw=Dd({topk_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];const s=Rd(e,"x","topk");if(0===s.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const r=s.shape[s.shape.length-1];if(t<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${t}`);if(t>r)throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${t}`);const i={x:s},a={k:t,sorted:n},[o,l]=kd.runKernel(Zc,i,a);return{values:o,indices:l}}});nd().prototype.topk=function(e,t){return this.throwIfDisposed(),Dw(this,e,t)},nd().prototype.transpose=function(e){return this.throwIfDisposed(),zm(this,e)};const Fw=Dd({unique_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=Rd(e,"x","unique","string_or_numeric");go(n.rank>0,(()=>"The input tensor must be at least 1D"));const s={x:n},r={axis:t},[i,a]=kd.runKernel(th,s,r);return{values:i,indices:a}}});nd().prototype.unique=function(e){return this.throwIfDisposed(),Fw(this,e)},nd().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),Ky(this,e,t)},nd().prototype.unstack=function(e){return this.throwIfDisposed(),Mm(this,e)},nd().prototype.where=function(e,t){return this.throwIfDisposed(),Om(e,this,t)},nd().prototype.zerosLike=function(){return this.throwIfDisposed(),Op(this)};class Mw extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Mw.prototype)}}class Ow extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Ow.prototype)}}class Lw extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Lw.prototype)}}class Pw extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Pw.prototype)}}class zw extends Error{constructor(e){super(e),Object.setPrototypeOf(this,zw.prototype)}}Error;class Bw{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const e=this.cache.keys().next().value;this.cache.delete(e)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){const e=this.cache.keys().next().value;this.cache.delete(e)}this.maxEntries=e}}function Ww(e,t){if(Array.isArray(e)){let n=[];for(let s=0;s<t;s++)n=n.concat(e);return n}{const n=new Array(t);return n.fill(e),n}}function Vw(e,t){if(!e)throw new zw(t)}function Uw(e,t){let n=0;for(const s of e)s===t&&n++;return n}function Gw(e){return 1===e.length?e[0]:e}function Hw(e){return Array.isArray(e)?e:[e]}function jw(e){const t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==t[0]?t:"private"+t}function Kw(e){return e.length<=1||-1===e.indexOf("_")?e:e.replace(/[_]+(\w|$)/g,((e,t)=>t.toUpperCase()))}let Xw={};function qw(e){if(null===e||void 0===e)return null;const t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function Yw(e){if(null!=e&&"object"===typeof e)if(Array.isArray(e))e.forEach((e=>Yw(e)));else{const t=Object.keys(e);for(const n of t){const t=e[n];null!=t&&"object"===typeof t&&(Array.isArray(t)||"ndarray"!==t.type||"number"!==typeof t.value?Yw(t):e[n]=t.value)}}}function Qw(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"object",r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if("string"===typeof e){const r=e;let i;if(r in n)i=n[r];else if(r in Xw)i=Xw[r];else if(i=t[r],null==i)throw new Lw(`Unknown ${s}: ${e}. This may be due to one of the following reasons:\n1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return i}{const i=e;if(null==i.className||null==i.config)throw new Lw(`${s}: Improper config format: ${JSON.stringify(i)}.\n'className' and 'config' must set.`);const a=i.className;let o,l;if(a in n?[o,l]=n[a]:a in Xw?[o,l]=Xw.className:a in t&&([o,l]=t[a]),null==o)throw new Lw(`Unknown ${s}: ${a}. This may be due to one of the following reasons:\n1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.\n2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(null!=l){const e={};for(const n of Object.keys(Xw))e[n]=Xw[n];for(const r of Object.keys(n))e[r]=n[r];i.config.customObjects=e;const t=Object.assign({},Xw);for(const r of Object.keys(n))Xw[r]=n[r];Yw(i.config);const s=l(o,i.config,n,r);return Xw=Object.assign({},t),s}{const e=Object.assign({},Xw);for(const s of Object.keys(n))Xw[s]=n[s];const t=new o(i.config);return Xw=Object.assign({},e),t}}}function Zw(e,t){return-1*function(e,t){return e<t?-1:e>t?1:0}(e,t)}function Jw(e){if(null==e)return e;const t=[];for(const n of e)-1===t.indexOf(n)&&t.push(n);return t}function ek(e){if(null==e)throw new Lw(`Invalid value in obj: ${JSON.stringify(e)}`);for(const t in e)if(e.hasOwnProperty(t))return!1;return!0}function tk(e,t,n){if(null!=n&&e.indexOf(n)<0)throw new Lw(`${n} is not a valid ${t}.  Valid values are ${e} or null/undefined.`)}function nk(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1/0;return Vw(n>=0),Vw(s>=n),Array.isArray(e)&&e.length>=n&&e.length<=s&&e.every((e=>typeof e===t))}function sk(e,t){Array.isArray(e)?(go(e.length>0,(()=>`${t} is unexpectedly an empty array.`)),e.forEach(((e,n)=>sk(e,`element ${n+1} of ${t}`)))):go(Number.isInteger(e)&&e>0,(()=>`Expected ${t} to be a positive integer, but got ${rk(e)}.`))}function rk(e){return null===e?"null":Array.isArray(e)?"["+e.map((e=>rk(e))).join(",")+"]":"string"===typeof e?`"${e}"`:`${e}`}function ik(e){return"relu"===e?"relu":"linear"===e?"linear":"elu"===e?"elu":null}let ak=0;function ok(){return ak++}const lk={};function uk(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return e in lk||(lk[e]=0),lk[e]+=1,e+lk[e].toString()}const ck=["channelsFirst","channelsLast"],hk=["nearest","bilinear"],dk=["valid","same","causal"],pk=["max","avg"],fk=["sum","mul","concat","ave"],gk=new Map;function mk(e){tk(ck,"DataFormat",e)}function bk(e){tk(dk,"PaddingMode",e)}function xk(e){tk(pk,"PoolMode",e)}const yk=[];function vk(e,t){yk.push(e);try{const e=t();return yk.pop(),e}catch(n){throw yk.pop(),n}}function wk(e){if(!Ik(e))throw new Error("Not a valid tensor name: '"+e+"'");return(0===yk.length?"":yk.join("/")+"/")+e}function kk(e){if(!Ik(e))throw new Error("Not a valid tensor name: '"+e+"'");gk.has(e)||gk.set(e,0);const t=gk.get(e);if(gk.set(e,gk.get(e)+1),t>0){const n=`${e}_${t}`;return gk.set(n,1),n}return e}const Sk=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function Ik(e){return!!e.match(Sk)}function Ck(e,t,n){null==t&&(t=0),null==n&&(n=e.length);let s=1;for(let r=t;r<n;++r)s*=e[r];return s}function Nk(e){if(0===e.length)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){const s=e[n];s<t&&(t=s)}return t}function Tk(e){if(0===e.length)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){const s=e[n];s>t&&(t=s)}return t}function _k(e,t){if(t<e)throw new Lw(`end (${t}) < begin (${e}) is forbidden.`);const n=[];for(let s=e;s<t;++s)n.push(s);return n}let Ek;function $k(){return null==Ek&&(Ek=Gd().epsilon()),Ek}function Rk(e,t){return _p(e,t)}function Ak(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),Jf(e,n)}function Dk(e,t,n){return Bd((()=>{switch(e.rank){case 1:return km(e,t,n);case 2:return Sm(e,[t,0],[n,e.shape[1]]);case 3:return Im(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return Cm(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return wm(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return wm(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new Lw(`sliceAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function Fk(e,t,n){return Bd((()=>{switch(e.rank){case 1:return km(e,t,n);case 2:return Sm(e,[0,t],[e.shape[0],n]);case 3:return Im(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return Cm(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new Lw(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function Mk(e,t,n,s){return Bd((()=>{switch(e.rank){case 1:return km(e,t,n);case 2:switch(s){case 1:return Dk(e,t,n);case 2:return Fk(e,t,n);default:throw new Lw(`The axis is not within the rank of the tensor ${s}`)}case 3:switch(s){case 1:return Dk(e,t,n);case 2:return Im(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return Fk(e,t,n);default:throw new Lw(`The axis is not within the rank of the tensor ${s}`)}case 4:switch(s){case 1:return Dk(e,t,n);case 2:return Cm(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return Cm(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return Fk(e,t,n);default:throw new Lw(`The axis is not within the rank of the tensor ${s}`)}default:throw new Lw(`sliceAlongLastAxis() received an unsupported tensor rank: ${e.rank}`)}}))}function Ok(e){let t,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;return n<0&&(t=e[0].rank,n=0!==t?t:0),n===e[0].rank&&(n=-1),lg(e,n)}function Lk(e,t){switch(e.rank){case 1:return ug([e,t]);case 2:return cg([e,t],0);case 3:return hg([e,t],0);case 4:return dg([e,t],0);default:throw new Lw(`concatAlongFirstAxis() received an unsupported tensor rank: ${e.rank}`)}}function Pk(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new Lw(`The length of input n (${t.length}) does not match the number of dimensions in input x (${e.rank})`);return Tg(e,t)}function zk(e){return pm(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,arguments.length>3?arguments[3]:void 0,arguments.length>4?arguments[4]:void 0)}function Bk(e,t,n,s){if(e.rank<2||t.rank<2)throw new Pw(`dot requires both inputs to be rank >= 2 but got x shape = ${e.shape} and y shape = ${t.shape}`);if(t.rank>=3){if(e.shape.slice(-1)[0]!==t.shape.slice(-2)[0])throw new Pw(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${e.shape} and  y shape = ${t.shape}`)}if(2===e.rank&&2===t.rank){return tb({a:e,b:t,transposeA:!1,transposeB:!1,bias:s?Uk(e.rank,s,"channelsLast"):null,activation:n})}{const r=e.shape.slice(),i=r.pop();e=Jf(e,[-1,i]);const a=t.shape.slice(),o=a.pop(),l=a.pop(),u=[...a,o],c=Array.from({length:t.rank},((e,n)=>0===n?t.rank-2:n<=t.rank-2?n-1:n));t=Jf(zm(t,c),[l,-1]);const h=[...r,...u];return Jf(tb({a:e,b:t,transposeA:!1,transposeB:!1,bias:s?Uk(e.rank,s,"channelsLast"):null,activation:n}),h)}}function Wk(e,t,n){return Bd((()=>(t=Array.isArray(t)?Am(t,"int32"):_p(t,"int32"),$g(e,t,n))))}function Vk(e){return Dp(e,e)}function Uk(e,t,n){const s=t.shape;if(1!==t.rank&&t.rank!==e)throw new Lw(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${e}`);if(5===e){if("channelsFirst"===n)return 1===s.length?Jf(t,[1,s[0],1,1,1]):Jf(t,[1,s[3],s[0],s[1],s[2]]);if("channelsLast"===n)return 1===s.length?Jf(t,[1,1,1,1,s[0]]):Jf(t,[1].concat(s))}else if(4===e){if("channelsFirst"===n)return 1===s.length?Jf(t,[1,s[0],1,1]):Jf(t,[1,s[2],s[0],s[1]]);if("channelsLast"===n)return 1===s.length?Jf(t,[1,1,1,s[0]]):Jf(t,[1].concat(s))}else if(3===e){if("channelsFirst"===n)return 1===s.length?Jf(t,[1,s[0],1]):Jf(t,[1,s[1],s[0]]);if("channelsLast"===n)return 1===s.length?Jf(t,[1,1,s[0]]):Jf(t,[1].concat(s))}else if(e<3)return t;throw new Lw(`Unsupported input rank by biasAdd: ${t.rank}`)}function Gk(e,t,n){return Bd((()=>(null==n&&(n="channelsLast"),mk(n),$p(e,Uk(e.rank,t,n)))))}function Hk(e,t,n,s){return Bd((()=>Bm(e,t,n,s)))}function jk(e,t){return arguments.length>2&&void 0!==arguments[2]&&arguments[2]?e():t()}const Kk=["fanIn","fanOut","fanAvg"],Xk=["normal","uniform","truncatedNormal"];class qk extends Wp{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class Yk extends qk{apply(e,t){return im(e,t)}}Yk.className="Zeros",Up(Yk);class Qk extends qk{apply(e,t){return am(e,t)}}Qk.className="Ones",Up(Qk);class Zk extends qk{constructor(e){if(super(),"object"!==typeof e)throw new Lw(`Expected argument of type ConstantConfig but got ${e}`);if(void 0===e.value)throw new Lw(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return Bd((()=>Dp(Pp(this.value),am(e,t))))}getConfig(){return{value:this.value}}}Zk.className="Constant",Up(Zk);class Jk extends qk{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return fm(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}Jk.className="RandomUniform",Up(Jk);class eS extends qk{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new Pw(`randomNormal does not support dType ${t}.`);return zk(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}eS.className="RandomNormal",Up(eS);class tS extends qk{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new Pw(`truncatedNormal does not support dType ${t}.`);return Fm(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}tS.className="TruncatedNormal",Up(tS);class nS extends qk{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,t){return Bd((()=>{if(2!==e.length||e[0]!==e[1])throw new Lw("Identity matrix initializer can only be used for 2D square matrices.");return Dp(this.gain,_g(e[0]))}))}getConfig(){return{gain:this.gain}}}nS.className="Identity",Up(nS);class sS extends qk{constructor(e){if(super(),e.scale<0)throw new Lw(`scale must be a positive float. Got: ${e.scale}`);var t;this.scale=null==e.scale?1:e.scale,this.mode=null==e.mode?"fanIn":e.mode,t=this.mode,tk(Kk,"FanMode",t),this.distribution=null==e.distribution?"normal":e.distribution,function(e){tk(Xk,"Distribution",e)}(this.distribution),this.seed=e.seed}apply(e,t){const n=function(e){let t,n,s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"channelsLast";if(mk(s),2===e.length)t=e[0],n=e[1];else if(-1!==[3,4,5].indexOf(e.length)){if("channelsFirst"===s){const s=Ck(e,2);t=e[1]*s,n=e[0]*s}else if("channelsLast"===s){const s=Ck(e,0,e.length-2);t=e[e.length-2]*s,n=e[e.length-1]*s}}else{const s=Ck(e);t=Math.sqrt(s),n=Math.sqrt(s)}return[t,n]}(e),s=n[0],r=n[1];let i=this.scale;if("fanIn"===this.mode?i/=Math.max(1,s):"fanOut"===this.mode?i/=Math.max(1,r):i/=Math.max(1,(s+r)/2),"normal"===this.distribution){const n=Math.sqrt(i);if("float32"!==(t=t||"float32")&&"int32"!==t)throw new Pw(`${this.getClassName()} does not support dType ${t}.`);return Fm(e,0,n,t,this.seed)}{const n=Math.sqrt(3*i);return fm(e,-n,n,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}sS.className="VarianceScaling",Up(sS);class rS extends sS{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return sS.className}}rS.className="GlorotUniform",Up(rS);class iS extends sS{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return sS.className}}iS.className="GlorotNormal",Up(iS);class aS extends sS{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return sS.className}}aS.className="HeNormal",Up(aS);class oS extends sS{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return sS.className}}oS.className="HeUniform",Up(oS);class lS extends sS{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return sS.className}}lS.className="LeCunNormal",Up(lS);class uS extends sS{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return sS.className}}uS.className="LeCunUniform",Up(uS);class cS extends qk{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=null==e.gain?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return Bd((()=>{if(e.length<2)throw new Pw("Shape must be at least 2D.");if("int32"!==t&&"float32"!==t&&void 0!==t)throw new TypeError(`Unsupported data type ${t}.`);const n=xo(e.slice(0,-1)),s=e[e.length-1],r=n*s;r>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${r}) elements: Slowness may result.`);const i=zk([Math.max(s,n),Math.min(s,n)],0,1,t,this.seed),a=Wb.qr(i,!1);let o=a[0];const l=a[1].flatten().stridedSlice([0],[Math.min(s,n)*Math.min(s,n)],[Math.min(s,n)+1]);return o=Dp(o,l.sign()),n<s&&(o=o.transpose()),Dp(Pp(this.gain),o.reshape(e))}))}getConfig(){return{gain:this.gain,seed:this.seed}}}cS.className="Orthogonal",Up(cS);const hS={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function dS(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Qw(e,Vp.getMap().classNameMap,t,"initializer")}function pS(e){return qw(e)}function fS(e){if("string"===typeof e){const t=e in hS?hS[e]:e;if("GlorotNormal"===t)return new iS;if("GlorotUniform"===t)return new rS;if("HeNormal"===t)return new aS;if("HeUniform"===t)return new oS;if("LeCunNormal"===t)return new lS;if("LeCunUniform"===t)return new uS;{const e={};return e.className=t,e.config={},dS(e)}}return e instanceof qk?e:dS(e)}function gS(e){return Array.isArray(e)&&Array.isArray(e[0])}function mS(e){return 0===e.length?[]:Array.isArray(e[0])?e:[e]}function bS(e){let t;if(Array.isArray(e)){if(1!==e.length)throw new Lw(`Expected Tensor length to be 1; got ${e.length}`);t=e[0]}else t=e;return t}function xS(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(1===e.length)return e[0];throw new Lw(`Expected exactly 1 Shape; got ${e.length}`)}return e}function yS(e){let t=0;for(const n of e)0===n.shape.length?t+=1:t+=n.shape.reduce(((e,t)=>e*t));return t}const vS="Variable";class wS{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:vS,s=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this.dtype=null==t?"float32":t,this.shape=e.shape,this.id=ok(),n=null==n?vS:n,this.originalName=wk(n),this.name=kk(this.originalName),this.trainable_=s,this.constraint=r,this.val=function(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,s=arguments.length>3?arguments[3]:void 0;return kd.makeVariable(e,t,n,s)}(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),function(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}(this.val,e),this.val.id!==e.id&&(this.val.assign(e),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function kS(e){return e.map((e=>e.read()))}function SS(e){e.forEach((e=>{e[0].write(e[1])}))}class IS{constructor(e){this.dtype=e.dtype,this.shape=e.shape,null!=e.shape?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class CS{constructor(e,t,n,s,r,i,a){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=s,this.callArgs=r,this.outputTensorIndex=a,this.id=ok(),null!=i&&(this.originalName=wk(i),this.name=kk(this.originalName)),this.rank=t.length}}let NS=0;class TS{constructor(e,t){this.callArgs=t,this.id=NS++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const n of e.inboundLayers)null!=n&&n.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)null!=t?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let _S=0;class ES extends Wp{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=_S++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const e=this.getClassName();t=jw(e)+"_"+uk(e)}if(this.name=t,this.trainable_=null==e.trainable||e.trainable,null!=e.inputShape||null!=e.batchInputShape){let t;if(null!=e.batchInputShape)t=e.batchInputShape;else if(null!=e.inputShape){let n=null;null!=e.batchSize&&(n=e.batchSize),t=[n].concat(e.inputShape)}this.batchInputShape=t;let n=e.dtype;null==n&&(n=e.inputDType),null==n&&(n="float32"),this.dtype=n}null!=e.weights?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(0===this.inboundNodes.length)throw new Ow(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new Lw(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return Gw(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return Gw(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Mw(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(0===this.inboundNodes.length)throw new Mw(`Layer ${this.name} is not connected, no input to return.`);return Gw(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new Mw(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Mw(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return Gw(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map((e=>e()))}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach((t=>t.trainable=e)),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter((e=>e.trainable)):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter((e=>!e.trainable)).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){const t=Hw(e);if(null==this.inputSpec||0===this.inputSpec.length)return;const n=Hw(this.inputSpec);if(t.length!==n.length)throw new Lw(`Layer ${this.name} expects ${n.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);for(let s=0;s<t.length;s++){const e=t[s],r=n[s];if(null==r)continue;const i=e.rank;if(null!=r.ndim&&i!==r.ndim)throw new Lw(`Input ${s} is incompatible with layer ${this.name}: expected ndim=${r.ndim}, found ndim=${i}`);if(null!=r.maxNDim&&i>r.maxNDim)throw new Lw(`Input ${s} is incompatible with layer ${this.name}: expected max_ndim=${r.maxNDim}, found ndim=${i}`);if(null!=r.minNDim&&i<r.minNDim)throw new Lw(`Input ${s} is incompatible with layer ${this.name}: expected min_ndim=${r.minNDim}, found ndim=${i}.`);if(null!=r.dtype&&e.dtype!==r.dtype)throw new Lw(`Input ${s} is incompatible with layer ${this.name} : expected dtype=${r.dtype}, found dtype=${e.dtype}.`);if(r.axes){const t=e.shape;for(const e in r.axes){const n=Number(e),i=r.axes[e],a=n>=0?t[n]:t[t.length+n];if(null!=i&&-1===[i,null].indexOf(a))throw new Lw(`Input ${s} is incompatible with layer ${this.name}: expected axis ${n} of input shape to have value ${i} but got shape ${t}.`)}}if(null!=r.shape)for(let t=0;t<r.shape.length;++t){const n=r.shape[t],i=e.shape[t];if(null!=n&&null!=i&&n!==i)throw new Lw(`Input ${s} is incompatible with layer ${this.name}: expected shape=${r.shape}, found shape=${e.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){null!=this._callHook&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const n=Hw(e),s=function(e){let t=!0;for(const n of Hw(e))if(!(n instanceof CS)){t=!1;break}return t}(e),r=function(e){let t=!0;for(const n of Hw(e))if(n instanceof CS){t=!1;break}return t}(e);if(s===r)throw new Lw("Arguments to apply() must be all SymbolicTensors or all Tensors");return vk(this.name,(()=>{if(!this.built){this.assertInputCompatibility(e);const t=[];for(const n of Hw(e))t.push(n.shape);this.build(Gw(t)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&r&&(this._refCount=1)}if(this.assertInputCompatibility(e),r){let s=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,s);const r=Hw(s),i=[];for(let e of r)-1!==n.indexOf(e)&&(e=e.clone()),i.push(e);if(s=Gw(i),null!=this.activityRegularizer)throw new Pw("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return s}{const n=function(e){e=Hw(e);const t=[];for(const n of e)t.push(n.shape);return Gw(t)}(e),s=this.computeOutputShape(n);let r;const i="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(e)?n[0]:n),r=null!=s&&s.length>0&&Array.isArray(s[0])?s.map(((n,s)=>new CS(i,n,this,Hw(e),t,this.name,s))):new CS(i,s,this,Hw(e),t,this.name),this.addInboundNode(e,r,null,null,n,s,t),this._refCount++,null!=this.activityRegularizer)throw new Pw("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return r}}))}warnOnIncompatibleInputShape(e){if(null!=this.batchInputShape)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach(((n,s)=>{null!=n&&null!=e[s]&&e[s]!==n&&(t=!0)})),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new Mw(`The layer ${this.name} has never been called and thus has no defined output shape.`);const e=[];for(const t of this.inboundNodes){const n=JSON.stringify(t.outputShapes);-1===e.indexOf(n)&&e.push(n)}if(1===e.length){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new Mw(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new Ow(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return yS(this.weights)}build(e){this.built=!0}getWeights(){return kS(arguments.length>0&&void 0!==arguments[0]&&arguments[0]?this.trainableWeights:this.weights)}setWeights(e){Bd((()=>{const t=this.weights;if(t.length!==e.length)throw new Lw(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(0===t.length)return;const n=[],s=kS(t);for(let r=0;r<s.length;++r){const i=s[r],a=t[r],o=e[r];if(!yo(i.shape,o.shape))throw new Lw(`Layer weight shape ${i.shape} not compatible with provided weight shape ${o.shape}`);n.push([a,o])}SS(n)}))}addWeight(e,t,n,s,r,i,a,o){if(-1!==this._addedWeightNames.indexOf(e))throw new Lw(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(s=null!=o?o():fS("zeros"));const l=s.apply(t,n),u=new wS(l,n,e,i,a);return l.dispose(),null!=r&&this.addLoss((()=>r.apply(u.read()))),null==i&&(i=!0),i?this._trainableWeights.push(u):this._nonTrainableWeights.push(u),u}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){null==e||Array.isArray(e)&&0===e.length||(e=Hw(e),void 0!==this._losses&&null!==this._losses&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(null!=t){if(!Array.isArray(t))throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);t.forEach((e=>{if(null!=e)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)}))}return null}return t}setMaskMetadata(e,t,n){if(!this.supportsMasking)return;const s=this.computeMask(e,n),r=Hw(t),i=Hw(s);if(r.length!==i.length)throw new Error(`${this.name} outputs ${r.length} tensors but ${r.length} masks for those tensors`);for(let a=0;a<r.length;a++)r[a].kerasMask=i[a]}addInboundNode(e,t,n,s,r,i){let a=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null;const o=Hw(e);t=Hw(t),n=Hw(n),s=Hw(s),r=mS(r),i=mS(i);const l=[],u=[],c=[];for(const h of o)l.push(h.sourceLayer),u.push(h.nodeIndex),c.push(h.tensorIndex);new TS({outboundLayer:this,inboundLayers:l,nodeIndices:u,tensorIndices:c,inputTensors:o,outputTensors:t,inputMasks:n,outputMasks:s,inputShapes:r,outputShapes:i},a);for(let h=0;h<t.length;h++)t[h].sourceLayer=this,t[h].nodeIndex=this.inboundNodes.length-1,t[h].tensorIndex=h}getConfig(){const e={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(e.batchInputShape=this.batchInputShape),null!=this.dtype&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach((e=>e.dispose())),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(null===this._refCount)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return 0===--this._refCount&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function $S(e,t,n){if((null==t||null!=n&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),0===t.inboundNodes.length)return[e];{const e=t.inboundNodes[n];if(0===e.inboundLayers.length)return e.inputTensors;{const t=[];for(let n=0;n<e.inboundLayers.length;n++){const s=$S(e.inputTensors[n],e.inboundLayers[n],e.nodeIndices[n]);for(const e of s)-1===t.indexOf(e)&&t.push(e)}return t}}}class RS extends ES{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:uk("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new Lw("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(null==t){if(null==e.inputShape)throw new Lw("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new Lw("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];const s=new CS(this.dtype,this.batchInputShape,this,[],{},this.name);s.nodeIndex=0,s.tensorIndex=0,new TS({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[s],outputTensors:[s],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new Lw(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}function AS(e){if(null==e.batchShape&&null==e.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=e.batchShape&&null!=e.shape)throw new Lw("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;null!=e.shape&&null==t&&(t=[null].concat(e.shape));let n=e.dtype;null==n&&(n="float32");return new RS({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}RS.className="InputLayer",Up(RS);class DS{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof DS)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(null==e)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,n){if(null!=this.id2Value[e.id])throw new Lw(`Duplicate key: name=${e.name}, id=${e.id}`);return this.id2Value[e.id]=function(e,t){if(null==e.dtype||e.dtype===t.dtype)return t;try{return _p(t,e.dtype)}catch(SG){throw new Lw(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${e.name}' (${e.dtype}).`)}}(e,t),this.name2Id[e.name]=e.id,null!=n&&(this.id2Mask[e.id]=n),this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return null!=this.id2Value[e.id]}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof CS){if(null==this.id2Value[e.id])throw new Lw(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}{const t=this.name2Id[e];if(null==t)throw new Lw(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof CS){if(null==this.id2Value[e.id])throw new Lw(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}{const t=this.name2Id[e];if(null==t)throw new Lw(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){null!=this.id2Mask&&Wd(this.id2Mask)}}const FS=new Bw,MS=new Bw;function OS(e,t,n,s){const r=null!=n&&n.training,i=Array.isArray(e),a=i?e:[e],o=a.map((e=>e.name)),l=[],u=t.names();for(const f of o)-1!==u.indexOf(f)?l.push(t.getValue(f)):l.push(null);null!=s&&(s.maxNumTensors=-1/0,s.minNumTensors=1/0);const c=o.join(",")+"|"+t.names().sort().join(",");let h,d=FS.get(c);if(null==d){const e=function(e,t){go(null!=e&&e.length>0,(()=>"Expected at least one fetch, got none"));let n=[],s={};if(1===e.length){const r=PS(e[0],t);n=r.sorted,s=r.recipientMap}else{const r=new Set;for(const i of e){const{sorted:e,recipientMap:a}=PS(i,t);for(const t of e)r.has(t.name)||(n.push(t),r.add(t.name));for(const t in a)null==s[t]&&(s[t]=new Set),a[t].forEach((e=>s[t].add(e)))}}return{sorted:n,recipientCounts:LS(s)}}(a,t);d=e.sorted,h=e.recipientCounts,FS.put(c,d),MS.put(c,h)}h={},r||Object.assign(h,MS.get(c));const p=new DS(t);for(let f=0;f<d.length;++f){if(null!=s){const e=zd().numTensors;e>s.maxNumTensors&&(s.maxNumTensors=e),e<s.minNumTensors&&(s.minNumTensors=e)}const e=d[f],i=e.sourceLayer;if(i instanceof RS)continue;const a=[],u=[],c=[];let g=!1;for(const n of e.inputs){const e=p.getValue(n),s=p.getMask(n);a.push(e),u.push(s),null!=s&&(g=!0),r||(h[n.name]--,0!==h[n.name]||t.hasKey(n)||-1!==o.indexOf(n.name)||e.isDisposed||!0===n.sourceLayer.stateful||c.push(e))}g&&((n=n||{}).mask=u[0]);const m=Hw(i.apply(a,n));let b=null;i.supportsMasking&&(b=i.computeMask(a,u));const x=zS(e),y=Array.isArray(x)?x:[x];for(let t=0;t<y.length;++t){p.hasKey(y[t])||p.add(y[t],m[t],Array.isArray(b)?b[0]:b);const e=o.indexOf(y[t].name);-1!==e&&(l[e]=m[t])}r||Wd(c)}return p.disposeMasks(),i?l:l[0]}function LS(e){const t={};for(const n in e)t[n]=e[n].size;return t}function PS(e,t){const n=new Set,s=[],r={};for(const o of t.names())n.add(o);const i=[],a=[];for(i.push(e);i.length>0;){const e=i[i.length-1];if(n.has(e.name)){i.pop();continue}const t=a[a.length-1]===i.length-1;if(0===e.inputs.length||t)i.pop(),s.push(e),n.add(e.name),t&&a.pop();else{a.push(i.length-1);for(const t of e.inputs)null==r[t.name]&&(r[t.name]=new Set),r[t.name].add(e.name),n.has(t.name)||i.push(t)}}return{sorted:s,recipientMap:r}}function zS(e){let t;if(1===e.sourceLayer.inboundNodes.length)t=e.sourceLayer.output;else{let n=null;for(let t=0;t<e.sourceLayer.inboundNodes.length;++t)for(const s of e.sourceLayer.inboundNodes[t].outputTensors)if(s.id===e.id){n=t;break}t=e.sourceLayer.getOutputAt(n)}return t}function BS(e,t){return Bd((()=>Fp(Lg(Dp(e,e),t,!0))))}qo().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",(()=>100),(function(e){null!=FS&&FS.setMaxEntries(e),null!=MS&&MS.setMaxEntries(e)}));class WS extends Wp{getConfig(){return{}}}class VS extends WS{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return Bd((()=>{const t=BS(e,this.axis),n=og(t,0,this.maxValue);return Dp(e,Ap(n,$p($k(),t)))}))}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}VS.className="MaxNorm",Up(VS);class US extends WS{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return Bd((()=>Ap(e,$p($k(),BS(e,this.axis)))))}getConfig(){return{axis:this.axis}}}US.className="UnitNorm",Up(US);class GS extends WS{apply(e){return mm(e)}}GS.className="NonNeg",Up(GS);class HS extends WS{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return Bd((()=>{const t=BS(e,this.axis),n=$p(Dp(this.rate,og(t,this.minValue,this.maxValue)),Dp(1-this.rate,t));return Dp(e,Ap(n,$p($k(),t)))}))}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}HS.className="MinMaxNorm",Up(HS);const jS={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function KS(e){return qw(e)}function XS(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Qw(e,Vp.getMap().classNameMap,t,"constraint")}function qS(e){if(null==e)return null;if("string"===typeof e){return XS({className:e in jS?jS[e]:e,config:{}})}return e instanceof WS?e:XS(e)}async function YS(e){if(null==e)return;const t=[],n=[],s=[];for(const r in e){const i=e[r];if("number"!==typeof i){const e=i;t.push(e.data()),n.push(r),s.push(e)}}if(t.length>0){const r=await Promise.all(t);for(let t=0;t<r.length;++t)e[n[t]]=r[t][0];Wd(s)}}function QS(e){if(null!=e)for(const t in e){const n=e[t];"number"!==typeof n&&n.dispose()}}var ZS;!function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"}(ZS||(ZS={}));class JS{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class eI{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:10;null==e&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){null==e&&(e={});for(const t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){null==e&&(e={});for(const t of this.callbacks)await t.onTrainEnd(e)}}class tI extends JS{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){null==t&&(t={});const n=null==t.size?0:t.size;this.seen+=n;for(const s in t){const e=t[s];if("number"===typeof e)this.totals.hasOwnProperty(s)||(this.totals[s]=0),this.totals[s]=this.totals[s]+e*n;else{let t;s in this.totals?t=this.totals[s]:this.totals[s]=0;const r=Bd((()=>$p(this.totals[s],Dp(e,n))));this.totals[s]=r,null!=t&&t.dispose()}}}async onEpochEnd(e,t){if(null!=t)for(const n of this.params.metrics)null!=this.totals[n]&&("number"===typeof this.totals[n]?t[n]=this.totals[n]/this.seen:Bd((()=>{const e=Dp(Ap(1,this.seen),this.totals[n]);t[n]=e,this.totals[n].dispose(),Vd(t[n])})))}}class nI extends JS{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){null==t&&(t={}),this.epoch.push(e);for(const n in t)null==this.history[n]&&(this.history[n]=[]),this.history[n].push(t[n])}async syncData(){const e=[],t=[],n=[];for(const r in this.history){const s=this.history[r];for(let i=0;i<s.length;++i)if("number"!==typeof s[i]){const a=s[i];e.push(a.data()),t.push(r),n.push(i)}}const s=await Promise.all(e);for(let r=0;r<s.length;++r){this.history[t[r]][n[r]].dispose(),this.history[t[r]][n[r]]=s[r][0]}}}class sI extends JS{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||Gb,this.yieldEvery=t||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=e.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");Ao(this.yieldEvery)&&(this.maybeWait=function(e,t,n){let s,r=null!=n?n():Ph();return function(){const i=null!=n?n():Ph();return i-r<t||(r=i,s=e(...arguments)),s}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){const s=[];null!=this.yield&&(await YS(n),s.push(this.yield(e,t,n))),s.push(this.nextFrameFunc()),await Promise.all(s)}async onEpochBegin(e,t){this.currentEpoch=e,null!=this.epochBegin&&(await YS(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){const n=[];null!=this.epochEnd&&(await YS(t),n.push(this.epochEnd(e,t))),"epoch"===this.yieldEvery&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){null!=this.batchBegin&&(await YS(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){const n=[];null!=this.batchEnd&&(await YS(t),n.push(this.batchEnd(e,t))),"batch"===this.yieldEvery?n.push(this.nextFrameFunc()):Ao(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){null!=this.trainBegin&&(await YS(e),await this.trainBegin(e))}async onTrainEnd(e){null!=this.trainEnd&&(await YS(e),await this.trainEnd(e))}}function rI(e,t){if(null==e&&(e={}),e instanceof JS)return[e];if(Array.isArray(e)&&e[0]instanceof JS)return e;return Hw(e).map((e=>new sI(e,t)))}class iI{constructor(){}static registerCallbackConstructor(e,t){go(e>=0&&Number.isInteger(e),(()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`)),iI.checkForDuplicate(t),null==iI.constructors[e]&&(iI.constructors[e]=[]),iI.constructors[e].push(t)}static checkForDuplicate(e){for(const t in iI.constructors){iI.constructors[+t].forEach((t=>{if(t===e)throw new Lw("Duplicate callback constructor.")}))}}static clear(){iI.constructors={}}static createCallbacks(e){const t=[];for(const n in iI.constructors){const s=+n;e>=s&&t.push(...iI.constructors[s])}return t.map((e=>new e))}}function aI(e,t,n,s,r,i,a,o,l){const u=new nI,c=[new tI,...iI.createCallbacks(t)];null!=e&&c.push(...e),c.push(u);const h=new eI(c);return h.setParams({epochs:n,initialEpoch:s,samples:r,steps:i,batchSize:a,verbose:t,doValidation:o,metrics:l}),{callbackList:h,history:u}}function oI(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return Qw(e,Vp.getMap().classNameMap,t,"layer",n)}function lI(e,t){return Bd((()=>{"float32"!==e.dtype&&(e=_p(e,"float32"));const n=Lg(Vk(e),t,!0),s=jp(n.shape,$k()),r=Fp(tf(n,s));return Ap(e,r)}))}function uI(e,t){return Bd((()=>Zg(Vk(qp(t,e)),-1)))}function cI(e,t){return Bd((()=>Zg(Qp(qp(t,e)),-1)))}function hI(e,t){return Bd((()=>{const n=qp(e,t),s=og(Qp(e),$k(),Number.MAX_VALUE),r=Qp(Ap(n,s));return Dp(100,Zg(r,-1))}))}function dI(e,t){return Bd((()=>{const n=og(t,$k(),Number.MAX_VALUE),s=Fg($p(1,n)),r=og(e,$k(),Number.MAX_VALUE),i=Fg($p(1,r));return Zg(Vk(qp(s,i)),-1)}))}function pI(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return Bd((()=>{if(n)t=Nm(t);else{const e=Lg(t,t.shape.length-1,!0);t=Ap(t,e)}return t=og(t,$k(),1-$k()),nm(Lg(Dp(_p(e,"float32"),Fg(t)),t.shape.length-1))}))}function fI(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return Bd((()=>{const s=_p(Eg(function(e){const t=[Ck(e.shape)];return Jf(e,t)}(e)),"int32"),r=(t=og(t,$k(),1-$k())).shape;return pI(Jf(rm(s,r[r.length-1]),r),t,n)}))}function gI(e,t){return Bd((()=>{let n;return n=og(t,$k(),1-$k()),n=Fg(Ap(n,qp(1,n))),Zg(function(e,t){if(!yo(e.shape,t.shape))throw new Lw(`logits and labels must have the same shape, but got shapes ${JSON.stringify(e.shape)} and ${JSON.stringify(t.shape)}`);return Bd((()=>{const n=mm(t),s=nm(Qp(t));return $p(qp(n,Dp(t,e)),Mg(Cg(s)))}))}(e,n),-1)}))}function mI(e,t){return Bd((()=>{const n=og(e,$k(),1),s=og(t,$k(),1);return Lg(Dp(e,Fg(Ap(n,s))),-1)}))}function bI(e,t){return Bd((()=>{const n=lI(e,-1),s=lI(t,-1),r=Dp(n,s);return nm(Lg(r,-1))}))}iI.constructors={};const xI={meanSquaredError:uI,meanAbsoluteError:cI,meanAbsolutePercentageError:hI,meanSquaredLogarithmicError:dI,squaredHinge:function(e,t){return Bd((()=>{const n=tf(0,qp(1,Dp(e,t)));return Zg(Vk(n),-1)}))},hinge:function(e,t){return Bd((()=>{const n=tf(0,qp(1,Dp(e,t)));return Zg(n,-1)}))},categoricalHinge:function(e,t){return Bd((()=>{const n=Lg(Dp(e,t),-1),s=Og(Dp(qp(1,e),t),-1);return tf(0,$p(1,qp(s,n)))}))},logcosh:function(e,t){return Bd((()=>{const n=Math.log(2),s=qp(t,e),r=qp($p(s,Tm(Dp(-2,s))),n);return Zg(r,-1)}))},categoricalCrossentropy:pI,sparseCategoricalCrossentropy:fI,binaryCrossentropy:gI,kullbackLeiblerDivergence:mI,poisson:function(e,t){return Bd((()=>{const n=Fg($p($k(),t));return Zg(qp(t,Dp(e,n)),-1)}))},cosineProximity:bI};function yI(e){if("string"===typeof e){if(e in xI)return xI[e];let t=`Unknown loss ${e}`;throw e.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${e}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new Lw(t)}return e}function vI(e,t){return Bd((()=>{const n=Dp(.5,om(t)),s=Rk(Rg(t,n),e.dtype);return Zg(Sg(e,s),-1)}))}function wI(e,t){return Bd((()=>Rk(Sg(Lf(e,-1),Lf(t,-1)),"float32")))}function kI(e,t){return Bd((()=>_p(Lg(Xg(Sg(e,1),Sg(t,1))),"float32")))}function SI(e,t){return gI(e,t)}function II(e,t){return e.rank===t.rank&&(e=Em(e,[e.rank-1])),(t=Lf(t,-1)).dtype!==e.dtype&&(t=_p(t,e.dtype)),_p(Sg(e,t),"float32")}const CI=pI,NI=fI,TI={binaryAccuracy:vI,categoricalAccuracy:wI,precision:function(e,t){return Bd((()=>{const n=kI(e,t),s=function(e,t){return Bd((()=>_p(Lg(Xg(Sg(e,0),Sg(t,1))),"float32")))}(e,t),r=$p(n,s);return _p(Om(Rg(r,0),Ap(n,r),0),"float32")}))},categoricalCrossentropy:CI,sparseCategoricalCrossentropy:NI,mse:uI,MSE:uI,mae:cI,MAE:cI,mape:hI,MAPE:hI,cosine:bI};function _I(e){if("string"===typeof e&&e in TI)return TI[e];if("string"!==typeof e&&null!=e)return e;throw new Lw(`Unknown metric ${e}`)}function EI(e){if(Vw(null!==e,`Unknown LossOrMetricFn ${e}`),"string"===typeof e)return e;{let t;for(const n of Object.keys(xI))if(xI[n]===e){t=n;break}if(void 0!==t)return t;for(const n of Object.keys(TI))if(TI[n]===e){t=n;break}return void 0!==t?t:e.name}}const $I=1048576;function RI(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(null==e||"object"!==typeof e||Object.getPrototypeOf(e)!==Object.prototype||!AI(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const n=JSON.stringify(e);n.length>$I&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= 1048576.`)}}function AI(e){if(null===e)return!0;if("object"===typeof e){if(Object.getPrototypeOf(e)===Object.prototype){const t=Object.keys(e);for(const n of t){if("string"!==typeof n)return!1;if(!AI(e[n]))return!1}return!0}if(Array.isArray(e)){for(const t of e)if(!AI(t))return!1;return!0}return!1}{const t=typeof e;return"string"===t||"number"===t||"boolean"===t}}function DI(e,t,n){let s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:console.log;const r=function(e){let t=!0;const n=[],s=[];for(const r in e.nodesByDepth)n.push(e.nodesByDepth[r]);for(const r of n){if(r.length>1||1===r.length&&r[0].inboundLayers.length>1){t=!1;break}s.push(...r)}if(t)for(const r of e.layers){let e=!1;for(const n of r.inboundNodes)if(-1!==s.indexOf(n)){if(e){t=!1;break}e=!0}if(!t)break}return t}(e),i=["Layer (type)","Input Shape","Output shape","Param #"];let a;if(r?(t=t||90,n=n||[.32,.61,.89,1]):(t=t||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map((e=>Math.floor(t*e)))),!r){i.push("Receives inputs"),a=[];for(const t in e.nodesByDepth)a.push(...e.nodesByDepth[t])}s("_".repeat(t)),FI(i,n,s),s("=".repeat(t));const o=e.layers;for(let c=0;c<o.length;++c)r?MI(o[c],n,s):OI(o[c],n,a,s),s((c===o.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();const l=function(e){let t;t=null!=e.collectedTrainableWeights?yS(e.collectedTrainableWeights):yS(e.trainableWeights);return t}(e),u=yS(e.nonTrainableWeights);s(`Total params: ${l+u}`),s(`Trainable params: ${l}`),s(`Non-trainable params: ${u}`),s("_".repeat(t))}function FI(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log,s="";for(let r=0;r<e.length;++r)r>0&&(s=s.slice(0,s.length-1)+" "),s+=e[r],s=s.slice(0,t[r]),s+=" ".repeat(t[r]-s.length);n(s)}function MI(e,t,n){let s,r;try{r=e.inboundNodes.map((e=>JSON.stringify(e.inputShapes))).join(",")}catch(SG){r="multiple"}try{s=JSON.stringify(e.outputShape)}catch(SG){s="multiple"}FI([`${e.name} (${e.getClassName()})`,r,s,e.countParams().toString()],t,n)}function OI(e,t,n,s){let r,i;try{i=e.inboundNodes.map((e=>JSON.stringify(e.inputShapes))).join(",")}catch(SG){i="multiple"}try{r=JSON.stringify(e.outputShape)}catch(SG){r="multiple"}const a=[];for(const c of e.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(c)))for(let e=0;e<c.inboundLayers.length;++e){const t=c.inboundLayers[e].name,n=c.nodeIndices[e],s=c.tensorIndices[e];a.push(`${t}[${n}][${s}]`)}const o=e.name,l=e.getClassName(),u=0===a.length?"":a[0];FI([`${o} (${l})`,i,r,e.countParams().toString(),u],t,s);for(let c=1;c<a.length;++c)FI(["","","","",a[c]],t,s)}function LI(e,t,n){return("inboundNodes"===e||"outputLayers"===e||"inputLayers"===e)&&0===t&&"string"===typeof n}function PI(e,t){if(null===e)return null;if("string"===typeof e)return Kw(e);if("number"===typeof e||"boolean"===typeof e)return e;if(e instanceof Array){const n=[],s=e.length;for(let r=0;r<s;++r){const s=e[r];LI(t,r,s)?n.push(s):n.push(PI(s,t))}return n}{const t={};for(const n of Object.keys(e)){const s=e[n];if("name"===n&&"string"===typeof s)t[n]=s;else{const e=Kw(n);t[e]=PI(s,e)}}return t}}function zI(e,t){if(null===e||void 0===e)return null;if("string"===typeof e)return jw(e);if("number"===typeof e||"boolean"===typeof e)return e;if(e instanceof Array){const n=[],s=e.length;for(let r=0;r<s;++r){const s=e[r];LI(t,r,s)?n.push(s):n.push(zI(s,t))}return n}{const t={};for(const n of Object.keys(e)){const s=e[n],r=jw(n);t[r]="name"!==n&&"className"!==n||"string"!==typeof s?zI(s,n):s}return t}}const BI="4.21.0";class WI extends ES{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,null==this.name){const e=this.getClassName().toLowerCase();this.name=uk(e)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],Jw(this.inputs).length!==this.inputs.length)throw new Lw(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map((e=>e.name))}`);Jw(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map((e=>e.name))}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const b of this.outputs){const e=b.sourceLayer,t=b.nodeIndex,n=b.tensorIndex;this.outputLayers.push(e),this.outputLayersNodeIndices.push(t),this.outputLayersTensorIndices.push(n)}for(const b of this.inputs){const e=b.sourceLayer,t=b.nodeIndex,n=b.tensorIndex;Vw(0===t,"input layer has >1 nodes"),Vw(0===n,"input layer has >1 tensors"),this.inputLayers.push(e),this.inputLayersNodeIndices.push(t),this.inputLayersTensorIndices.push(n)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let b=0;b<this.inputLayers.length;b++){const t=this.inputLayers[b];if(!(t instanceof RS))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${b} (0-based) originates from layer type ${t.getClassName()}.`);this.inputNames.push(t.name),this.feedInputShapes.push(t.batchInputShape),this.feedInputNames.push(t.name)}for(const b of this.outputLayers)this.outputNames.push(b.name);this.internalInputShapes=this.inputs.map((e=>e.shape)),this.internalOutputShapes=this.outputs.map((e=>e.shape));const t={},n={},s={},r={},i={},a=[],o=(e,t,n,s,r,l)=>{null!=s&&null!=r&&null!=l||(s=e.sourceLayer,r=e.nodeIndex,l=e.tensorIndex);const u=s.inboundNodes[r];if(-1!==n.indexOf(u))throw new Ow(`The tensor ${e.name} at layer "${s.name}" is part of a cycle.`);if(-1!==t.indexOf(u))return;this.containerNodes.add(WI.nodeKey(s,r)),s.id in i||(i[s.id]=Object.keys(i).length),-1===n.indexOf(u)&&n.push(u);const c=u.inboundLayers.length;for(let i=0;i<c;i++){const e=u.inputTensors[i],s=u.inboundLayers[i],r=u.nodeIndices[i],a=u.tensorIndices[i];o(e,t,n,s,r,a)}for(t.push(u);n.indexOf(u)>=0;)n.splice(n.indexOf(u),1);a.push(u)},l=[],u=[];for(const b of this.outputs)o(b,l,u);const c=a.slice().reverse();for(const b of c){n[b.id]=b,b.id in t||(t[b.id]=0);let e=t[b.id];const i=null==s[b.outboundLayer.id]?0:s[b.outboundLayer.id];e=Math.max(e,i),s[b.outboundLayer.id]=e,r[b.outboundLayer.id]=b.outboundLayer,t[b.id]=e;for(let s=0;s<b.inboundLayers.length;s++){const r=b.inboundLayers[s],i=b.nodeIndices[s],a=r.inboundNodes[i],o=null==t[a.id]?0:t[a.id];t[a.id]=Math.max(e+1,o),n[a.id]=a}}const h={};for(const b in t){const e=t[b];e in h||(h[e]=[]),h[e].push(n[b])}const d={};for(const b in s){const e=s[b];e in d||(d[e]=[]),d[e].push(r[b])}let p=Object.keys(d).map((e=>parseInt(e,10))).sort(Zw);this.layers=[];for(const b of p){const e=d[b];e.sort(((e,t)=>{const n=i[e.id],s=i[t.id];return n<s?-1:n>s?1:0}));for(const t of e)t instanceof WI&&this.internalContainerRefs.push(t),this.layers.push(t)}this.layersByDepth=d,p=Object.keys(h).map((e=>parseInt(e,10))).sort(Zw);const f=this.inputs.slice(),g=[];for(const b of p)for(const e of h[b]){const t=e.outboundLayer;if(null!=t){for(const n of e.inputTensors)if(-1===f.indexOf(n))throw new Ow(`Graph disconnected: cannot obtain value for tensor ${n} at layer "${t.name}". The following previous layers were accessed without issue: ${g}`);for(const t of e.outputTensors)f.push(t);g.push(t.name)}}this.nodesByDepth=h;const m=this.layers.map((e=>e.name));for(const b of m){const e=m.filter((e=>e===b)).length;if(1!==e)throw new Ow(`The name "${b}" is used ${e} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(m))}this.outboundNodes=[],this.inboundNodes=[],new TS({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map((e=>null)),outputMasks:this.outputs.map((e=>null)),inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs.map((e=>e.shape))}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(0===--this._refCount){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach((t=>{t._trainableWeights.forEach((t=>t.trainable=e))})),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new Lw("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.layers)t.push(...e.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n={};let s=0;const r=(e=>{const t=Object.keys(e);if(0===t.length)return!1;const n=t[0].split("/");return!isNaN(parseInt(n[n.length-1],10))})(e);r&&this.parseWeights(e);for(const a of this.layers)for(const[e,t]of a.weights.entries()){const i=r?`${t.name.split("/").slice(0,-1).join("/")+"/"}${e}`:t.originalName;if(null!=n[i])throw new Lw(`Duplicate weight name: ${i}`);n[i]=t,s++}const i=[];for(const a in e){let s=a;if(null==n[a]){const e=a.split("/");s=e.slice(0,-2).concat([e[e.length-1]]).join("/")}if(null!=n[s])i.push([n[s],e[a]]);else if(t)throw new Lw(`Provided weight data has no target variable: ${a}`);delete n[s]}if(t){const e=[];for(const t in n)e.push(t);if(e.length>0)throw new Lw(`${e.length} of ${s} weights are not set: ${e}`)}SS(i)}parseWeights(e){for(const t in Object.keys(e)){const n=t.split("/"),s=["vars","layer_checkpoint_dependencies"],r=n.map((e=>e.startsWith("_")?e.slice(1):e)).filter((e=>!s.includes(e))).join("/");r!==t&&(e[r]=e[t],delete e[t])}}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${BI}`,t.backend="TensorFlow.js",t}toJSON(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n=zI(this.updatedConfig());return t?JSON.stringify(n):n}call(e,t){return Bd((()=>{e=Hw(e);const n=new DS;for(let t=0;t<this.inputs.length;++t)n.add(this.inputs[t],e[t]);return OS(this.outputs,n,t)}))}computeMask(e,t){return Bd((()=>{let n;return e=Hw(e),n=null==t?Ww(null,e.length):Hw(t),this.runInternalGraph(e,n)[1]}))}computeOutputShape(e){const t=mS(e);if(t.length!==this.inputLayers.length)throw new Lw(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);const n={};for(let a=0;a<t.length;a++){const e=this.inputLayers[a],s=t[a];n[e.name+"_0_0"]=s}const s=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(Zw);if(s.length>1)for(const a of s){const e=this.nodesByDepth[a];for(const t of e){const e=t.outboundLayer;if(-1!==this.inputLayers.map((e=>e.id)).indexOf(e.id))continue;const s=[];for(let a=0;a<t.inboundLayers.length;a++){const e=t.inboundLayers[a],r=t.nodeIndices[a],i=t.tensorIndices[a],o=n[`${e.name}_${r}_${i}`];s.push(o)}const r=mS(e.computeOutputShape(Gw(s))),i=e.inboundNodes.indexOf(t);for(let t=0;t<r.length;t++){n[`${e.name}_${i}_${t}`]=r[t]}}}const r=[],i=[];for(let a=0;a<this.outputLayers.length;a++){const e=this.outputLayers[a],t=this.outputLayersNodeIndices[a],n=this.outputLayersTensorIndices[a],s=`${e.name}_${t}_${n}`;i.push(s)}for(let a=0;a<i.length;a++){const e=i[a];Vw(e in n),r.push(n[e])}return Gw(r)}runInternalGraph(e,t){null==t&&(t=Ww(null,e.length));const n={};for(let o=0;o<this.inputs.length;++o){const s=this.inputs[o],r=e[o],i=t[o];n[s.id]=[r,i]}const s=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(Zw);for(const o of s){const e=this.nodesByDepth[o];for(const t of e){const e=t.outboundLayer,s=t.inputTensors,r=t.outputTensors,i=new Array;for(const t of s)t.id in n&&i.push(n[t.id]);if(i.length===s.length){let s,a,o,l,u={};if(null!=t.callArgs&&(u=t.callArgs),1===i.length){const[t,n]=i[0];null==u.mask&&(u.mask=n),o=Hw(e.call(t,u)),l=Hw(e.computeMask(t,n)),s=[t],a=[n]}else s=i.map((e=>e[0])),a=i.map((e=>e[1])),null==u.mask&&(u.mask=a),o=Hw(e.call(s,u)),l=Hw(e.computeMask(s,a));if(e.activityRegularizer)throw new Pw("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let e=0;e<r.length;++e){const t=r[e],s=o[e],i=l[e];n[t.id]=[s,i]}}}}const r=[],i=[],a=[];for(const o of this.outputs){Vw(o.id in n,`Could not compute output ${o.name} : ${o.id}`);const[e,t]=n[o.id];a.push(e.shape),r.push(e),i.push(t)}return[r,i,a]}buildNodeConversionMap(e){const t={};let n;for(const s of this.layers){n=s instanceof WI?1:0;for(let e=0;e<s.inboundNodes.length;e++){const r=WI.nodeKey(s,e);this.containerNodes.has(r)&&(t[r]=n,n+=1)}}return t}getLayer(e,t){if(null!=t)return this.findLayer(t);if(null==e)throw new Lw("Provide either a layer name or layer index");if("number"===typeof e)return this.findLayer(e);for(const n of this.layers)if(n.name===e)return n;throw new Lw(`No such layer: ${e}`)}findLayer(e){if(this.layers.length<=e)throw new Lw(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}calculateLosses(){return Bd((()=>{const e=[];for(const t of this.layers)for(let n=0;n<t.inboundNodes.length;++n){const s=WI.nodeKey(t,n);this.containerNodes.has(s)&&e.push(...t.calculateLosses())}return e}))}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),n=[];for(const i of this.layers){const e=i.getClassName(),s=i.getConfig(),r=[];for(let n=0;n<i.inboundNodes.length;n++){const e=i.inboundNodes[n],s=WI.nodeKey(i,n);let a={};if(this.containerNodes.has(s)){if(e.callArgs)try{JSON.stringify(e.callArgs),a=e.callArgs}catch(SG){console.warn(`Layer ${i.name} was passed non-serializable keyword arguments: ${e.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),a={}}if(e.inboundLayers.length>0){const n=[];for(let s=0;s<e.inboundLayers.length;s++){const r=e.inboundLayers[s],i=e.nodeIndices[s],o=e.tensorIndices[s];let l=t[WI.nodeKey(r,i)];null==l&&(l=0),n.push([r.name,l,o,a])}r.push(n)}}}const a={};a.name=i.name,a.className=e,a.config=s,a.inboundNodes=r,n.push(a)}e.layers=n;const s=[];for(let i=0;i<this.inputLayers.length;i++){const e=this.inputLayers[i],n=this.inputLayersNodeIndices[i],r=WI.nodeKey(e,n);if(!this.containerNodes.has(r))continue;let a=t[r];null!==a&&void 0!==a||(a=0);const o=this.inputLayersTensorIndices[i];s.push([e.name,a,o])}e.inputLayers=s;const r=[];for(let i=0;i<this.outputLayers.length;i++){const e=this.outputLayers[i],n=this.outputLayersNodeIndices[i],s=WI.nodeKey(e,n);if(!this.containerNodes.has(s))continue;let a=t[s];null!==a&&void 0!==a||(a=0);const o=this.outputLayersTensorIndices[i];r.push([e.name,a,o])}return e.outputLayers=r,e}static fromConfig(e,t){let n=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const s={},r={};function i(e,t){e.name in r?r[e.name].push(t):r[e.name]=[t]}function a(e,t){const n=[];let r;for(const a of t){const o=a[0],l=a[1],u=a[2];if(r=null==a[3]?{}:a[3],!(o in s))return void i(e,t);const c=s[o];if(c.inboundNodes.length<=l)return void i(e,t);const h=c.inboundNodes[l];n.push(h.outputTensors[u])}n.length>0&&e.apply(Gw(n),r)}function o(e){const r=e.name,a=oI(e,null!=t.customObjects?t.customObjects:{});a.setFastWeightInitDuringBuild(n),s[r]=a;e.inboundNodes.forEach((e=>{if(!(e instanceof Array))throw new Lw(`Corrupted configuration, expected array for nodeData: ${e}`);i(a,e)}))}const l=t.name,u=t.layers;for(const f of u)o(f);for(;!ek(r);)for(const e of u){const t=s[e.name];if(t.name in r){const e=r[t.name];delete r[t.name];for(const n of e)a(t,n)}}const c=[],h=[],d=t.inputLayers;for(const f of d){const e=f[0],t=f[1],n=f[2];Vw(e in s);const r=s[e].inboundNodes[t].outputTensors;c.push(r[n])}const p=t.outputLayers;for(const f of p){const e=f[0],t=f[1],n=f[2];Vw(e in s);const r=s[e].inboundNodes[t].outputTensors;h.push(r[n])}return new e({inputs:c,outputs:h,name:l})}get stateful(){if(this._stateful)throw new Lw("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){Bd((()=>{this.layers.forEach((e=>{e.stateful&&e.resetStates()}))}))}}function VI(e,t,n){const s=t.length;if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>null));if(1===s)return Array.isArray(e)&&1===e.length?e:"object"===typeof e&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==s)throw new Error(`Provided ${n} is an array of ${e.length} element(s), but the model has ${s} outputs. Make sure a set of weights is provided for each model output.`);return e}if("object"===typeof e&&Object.keys(e).length>0&&"object"===typeof e[Object.keys(e)[0]]){const n=[];return t.forEach((t=>{t in e?n.push(e[t]):n.push(null)})),n}throw new Error(`The model has multiple (${s}) outputs, so ${n} must be either an array with ${s} elements or an object with ${t} keys. Provided ${n} not understood: ${JSON.stringify(e)}`)}function UI(e,t){return VI(e,t,"classWeight")}async function GI(e,t,n,s){if(null!=t||null!=s)throw new Error("Support sampleWeight is not implemented yet");if(null!=n){const t=Bd((()=>{if(1===e.shape.length)return Ep(e);if(2===e.shape.length){if(e.shape[1]>1){return Lf(e,1)}if(1===e.shape[1])return Jf(e,[e.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${e.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}throw new Error(`Unexpected rank of target (y) tensor (${e.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)})),s=Array.from(await t.data());Wd(t);const r=[];return s.forEach((e=>{if(null==n[e])throw new Error(`classWeight must contain all classes in the training data. The class ${e} exists in the data but not in classWeight`);r.push(n[e])})),Am(r,"float32")}return null}function HI(e,t){return Dp(e,t)}function jI(e,t){let n,s;const r=t;n=r.xs,s=r.ys,go(null!=n&&null!=s,(()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`));const i=KI("input",e.inputNames,n),a=KI("output",e.outputNames,s),o=i[0].shape[0];go(i.length===e.inputs.length,(()=>`LayersModel has ${e.inputs.length} inputs, but the dataset provides ${i.length} inputs.  (Expected input keys: ${JSON.stringify(e.inputNames)})`)),go(a.length===e.outputs.length,(()=>`LayersModel has ${e.outputs.length} outputs, but the dataset provides ${a.length} outputs.  (Expected output keys: ${JSON.stringify(e.outputNames)})`));for(let l=0;l<i.length;l++)go(i[l].shape[0]===o,(()=>`Batch size mismatch: input ${e.inputNames[l]} has ${i[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`));for(let l=0;l<a.length;l++)go(a[l].shape[0]===o,(()=>`Batch size mismatch: output ${e.outputNames[l]} has ${a[l].shape[0]}; expected  ${o} based on input ${e.inputNames[0]}.`));return{xs:i,ys:a}}function KI(e,t,n){if(n instanceof td)return[n];if(Array.isArray(n))return go(n.length===t.length,(()=>`Received an array of ${n.length} Tensors, but expected ${t.length} to match the ${e} keys ${t}.`)),n;{const s=[];for(const r of t){if(null==n[r])throw new Lw(`The feature data generated by the dataset lacks the required ${e} key '${r}'.`);s.push(n[r])}return s}}async function XI(e,t,n){const s=null!=n.batchesPerEpoch;if(go(null!=e.optimizer,(()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig).")),go(null!=n,(()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call.")),go(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),(()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${n.epochs}`)),go(!s||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),(()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${n.batchesPerEpoch}`)),go(null==n.validationSplit,(()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead.")),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{const r=null!=n.validationData;let i,a;if(r)if(qI(n.validationData))go(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),(()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${n.validationBatches}`));else{const e=function(e){if(3===e.length)throw new Pw("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}(n.validationData);i=e.xs,a=e.ys}const o=e.makeTrainFunction(),l=e.getDedupedMetricsNames();let u;u=r?l.slice().concat(l.map((e=>"val_"+e))):l.slice();const c=rI(n.callbacks,n.yieldEvery),h=null==n.verbose?1:n.verbose,{callbackList:d,history:p}=aI(c,h,n.epochs,null,null,function(e,t){let n=null;null!=t.batchesPerEpoch?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size);return n}(t,n),null,r,u);d.setModel(e),e.history=p,await d.onTrainBegin(),e.stopTraining_=!1;let f=null==n.initialEpoch?0:n.initialEpoch,g=await t.iterator();for(;f<n.epochs;){const u={};await d.onEpochBegin(f);let c=0,h=0;for(s||(g=await t.iterator());!s||c<n.batchesPerEpoch;){const t=await g.next();if(s&&t.done){console.warn(`You provided \`batchesPerEpoch\` as ${n.batchesPerEpoch}, but your dataset iterator ran out of data after ${c} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, `+n.batchesPerEpoch*n.epochs+" batches). You may need to use the repeat() function when building your dataset.");break}if(null!=t.value){const{xs:s,ys:r}=jI(e,t.value),i={};i.batch=h,i.size=s[0].shape[0],await d.onBatchBegin(h,i);const a=[];if(null!=n.classWeight){const t=UI(n.classWeight,e.outputNames);for(let e=0;e<t.length;++e)a.push(await GI(r[e],null,t[e]))}const u=s.concat(r).concat(a),p=o(u);Wd(u);for(let e=0;e<l.length;++e){const t=l[e],n=p[e];i[t]=n,Vd(n)}await d.onBatchEnd(h,i),QS(i),h++,c++}if(s?c>=n.batchesPerEpoch:t.done){if(r){let t;t=qI(n.validationData)?Hw(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):Hw(e.evaluate(i,a,{batchSize:null==n.validationBatchSize?32:n.validationBatchSize,verbose:0}));for(let n=0;n<e.metricsNames.length;++n)u[`val_${e.metricsNames[n]}`]=t[n]}break}if(e.stopTraining_)break}if(await d.onEpochEnd(f,u),f++,e.stopTraining_)break}return await d.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function qI(e){return"function"===typeof e.iterator}function YI(e){go(e>0&&Number.isInteger(e),(()=>`batchSize is required to be a positive integer, but got ${e}`))}function QI(e,t,n){return null==e?[null]:Array.isArray(e)?e.map((e=>Dk(e,t,n-t))):Dk(e,t,n-t)}function ZI(e,t){return Bd((()=>null==e?null:Array.isArray(e)?e.map((e=>ZI(e,t))):Wk(e,"int32"===t.dtype?t:_p(t,"int32"))))}function JI(e,t){const n=[];let s=0,r=null;for(;s<e;)r=s+t,r>=e&&(r=e),n.push([s,r]),s=r;return n}function eC(e){const t=[];e instanceof td&&(e=[e]);for(let n=0;n<e.length;++n){const s=e[n];if(1===s.rank)t.push(Ak(s,1));else{if(0===s.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(s)}}return t}function tC(e,t){if(null==e)return;const n=[];if(t instanceof td)n.push(t.id);else if(Array.isArray(t))t.forEach((e=>n.push(e.id)));else if(null!=t)for(const r in t){const e=t[r];n.push(e.id)}const s=[];if(e instanceof td)-1===n.indexOf(e.id)&&s.push(e);else if(Array.isArray(e))e.forEach((e=>{-1===n.indexOf(e.id)&&s.push(e)}));else if(null!=e)for(const r in e){const t=e[r];-1===n.indexOf(t.id)&&s.push(t)}s.forEach((e=>{e.isDisposed||e.dispose()}))}function nC(e){return Array.isArray(e)}function sC(e){return!function(e){return e instanceof td}(e)&&!nC(e)}function rC(e,t,n){let s,r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"";if(null==t||0===t.length){if(null!=e){let t=!1;if(nC(e)&&e.length>0)t=!0;else if(sC(e)){for(const n in e)if(e.hasOwnProperty(n)){t=!0;break}}else t=!0;if(t)throw new Lw(`Error when checking model ${i} expected no data, but got ${e}`)}return[]}if(null==e)return t.map((e=>null));if(sC(e)){s=[];for(const n of t){if(null==e[n])throw new Lw(`No data provided for "${n}". Need data for each key in: ${t}`);s.push(e[n])}}else if(nC(e)){if(e.length!==t.length)throw new Lw(`Error when checking model ${i}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${e}`);s=e}else{if(t.length>1)throw new Lw(`The model ${i} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${e.shape}`);s=[e]}if(s=eC(s),null!=n)for(let a=0;a<t.length;++a){if(null==n[a])continue;const e=s[a];if(e.shape.length!==n[a].length)throw new Lw(`Error when checking ${i}: expected ${t[a]} to have ${n[a].length} dimension(s). but got array with shape ${e.shape}`);for(let t=0;t<n[a].length;++t){if(0===t&&!r)continue;const s=e.shape[t],o=n[a][t];if(null!=o&&o>=0&&s!==o)throw new Lw(`${i} expected a batch of elements where each example has shape [${n[a].slice(1,n[a].length)}] (i.e.,tensor shape [*,${n[a].slice(1,n[a].length)}]) but the ${i} received an input with ${e.shape[0]} examples, each with shape [${e.shape.slice(1,e.shape.length)}] (tensor shape [${e.shape}])`)}}return s}function iC(e,t,n){let s,r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"";if(Array.isArray(e)){if(e.length!==t.length)throw new Lw(`Error when checking model ${i}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${e.length} Tensors(s).`);s=e}else{if(t.length>1)throw new Lw(`The model expects ${t.length} ${i} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(e.shape)}.`);s=[e]}if(null!=n)for(let a=0;a<t.length;++a){if(null==n[a])continue;const e=s[a];if(e.shape.length!==n[a].length)throw new Lw(`Error when checking ${i}: expected ${t[a]} to have ${n[a].length} dimension(s), but got array with shape ${JSON.stringify(e.shape)}`);for(let s=0;s<n[a].length;++s){if(0===s&&!r)continue;const o=e.shape[s],l=n[a][s];if(null!=l&&l!==o)throw new Lw(`Error when checking ${i}: expected ${t[a]} to have shape ${JSON.stringify(n[a])} but got array with shape ${JSON.stringify(e.shape)}.`)}}}class aC extends WI{constructor(e){super(e),this.isTraining=!1}summary(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log;if(!this.built)throw new Lw("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");DI(this,e,t,n)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"===typeof e.optimizer)this.optimizer_=function(e){const t={Adagrad:()=>Vb.adagrad(.01),Adadelta:()=>Vb.adadelta(1,.95,$k()),Adam:()=>Vb.adam(.001,.9,.999,$k()),Adamax:()=>Vb.adamax(.002,.9,.999,$k(),0),RMSProp:()=>Vb.rmsprop(.001,.9,0,$k()),SGD:()=>Vb.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new Lw(`Unknown Optimizer ${e}`)}(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof Gp))throw new Lw("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(Array.isArray(e.loss)||"string"===typeof e.loss||"function"===typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new Lw(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);const n=e.loss;t=n.map((e=>yI(e)))}else{const n=yI(e.loss);this.outputs.forEach((e=>{t.push(n)}))}else{e.loss=e.loss;for(const t in e.loss)if(-1===this.outputNames.indexOf(t))throw new Lw(`Unknown entry in loss dictionary: "${t}". Only expected the following keys: ${this.outputNames}`);for(const n of this.outputNames)null==e.loss[n]&&console.warn(`Output "${n}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${n} during training`),t.push(yI(e.loss[n]))}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let i=0;i<this.outputs.length;++i){const e=this.internalOutputShapes[i],t=this.outputNames[i];this.feedOutputNames.push(t),this.feedOutputShapes.push(e),this.feedLossFns.push(this.lossFunctions[i])}const n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],vk("loss",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;const t=this.lossFunctions[e];this.outputs.length>1&&(this.metricsTensors.push([t,e]),this.metricsNames.push(this.outputNames[e]+"_loss"))}}));const s=function(e,t){if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>[]));let n;if("string"===typeof e||"function"===typeof e)n=[e];else{if(!Array.isArray(e)&&"object"!==typeof e)throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${e}`);n=e}if(Array.isArray(n))return t.map((e=>n));{const e=[];for(const s of t){let t=n.hasOwnProperty(s)?n[s]:[];Array.isArray(t)||(t=[t]),e.push(t)}return e}}(e.metrics,this.outputNames),r=(e,t,n)=>{this.outputNames.length>1&&(t=this.outputNames[e]+"_"+t),this.metricsNames.push(t),this.metricsTensors.push([n,e])};vk("metric",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;(t=>{let n,s,i;for(const a of t){if("string"===typeof a&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(a)){const t=this.internalOutputShapes[e];let r;1===t[t.length-1]||this.lossFunctions[e]===gI?-1!==["accuracy","acc"].indexOf(a)?s=vI:-1!==["crossentropy","ce"].indexOf(a)&&(s=SI):this.lossFunctions[e]===fI?-1!==["accuracy","acc"].indexOf(a)?s=II:-1!==["crossentropy","ce"].indexOf(a)&&(s=NI):-1!==["accuracy","acc"].indexOf(a)?s=wI:-1!==["crossentropy","ce"].indexOf(a)&&(s=CI),-1!==["accuracy","acc"].indexOf(a)?r="acc":-1!==["crossentropy","ce"].indexOf(a)&&(r="ce"),i=s,n=""+r}else{const e=_I(a);i=e,n=""+EI(a)}let t;vk(n,(()=>{t=i})),r(e,n,t)}})(s[e])}})),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const s=null==n.batchSize?32:n.batchSize;YI(s);const r=this.standardizeUserDataXY(e,t,!0,s);try{const e=r[0].concat(r[1]);this.makeTestFunction();const t=this.testFunction;return Gw(this.testLoop(t,e,s,n.verbose,n.steps))}finally{tC(r[0],e),tC(r[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),async function(e,t,n){const s=null!=(n=n||{}).batches,r=e.testFunction;let i=[];if(n.verbose>0)throw new Pw("Verbose mode is not implemented yet.");go(!s||n.batches>0&&Number.isInteger(n.batches),(()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(n.batches)}`));const a="function"===typeof t.next?t:await t.iterator();let o=0,l=0;for(;!s||l<n.batches;){const t=await a.next();if(i=Bd((()=>{if(t.value){const{xs:n,ys:s}=jI(e,t.value),a=n.concat(s),u=Bd((()=>r(a)));if(Wd(a),0===l)for(let e=0;e<u.length;++e)i.push(Pp(0));const c=a[0].shape[0];for(let e=0;e<u.length;++e){const t=u[e],n=i[e];i[e]=Bd((()=>$p(i[e],Dp(c,t)))),l>0&&Wd(n)}Wd(u),o+=c,++l}return i})),t.done){s&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${n.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let u=0;u<i.length;++u){const e=i[u];i[u]=Ap(i[u],o),Wd(e)}return Gw(i)}(this,e,t)}checkNumSamples(e,t,n){let s,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"steps";if(null!=n){if(s=null,null!=t)throw new Lw(`If ${r} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else{if(null==e)throw new Lw(`Either the input data should have a defined shape, or ${r} shoud be specified.`);s=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return s}execute(e,t){if(Array.isArray(t)&&0===t.length)throw new Lw("`outputs` is an empty Array, which is not allowed.");const n=Array.isArray(t),s=n?t:[t],r=this.retrieveSymbolicTensors(s),i=new DS;if(e instanceof td&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new Lw(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let t=0;t<this.inputs.length;++t)i.add(this.inputs[t],e[t])}else for(const o of this.inputs){const t=e[o.name];if(null==t)throw new Lw(`No value is provided for the model's input ${o.name}`);i.add(o,t)}const a=OS(r,i);return n?a:a[0]}retrieveSymbolicTensors(e){const t=Ww(null,e.length);let n=e.length;for(const s of this.layers){const r=Array.isArray(s.output)?s.output:[s.output],i=r.map((e=>e.name));for(let s=0;s<e.length;++s){const a=i.indexOf(e[s]);if(-1!==a&&(t[s]=r[a],n--),0===n)break}if(0===n)break}if(n>0){const n=[];throw t.forEach(((t,s)=>{null==t&&n.push(e[s])})),new Lw(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(n)}`)}return t}predictLoop(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:32,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return Bd((()=>{const s=this.checkNumSamples(e);if(n)throw new Pw("Verbose predictLoop() is not implemented yet.");const r=JI(s,t),i=this.outputs.map((e=>[]));for(let t=0;t<r.length;++t){Bd((()=>{const n=r[t][0],s=r[t][1],i=QI(e,n,s),a=[];if(Array.isArray(i))for(let e=0;e<i.length;++e)a.push({key:this.inputs[e],value:i[e]});else a.push({key:this.inputs[0],value:i});const o=new DS(a);return OS(this.outputs,o)})).forEach(((e,t)=>i[t].push(e)))}return Gw(i.map((e=>lg(e,0))))}))}predict(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=eC(e);iC(n,this.inputNames,this.feedInputShapes,!1);try{const e=null==t.batchSize?32:t.batchSize;return YI(e),this.predictLoop(n,e)}finally{tC(n,e)}}predictOnBatch(e){iC(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t){let n=arguments.length>3?arguments[3]:void 0;if(null==this.optimizer_)throw new Ow("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const s=[];for(let r=0;r<this.feedOutputShapes.length;++r){const e=this.feedOutputShapes[r];this.feedLossFns[r]===fI?s.push(e.slice(0,e.length-1).concat([1])):s.push(e)}if(function(e,t){const n=Jw(e.map((e=>e.shape[0])));n.sort();const s=Jw(t.map((e=>e.shape[0])));if(s.sort(),n.length>1)throw new Lw(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map((e=>e.shape)))}`);if(s.length>1)throw new Lw(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map((e=>e.shape)))}`);if(n.length>0&&s.length>0&&!yo(n,s))throw new Lw(`Input Tensors should have the same number of samples as target Tensors. Found ${n[0]} input sample(s) and ${s[0]} target sample(s).`)}(e=rC(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=rC(t,this.feedOutputNames,s,!1,"target")),function(e,t,n){const s=[uI,gI,pI];for(let r=0;r<e.length;++r){const i=e[r],a=t[r],o=n[r];if(null!=a){if(a===pI&&1===i.shape[i.shape.length-1])throw new Lw(`You are passing a target array of shape ${i.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(-1!==s.indexOf(a)){const e=i.shape.slice(1),t=o.slice(1);for(let n=0;n<e.length;++n){const s=e[n],r=t[n];if(null!=r&&s!==r)throw new Lw(`A target Tensor with shape ${i.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=n&&n>0&&e[0].shape[0]%n!==0)throw new Lw(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${n}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,n,s){let r=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],i=arguments.length>5?arguments[5]:void 0;const[a,o]=this.standardizeUserDataXY(e,t,r,i);if(null!=n)throw new Error("sample weight is not supported yet.");let l=null;if(null!=s){const e=UI(s,this.outputNames);l=[];for(let t=0;t<e.length;++t)l.push(await GI(o[t],null,e[t]))}return[a,o,l]}testLoop(e,t,n){let s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,r=arguments.length>4?arguments[4]:void 0;return Bd((()=>{const i=this.checkNumSamples(t,n,r,"steps"),a=[];if(s>0)throw new Pw("Verbose mode is not implemented yet.");if(null!=r)throw new Pw("steps mode in testLoop() is not implemented yet");{const s=JI(i,n),r=Am(_k(0,i));for(let n=0;n<s.length;++n){const i=s[n][0],o=s[n][1],l=Dk(r,i,o-i),u=ZI(t,l),c=e(u);if(0===n)for(let e=0;e<c.length;++e)a.push(Pp(0));for(let e=0;e<c.length;++e){const t=c[e];a[e]=$p(a[e],Dp(o-i,t))}}for(let e=0;e<a.length;++e)a[e]=Ap(a[e],i)}return a}))}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){const s=e[n];let r=s;if(Uw(e,s)>1){r+=`_${Uw(e.slice(0,n),s)}`}t.push(r)}return t}makeTrainFunction(){return e=>{const t=[],n=e.slice(0,this.inputs.length),s=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),r=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),i=[],a=this.collectedTrainableWeights.map((e=>e.read()));return[this.optimizer_.minimize((()=>{const e=[];for(let t=0;t<this.inputs.length;++t)e.push({key:this.inputs[t],value:n[t]});const a=new DS(e),o=OS(this.outputs,a,{training:!0});let l;for(let n=0;n<this.lossFunctions.length;++n){let e=(0,this.lossFunctions[n])(s[n],o[n]);null!=r[n]&&(e=HI(e,r[n]));const i=Zg(e);t.push(i),l=0===n?e:$p(l,e)}for(let n=0;n<this.metricsTensors.length;++n){let e;if(this.outputs.length>1&&n<this.outputs.length)e=t[n];else{const t=this.metricsTensors[n][0],r=this.metricsTensors[n][1];e=Zg(t(s[r],o[r]))}Vd(e),i.push(e)}return l=Zg(l),this.calculateLosses().forEach((e=>{l=$p(l,e)})),l}),!0,a)].concat(i)}}makeTestFunction(){this.testFunction=e=>Bd((()=>{const t=[];let n;const s=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),i=[];for(let e=0;e<this.inputs.length;++e)i.push({key:this.inputs[e],value:s[e]});const a=new DS(i),o=OS(this.outputs,a);for(let e=0;e<this.lossFunctions.length;++e){const s=this.lossFunctions[e],i=Zg(s(r[e],o[e]));n=0===e?i:$p(n,i),t.push(n)}for(let e=0;e<this.metricsTensors.length;++e){const n=this.metricsTensors[e][0],s=this.metricsTensors[e][1],i=Zg(n(r[s],o[s]));t.push(i)}return t}))}async fit(e,t){let n,s,r,i,a,o,l,u,c,h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;try{const d=null==h.batchSize?32:h.batchSize;YI(d);const p=!1,f=await this.standardizeUserData(e,t,h.sampleWeight,h.classWeight,p,d);n=f[0],s=f[1],c=f[2];let g,m=!1;if(null!=h.validationData&&h.validationData.length>0){if(m=!0,2!==h.validationData.length)throw 3===h.validationData.length?new Pw("validationData including sample weights is not supported yet."):new Lw(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${h.validationData} is invalid.`);a=h.validationData[0],o=h.validationData[1];const e=!0,t=await this.standardizeUserData(a,o,null,null,e,d);l=t[0],u=t[1],g=l.concat(u)}else if(null!=h.validationSplit&&h.validationSplit>0&&h.validationSplit<1){m=!0;const e=Math.floor(n[0].shape[0]*(1-h.validationSplit)),t=n[0].shape[0];l=QI(n,e,t),r=n,n=QI(n,0,e),u=QI(s,e,t),i=s,s=QI(s,0,e),g=l.concat(u)}else null!=h.validationSteps&&(m=!0);const b=n.concat(s).concat(c);this.checkTrainableWeightsConsistency();const x=this.makeTrainFunction(),y=this.getDedupedMetricsNames();let v,w;m?(this.makeTestFunction(),v=this.testFunction,w=y.slice().concat(y.map((e=>"val_"+e)))):(v=null,g=[],w=y.slice());const k=rI(h.callbacks,h.yieldEvery);return await this.fitLoop(x,b,y,d,h.epochs,h.verbose,k,v,g,h.shuffle,w,h.initialEpoch,null,null)}finally{this.isTraining=!1,tC(n,e),tC(s,t),tC(r,e),tC(i,t),tC(l,a),tC(u,o),null!=c&&Wd(c)}}async fitLoop(e,t,n,s,r,i,a,o,l,u,c,h,d,p){null==s&&(s=32),null==r&&(r=1),null==u&&(u=!0),null==h&&(h=0);let f=!1;if(null!=o&&null!=l&&(f=!0),null!=p&&(f=!0,null==d))throw new Lw("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const g=this.checkNumSamples(t,s,d,"steps_per_epoch");let m;null!=g&&(m=_k(0,g)),null==i&&(i=1);const{callbackList:b,history:x}=aI(a,i,r,h,g,d,s,f,c);b.setModel(this),this.history=x,await b.onTrainBegin(),this.stopTraining_=!1;for(let y=h;y<r;++y){await b.onEpochBegin(y);const r={};if(null!=d)throw new Pw("stepsPerEpoch mode is not implemented yet.");{if("batch"===u)throw new Pw("batch shuffling is not implemneted yet");u&&co(m);const i=Am(m),a=JI(g,s);for(let u=0;u<a.length;++u){const c={};if(await b.onBatchBegin(u,c),Bd((()=>{const h=a[u][0],d=a[u][1],p=Dk(i,h,d-h);c.batch=u,c.size=d-h;const g=ZI(t,p),m=e(g);for(let e=0;e<n.length;++e){const t=n[e],s=m[e];c[t]=s,Vd(s)}if(u===a.length-1&&f){const e=this.testLoop(o,l,s);for(let t=0;t<n.length;++t){const s=n[t],i=e[t];Vd(i),r["val_"+s]=i}}})),await b.onBatchEnd(u,c),QS(c),this.stopTraining_)break}i.dispose()}if(await b.onEpochEnd(y,r),this.stopTraining_)break}return await b.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return XI(this,e,t)}async trainOnBatch(e,t){const n=await this.standardizeUserData(e,t),s=n[0],r=n[1],i=this.makeTrainFunction()(s.concat(r)),a=[];for(const o of i){const e=await o.data();a.push(e[0])}return Wd(i),tC(n[0],e),tC(n[1],t),Gw(a)}getNamedWeights(e){const t=[],n=null!=e&&e.trainableOnly,s=n?this.trainableWeights:this.weights,r=this.getWeights(n);for(let i=0;i<s.length;++i)n&&!s[i].trainable||t.push({name:s[i].originalName,tensor:r[i]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const t=zd().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-zd().numTensors}return e}getLossIdentifiers(){let e;if("string"===typeof this.loss)e=jw(this.loss);else if(Array.isArray(this.loss)){for(const e of this.loss)if("string"!==typeof e)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map((e=>jw(e)))}else{const t=Object.keys(this.loss);e={};const n=this.loss;for(const s of t){if("string"!==typeof n[s])throw new Error("Serialization of non-string loss is not supported.");e[s]=jw(n[s])}}return e}getMetricIdentifiers(){if("string"===typeof this.metrics||"function"===typeof this.metrics)return[jw(EI(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map((e=>jw(EI(e))));{const e={};for(const t in this.metrics)e[t]=jw(EI(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const t=oI(PI(e.optimizer_config));let n,s;if("string"===typeof e.loss)n=Kw(e.loss);else if(Array.isArray(e.loss))n=e.loss.map((e=>Kw(e)));else if(null!=e.loss){n={};for(const t in e.loss)n[t]=Kw(e.loss[t])}if(Array.isArray(e.metrics))s=e.metrics.map((e=>Kw(e)));else if(null!=e.metrics){s={};for(const t in e.metrics)s[t]=Kw(e.metrics[t])}this.compile({loss:n,metrics:s,optimizer:t})}async save(e,t){if("string"===typeof e){const t=(n=e,Jd.getSaveHandlers(n));if(0===t.length)throw new Lw(`Cannot find any save handlers for URL '${e}'`);if(t.length>1)throw new Lw(`Found more than one (${t.length}) save handlers for URL '${e}'`);e=t[0]}var n;if(null==e.save)throw new Lw("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const s=await Hd(this.getNamedWeights(t)),r={modelTopology:this.toJSON(null,!1),format:"layers-model",generatedBy:`TensorFlow.js tfjs-layers v${BI}`,convertedBy:null};if(null!=t&&t.includeOptimizer&&null!=this.optimizer){r.trainingConfig=this.getTrainingConfig();const e="optimizer",{data:t,specs:n}=await Hd(await this.optimizer.getWeights(),e);s.specs.push(...n),s.data=(i=[s.data,t],Ld.join(i))}var i;if(null!=this.userDefinedMetadata){const e=!0;RI(this.userDefinedMetadata,this.name,e),r.userDefinedMetadata=this.userDefinedMetadata}return r.weightData=s.data,r.weightSpecs=s.specs,e.save(r)}setUserDefinedMetadata(e){RI(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}aC.className="Model",Up(aC);class oC extends aC{}oC.className="Functional",Up(oC);class lC extends aC{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:uk("sequential_"),null!=e.layers)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some((e=>e<0)))throw new Lw(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const t=e instanceof lC||e instanceof aC;let n;if(t){if(n=e,1!==n.outputs.length)throw new Lw("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==n.inputs.length)throw new Lw("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new Lw("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const t=AS({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(t)}if(t)this.outputs=n.outputs,this.inputs=n.inputs;else{if(1!==e.inboundNodes.length)throw new Lw(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(1!==e.inboundNodes[0].outputTensors.length)throw new Lw("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=$S(this.outputs[0])}this.inboundNodes=[],new TS({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Ww(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs[0].shape})}else{const t=e.apply(this.outputs[0]);if(Array.isArray(t))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[t],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return null==this.model&&this.build(),this.model.call(e,t)}build(e){if(xS(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new aC({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log;this.built||this.build(),super.summary(e,t,n)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.built)throw new Ow("The model needs to be compiled before being used.");return this.model.evaluate(e,t,n)}async evaluateDataset(e,t){if(!this.built)throw new Ow("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return null==this.model&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.built)throw new Ow("The model needs to be compiled before being used.");return this.model.fit(e,t,n)}async fitDataset(e,t){if(!this.built)throw new Ow("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t){let n,s=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r={};if(t instanceof Array){if(null==t[0].className||"Merge"===t[0].className)throw new Lw("Legacy serialization format not supported yet.");n=t}else go(null!=t.layers,(()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.")),n=t.layers,delete t.layers,r=t;const i=new e(r);if(!(i instanceof lC))throw new Pw(`Sequential.fromConfig called on non-Sequential input: ${i}`);for(const a of n){const e=oI(a,void 0,s);s&&e.setFastWeightInitDuringBuild(!0),i.add(e)}return i}set stopTraining(e){if(null==this.model)throw new Lw("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new Lw("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const n={};n.className=t.getClassName(),n.config=t.getConfig(),e.push(n)}return{name:this.name,layers:e}}}lC.className="Sequential",Up(lC);class uC extends Wp{getConfig(){return{}}}class cC extends uC{apply(e){return function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(1!==t)throw new Pw(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return kg(e)}(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:1)}}cC.className="elu",Up(cC);class hC extends uC{apply(e){return xm(e)}}hC.className="selu",Up(hC);class dC extends uC{apply(e){return mm(e)}}dC.className="relu",Up(dC);class pC extends uC{apply(e){return Bd((()=>em(6,mm(e))))}}pC.className="relu6",Up(pC);class fC extends uC{apply(e){return e}}fC.className="linear",Up(fC);class gC extends uC{apply(e){return vm(e)}}gC.className="sigmoid",Up(gC);class mC extends uC{apply(e){return function(e){return Bd((()=>{const t=$p(.5,Dp(.2,e));return og(t,0,1)}))}(e)}}mC.className="hardSigmoid",Up(mC);class bC extends uC{apply(e){return Tm(e)}}bC.className="softplus",Up(bC);class xC extends uC{apply(e){return function(e){return Bd((()=>Ap(e,$p(Qp(e),1))))}(e)}}xC.className="softsign",Up(xC);class yC extends uC{apply(e){return Rm(e)}}yC.className="tanh",Up(yC);class vC extends uC{apply(e){return Nm(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1)}}vC.className="softmax",Up(vC);class wC extends uC{apply(e){return Pg(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1)}}wC.className="logSoftmax",Up(wC);class kC extends uC{apply(e){return Bd((()=>Bd((()=>{const t=Math.sqrt(2),n=Dp(.5,$p(1,Ig(Ap(e,t))));return Dp(e,n)}))))}}kC.className="gelu",Up(kC);class SC extends uC{apply(e){return Bd((()=>Dp(.5,Dp(e,$p(1,Rm(Dp(Fp(Ap(2,Math.PI)),$p(e,Dp(.044715,Xp(e,3))))))))))}}SC.className="gelu_new",Up(SC);class IC extends uC{apply(e){return Bd((()=>Dp(e,Rm(Tm(e)))))}}IC.className="mish",Up(IC);class CC extends uC{apply(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return Bd((()=>Dp(vm(Dp(e,t)),e)))}}function NC(e){return e.getClassName()}function TC(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Qw(e,Vp.getMap().classNameMap,t,"activation")}function _C(e){if(null==e){const e={className:"linear",config:{}};return TC(e)}if("string"===typeof e){const t={};return t.className=e,t.config={},TC(t)}return e instanceof uC?e:TC(e)}function EC(e){if(null!=e&&"object"!==typeof e)throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${e}`)}CC.className="swish",Up(CC);class $C extends Wp{}class RC extends $C{constructor(e){super(),EC(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return Bd((()=>{let t=im([1]);return this.hasL1&&(t=$p(t,Lg(Dp(this.l1,Qp(e))))),this.hasL2&&(t=$p(t,Lg(Dp(this.l2,Vk(e))))),Jf(t,[])}))}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}RC.className="L1L2",Up(RC);const AC={l1l2:"L1L2"};function DC(e){return qw(e)}function FC(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Qw(e,Vp.getMap().classNameMap,t,"regularizer")}function MC(e){if(null==e)return null;if("string"===typeof e){return FC({className:e in AC?AC[e]:e,config:{}})}return e instanceof $C?e:FC(e)}class OC extends ES{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,t){e=bS(e);let n=mm(e);return null!=this.maxValue&&(n=og(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}OC.className="ReLU",Up(OC);class LC extends ES{constructor(e){super(null==e?{}:e),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=bS(e);return Dg(n,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}LC.className="LeakyReLU",Up(LC);class PC extends ES{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=fS(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=MC(e.alphaRegularizer),this.alphaConstraint=qS(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!==typeof e.sharedAxes)throw new Lw(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`);this.sharedAxes=[e.sharedAxes]}}build(e){const t=(e=xS(e)).slice(1);if(null!=this.sharedAxes)for(const s of this.sharedAxes)t[s-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const n={};if(null!=this.sharedAxes)for(let s=1;s<e.length;++s)n[s]=e[s];this.inputSpec=[new IS({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=bS(e),um(e,this.alpha.read())}getConfig(){const e={alphaInitializer:pS(this.alphaInitializer),alphaRegularizer:DC(this.alphaRegularizer),alphaConstraint:KS(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}PC.className="PReLU",Up(PC);class zC extends ES{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new Pw(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=bS(e);return kg(n)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}zC.className="ELU",Up(zC);class BC extends ES{constructor(e){super(null==e?{}:e),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=null==e.theta?this.DEFAULT_THETA:e.theta}call(e,t){const n=bS(e);return Dp(n,_p(Rg(n,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}}BC.className="ThresholdedReLU",Up(BC);class WC extends ES{constructor(e){super(null==e?{}:e),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new vC).apply,this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis}call(e,t){return Bd((()=>{let n=bS(e);const s=t.mask;if(null!=s){const e=Dp(qp(am(n.shape),_p(s,n.dtype)),Pp(-1e9));n=$p(n,e)}return this.axis instanceof Array?this.axis.length>1?Cg(qp(n,Kg(n,this.axis,!0))):this.softmax(n,this.axis[0]):this.softmax(n,this.axis)}))}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function VC(e,t,n){if("number"===typeof e)return Ww(e,t);if(e.length!==t)throw new Lw(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${e.length} elements.`);for(let r=0;r<t;++r){const i=e[r];if((s=i)!==parseInt(s.toString(),10))throw new Lw(`The ${n} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(e)} including a non-integer number ${i}`)}return e;var s}function UC(e,t,n,s){if(null==e)return e;let r;return r="same"===n?e:e-(t+(t-1)*((arguments.length>4&&void 0!==arguments[4]?arguments[4]:1)-1))+1,Math.floor((r+s-1)/s)}function GC(e,t,n,s){if(null==e)return null;if("valid"===s)e=e*t+Tk([n-t,0]);else{if("same"!==s)throw new Lw(`Unsupport padding mode: ${s}.`);e*=t}return e}function HC(e,t){return Bd((()=>(mk(t),"channelsFirst"===t?zm(e,[0,2,3,1]):e)))}function jC(e,t){return Bd((()=>(mk(t),"channelsFirst"===t?zm(e,[0,2,3,4,1]):e)))}function KC(e,t,n){let s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",i=arguments.length>5?arguments[5]:void 0,a=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1;return Bd((()=>{if(null==i&&(i="channelsLast"),mk(i),3!==e.shape.length)throw new Lw(`The input of a conv1dWithBias operation should be 3, but is ${e.shape.length} instead.`);if(3!==t.shape.length)throw new Lw(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(null!=n&&1!==n.shape.length)throw new Lw(`The bias for a conv1dWithBias operation should be 1, but is ${n.shape.length} instead`);if("channelsFirst"===i&&(e=zm(e,[0,2,1])),"causal"===r)throw new Pw("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=fg(e,t,s,"same"===r?"same":"valid","NWC",a);return null!=n&&(o=Gk(o,n)),o}))}function XC(e,t,n){let s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1],r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",i=arguments.length>5?arguments[5]:void 0,a=arguments.length>6?arguments[6]:void 0,o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null;return Bd((()=>{if(null==i&&(i="channelsLast"),mk(i),3!==e.rank&&4!==e.rank)throw new Lw(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${e.rank}.`);if(3!==t.rank&&4!==t.rank)throw new Lw(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${e.rank}.`);let l=HC(e,i);if("causal"===r)throw new Pw("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=Zm({x:l,filter:t,strides:s,pad:"same"===r?"same":"valid",dilations:a,dataFormat:"NHWC",bias:n,activation:o}),"channelsFirst"===i&&(l=zm(l,[0,3,1,2])),l}))}function qC(e,t,n){let s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1,1],r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",i=arguments.length>5?arguments[5]:void 0,a=arguments.length>6?arguments[6]:void 0;return Bd((()=>{if(null==i&&(i="channelsLast"),mk(i),4!==e.rank&&5!==e.rank)throw new Lw(`conv3dWithBias expects input to be of rank 4 or 5, but received ${e.rank}.`);if(4!==t.rank&&5!==t.rank)throw new Lw(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${e.rank}.`);let o=jC(e,i);if("causal"===r)throw new Pw("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=bg(o,t,s,"same"===r?"same":"valid","NDHWC",a),null!=n&&(o=Gk(o,n)),"channelsFirst"===i&&(o=zm(o,[0,4,1,2,3])),o}))}WC.className="Softmax",Up(WC);class YC extends ES{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",YC.verifyArgs(t),this.rank=e,sk(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new Pw(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=VC(t.kernelSize,e,"kernelSize"),this.strides=VC(null==t.strides?1:t.strides,e,"strides"),this.padding=null==t.padding?"valid":t.padding,bk(this.padding),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,mk(this.dataFormat),this.activation=_C(t.activation),this.useBias=null==t.useBias||t.useBias,this.biasInitializer=fS(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=qS(t.biasConstraint),this.biasRegularizer=MC(t.biasRegularizer),this.activityRegularizer=MC(t.activityRegularizer),this.dilationRate=VC(null==t.dilationRate?1:t.dilationRate,e,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new Lw(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(2===this.rank){if("number"===typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new Lw(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(3===this.rank)if("number"===typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new Lw(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}static verifyArgs(e){if(Vw("kernelSize"in e,"required key 'kernelSize' not in config"),"number"!==typeof e.kernelSize&&!nk(e.kernelSize,"number",1,3))throw new Lw(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:NC(this.activation),useBias:this.useBias,biasInitializer:pS(this.biasInitializer),biasRegularizer:DC(this.biasRegularizer),activityRegularizer:DC(this.activityRegularizer),biasConstraint:KS(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}class QC extends YC{constructor(e,t){super(e,t),this.kernel=null,QC.verifyArgs(t),this.filters=t.filters,sk(this.filters,"filters"),this.kernelInitializer=fS(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=qS(t.kernelConstraint),this.kernelRegularizer=MC(t.kernelRegularizer)}build(e){e=xS(e);const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new Lw(`The channel dimension of the input should be defined. Found ${e[t]}`);const n=e[t],s=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:n}}],this.built=!0}call(e,t){return Bd((()=>{let t;e=bS(e);const n=null==this.bias?null:this.bias.read(),s=ik(this.activation.getClassName());if(null!=s&&2===this.rank)t=XC(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,s);else{if(1===this.rank)t=KC(e,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)t=XC(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new Pw("convolutions greater than 3D are not implemented yet.");t=qC(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(t=this.activation.apply(t))}return t}))}computeOutputShape(e){e=xS(e);const t=[],n="channelsLast"===this.dataFormat?e.slice(1,e.length-1):e.slice(2);for(let r=0;r<n.length;++r){const e=UC(n[r],this.kernelSize[r],this.padding,this.strides[r],"number"===typeof this.dilationRate?this.dilationRate:this.dilationRate[r]);t.push(e)}let s=[e[0]];return"channelsLast"===this.dataFormat?(s=s.concat(t),s.push(this.filters)):(s.push(this.filters),s=s.concat(t)),s}getConfig(){const e={filters:this.filters,kernelInitializer:pS(this.kernelInitializer),kernelRegularizer:DC(this.kernelRegularizer),kernelConstraint:KS(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||"number"!==typeof e.filters||e.filters<1)throw new Lw(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}}class ZC extends QC{constructor(e){super(2,e),ZC.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!==typeof e.kernelSize&&!nk(e.kernelSize,"number",1,2))throw new Lw(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}ZC.className="Conv2D",Up(ZC);class JC extends QC{constructor(e){super(3,e),JC.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!==typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new Lw(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}JC.className="Conv3D",Up(JC);class eN extends ZC{constructor(e){if(super(e),this.inputSpec=[new IS({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new Lw(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(4!==(e=xS(e)).length)throw new Lw("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new Lw("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],s=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new IS({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return Bd((()=>{let t=bS(e);if(4!==t.shape.length)throw new Lw(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);const n=t.shape,s=n[0];let r,i;"channelsFirst"===this.dataFormat?(r=2,i=3):(r=1,i=2);const a=n[r],o=n[i],l=this.kernelSize[0],u=this.kernelSize[1],c=this.strides[0],h=this.strides[1],d=[s,GC(a,c,l,this.padding),GC(o,h,u,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=zm(t,[0,2,3,1]));let p=mg(t,this.kernel.read(),d,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(p=zm(p,[0,3,1,2])),null!=this.bias&&(p=Gk(p,this.bias.read(),this.dataFormat)),null!=this.activation&&(p=this.activation.apply(p)),p}))}computeOutputShape(e){const t=(e=xS(e)).slice();let n,s,r;"channelsFirst"===this.dataFormat?(n=1,s=2,r=3):(n=3,s=1,r=2);const i=this.kernelSize[0],a=this.kernelSize[1],o=this.strides[0],l=this.strides[1];return t[n]=this.filters,t[s]=GC(t[s],o,i,this.padding),t[r]=GC(t[r],l,a,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}eN.className="Conv2DTranspose",Up(eN);class tN extends JC{constructor(e){if(super(e),this.inputSpec=[new IS({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new Lw(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(5!==(e=xS(e)).length)throw new Lw("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new Lw("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],s=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new IS({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return Bd((()=>{let t=bS(e);if(5!==t.shape.length)throw new Lw(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${t.shape.length}`);const n=t.shape,s=n[0];let r,i,a;"channelsFirst"===this.dataFormat?(a=2,r=3,i=4):(a=1,r=2,i=3);const o=n[a],l=n[r],u=n[i],c=this.kernelSize[0],h=this.kernelSize[1],d=this.kernelSize[2],p=this.strides[0],f=this.strides[1],g=this.strides[2],m=[s,GC(o,p,c,this.padding),GC(l,f,h,this.padding),GC(u,g,d,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=zm(t,[0,2,3,4,1]));let b=yg(t,this.kernel.read(),m,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(b=zm(b,[0,4,1,2,3])),null!==this.bias&&(b=Gk(b,this.bias.read(),this.dataFormat)),null!==this.activation&&(b=this.activation.apply(b)),b}))}computeOutputShape(e){const t=(e=xS(e)).slice();let n,s,r,i;"channelsFirst"===this.dataFormat?(n=1,s=2,r=3,i=4):(n=4,s=1,r=2,i=3);const a=this.kernelSize[0],o=this.kernelSize[1],l=this.kernelSize[2],u=this.strides[0],c=this.strides[1],h=this.strides[2];return t[n]=this.filters,t[s]=GC(t[s],u,a,this.padding),t[r]=GC(t[r],c,o,this.padding),t[i]=GC(t[i],h,l,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}tN.className="Conv3DTranspose",Up(tN);class nN extends QC{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==t.filters)throw new Lw("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=t.kernelInitializer||null!=t.kernelRegularizer||null!=t.kernelConstraint)throw new Lw("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=t.padding&&"same"!==t.padding&&"valid"!==t.padding)throw new Lw(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=fS(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=MC(t.depthwiseRegularizer),this.depthwiseConstraint=qS(t.depthwiseConstraint),this.pointwiseInitializer=fS(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=MC(t.pointwiseRegularizer),this.pointwiseConstraint=qS(t.pointwiseConstraint)}build(e){if((e=xS(e)).length<this.rank+2)throw new Lw(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t]||e[t]<0)throw new Lw(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);const n=e[t],s=this.kernelSize.concat([n,this.depthMultiplier]),r=[];for(let a=0;a<this.rank;++a)r.push(1);r.push(n*this.depthMultiplier,this.filters);const i=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",s,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,i,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",r,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,i,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,i,this.biasConstraint):this.bias=null,this.inputSpec=[new IS({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return Bd((()=>{let t;if(e=bS(e),1===this.rank)throw new Pw("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=zm(e,[0,2,3,1])),t=ym(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(t=Gk(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),"channelsFirst"===this.dataFormat&&(t=zm(t,[0,3,1,2])),t}))}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=pS(this.depthwiseInitializer),e.pointwiseInitializer=pS(this.pointwiseInitializer),e.depthwiseRegularizer=DC(this.depthwiseRegularizer),e.pointwiseRegularizer=DC(this.pointwiseRegularizer),e.depthwiseConstraint=KS(this.depthwiseConstraint),e.pointwiseConstraint=KS(this.pointwiseConstraint),e}}nN.className="SeparableConv";class sN extends nN{constructor(e){super(2,e)}}sN.className="SeparableConv2D",Up(sN);class rN extends QC{constructor(e){super(1,e),rN.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!==typeof e.kernelSize&&!nk(e.kernelSize,"number",1,1))throw new Lw(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}rN.className="Conv1D",Up(rN);class iN extends ES{constructor(e){super(e),"number"===typeof e.cropping?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"===typeof e.cropping[0]?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return Bd((()=>{if(e=bS(e),"channelsLast"===this.dataFormat){const t=Mk(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Mk(t,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const t=Mk(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Mk(t,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}}))}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}iN.className="Cropping2D",Up(iN);class aN extends ES{constructor(e){var t;super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==e.size?this.DEFAULT_SIZE:e.size,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,mk(this.dataFormat),this.interpolation=null==e.interpolation?"nearest":e.interpolation,t=this.interpolation,tk(hk,"InterpolationFormat",t)}computeOutputShape(e){if("channelsFirst"===this.dataFormat){const t=null==e[2]?null:this.size[0]*e[2],n=null==e[3]?null:this.size[1]*e[3];return[e[0],e[1],t,n]}{const t=null==e[1]?null:this.size[0]*e[1],n=null==e[2]?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return Bd((()=>{let t=bS(e);const n=t.shape;if("channelsFirst"===this.dataFormat){t=zm(t,[0,2,3,1]);const e=this.size[0]*n[2],s=this.size[1]*n[3],r="nearest"===this.interpolation?Bb.resizeNearestNeighbor(t,[e,s]):Bb.resizeBilinear(t,[e,s]);return zm(r,[0,3,1,2])}{const e=this.size[0]*n[1],s=this.size[1]*n[2];return"nearest"===this.interpolation?Bb.resizeNearestNeighbor(t,[e,s]):Bb.resizeBilinear(t,[e,s])}}))}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}}aN.className="UpSampling2D",Up(aN);class oN extends YC{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=fS(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=qS(e.depthwiseConstraint),this.depthwiseRegularizer=MC(e.depthwiseRegularizer)}build(e){if((e=xS(e)).length<4)throw new Lw(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const t="channelsFirst"===this.dataFormat?1:3;if(null==e[t]||e[t]<0)throw new Lw(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);const n=e[t],s=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",s,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return Bd((()=>{let t=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[1,1],s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"valid",r=arguments.length>4?arguments[4]:void 0,i=arguments.length>5?arguments[5]:void 0;return Bd((()=>{null==r&&(r="channelsLast"),mk(r);let a=HC(e,r);if(4!==e.rank)throw new Lw(`Input for depthwiseConv2d is required to be 4-D, but is instead ${e.rank}-D`);if(4!==t.rank)throw new Lw(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return a=wg(a,t,n,"same"===s?"same":"valid","NHWC",i),"channelsFirst"===r&&(a=zm(a,[0,3,1,2])),a}))}(e=bS(e),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(t=Gk(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),t}))}computeOutputShape(e){e=xS(e);const t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],s="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,r=UC(t,this.kernelSize[0],this.padding,this.strides[0]),i=UC(n,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],s,r,i]:[e[0],r,i,s]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=pS(this.depthwiseInitializer),e.depthwiseRegularizer=DC(this.depthwiseRegularizer),e.depthwiseConstraint=KS(this.depthwiseRegularizer),e}}function lN(e,t,n,s){if(Array.isArray(e)){if(null!=t||null!=n)throw new Lw("When inputs is an array, neither initialState or constants should be provided");null!=s&&(n=e.slice(e.length-s,e.length),e=e.slice(0,e.length-s)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function r(e){return null==e||Array.isArray(e)?e:[e]}return{inputs:e,initialState:t=r(t),constants:n=r(n)}}function uN(e,t,n){let s=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4?arguments[4]:void 0,i=arguments.length>5?arguments[5]:void 0,a=arguments.length>6&&void 0!==arguments[6]&&arguments[6],o=arguments.length>7&&void 0!==arguments[7]&&arguments[7];return Bd((()=>{const l=t.shape.length;if(l<3)throw new Lw(`Input should be at least 3D, but is ${l}D.`);const u=[1,0].concat(_k(2,l));if(t=zm(t,u),null!=i)throw new Pw("The rnn() functoin of the deeplearn.js backend does not support constants yet.");a&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=r&&(r=_p(_p(r,"bool"),"float32"),r.rank===l-1&&(r=Ng(r,-1)),r=zm(r,u)),s&&(t=bm(t,0),null!=r&&(r=bm(r,0)));const c=[];let h,d=n;const p=t.shape[0],f=Mm(t);let g,m;null!=r&&(g=Mm(r));for(let t=0;t<p;++t){const n=f[t],s=Bd((()=>e(n,d)));if(null==r)h=s[0],d=s[1];else{const e=Bd((()=>{const e=g[t],n=qp(om(e),e);return{output:$p(Dp(s[0],e),Dp(d[0],n)),newStates:d.map(((t,r)=>$p(Dp(s[1][r],e),Dp(t,n))))}}));h=e.output,d=e.newStates}o&&c.push(h)}if(o){m=$m(c,1)}return[h,m,d]}))}oN.className="DepthwiseConv2D",Up(oN);class cN extends ES{constructor(e){let t;if(super(e),null==e.cell)throw new Lw("cell property is missing for the constructor of RNN.");if(t=Array.isArray(e.cell)?new xN({cells:e.cell}):e.cell,null==t.stateSize)throw new Lw("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=null!=e.returnSequences&&e.returnSequences,this.returnState=null!=e.returnState&&e.returnState,this.goBackwards=null!=e.goBackwards&&e.goBackwards,this._stateful=null!=e.stateful&&e.stateful,this.unroll=null!=e.unroll&&e.unroll,this.supportsMasking=!0,this.inputSpec=[new IS({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(null==this.states_){return _k(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map((e=>null))}return this.states_}setStates(e){this.states_=e}computeOutputShape(e){gS(e)&&(e=e[0]);let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const n=t[0];let s;if(s=this.returnSequences?[e[0],e[1],n]:[e[0],n],this.returnState){const n=[];for(const s of t)n.push([e[0],s]);return[s].concat(n)}return s}computeMask(e,t){return Bd((()=>{Array.isArray(t)&&(t=t[0]);const e=this.returnSequences?t:null;if(this.returnState){const t=this.states.map((e=>null));return[e].concat(t)}return e}))}get states(){if(null==this.states_){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let n=0;n<e;++n)t.push(null);return t}return this.states_}set states(e){this.states_=e}build(e){if(null!=this.numConstants)throw new Pw("Constants support is not implemented in RNN yet.");gS(e)&&(e=e[0]);const t=this.stateful?e[0]:null,n=e.slice(2);this.inputSpec[0]=new IS({shape:[t,null,...n]});const s=[e[0]].concat(e.slice(2));let r;if(this.cell.build(s),r=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!yo(this.stateSpec.map((e=>e.shape[e.shape.length-1])),r))throw new Lw(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=r.map((e=>new IS({shape:[null,e]})));this.stateful&&this.resetStates()}resetStates(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];Bd((()=>{if(!this.stateful)throw new Mw("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape[0];if(null==n)throw new Lw("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>im([n,e]))):this.states_=[im([n,this.cell.stateSize])];else if(null==e)Wd(this.states_),null!=this.keptStates&&(Wd(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>im([n,e]))):this.states_[0]=im([n,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new Lw(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);!0===t?this.keptStates.push(this.states_.slice()):Wd(this.states_);for(let t=0;t<this.states_.length;++t){const s=e[t],r=Array.isArray(this.cell.stateSize)?this.cell.stateSize[t]:this.cell.stateSize,i=[n,r];if(!yo(s.shape,i))throw new Lw(`State ${t} is incompatible with layer ${this.name}: expected shape=${i}, received shape=${s.shape}`);this.states_[t]=s}}this.states_=this.states_.map((e=>Vd(e.clone())))}))}apply(e,t){let n=null==t?null:t.initialState,s=null==t?null:t.constants;null==t&&(t={});const r=lN(e,n,s,this.numConstants);e=r.inputs,n=r.initialState,s=r.constants;let i=[],a=[];if(null!=n){t.initialState=n,i=i.concat(n),this.stateSpec=[];for(const e of n)this.stateSpec.push(new IS({shape:e.shape}));a=a.concat(this.stateSpec)}null!=s&&(t.constants=s,i=i.concat(s),this.numConstants=s.length);if(i[0]instanceof CS){const n=[e].concat(i),s=this.inputSpec.concat(a),r=this.inputSpec;this.inputSpec=s;const o=super.apply(n,t);return this.inputSpec=r,o}return super.apply(e,t)}call(e,t){return Bd((()=>{const n=null==t?null:t.mask,s=null==t?null:t.training;let r=null==t?null:t.initialState;e=bS(e),null==r&&(r=this.stateful?this.states_:this.getInitialState(e));const i=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(r.length!==i)throw new Lw(`RNN Layer has ${i} state(s) but was passed ${r.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const a={training:s},o=uN(((e,t)=>{const n=this.cell.call([e].concat(t),a);return[n[0],n.slice(1)]}),e,r,this.goBackwards,n,null,this.unroll,this.returnSequences),l=o[0],u=o[1],c=o[2];this.stateful&&this.resetStates(c,s);const h=this.returnSequences?u:l;return this.returnState?[h].concat(c):h}))}getInitialState(e){return Bd((()=>{let t=im(e.shape);return t=Lg(t,[1,2]),t=Ak(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map((e=>e>1?Pk(t,[1,e]):t)):this.cell.stateSize>1?[Pk(t,[1,this.cell.stateSize])]:[t]}))}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(t.numConstants=this.numConstants);const n=this.cell.getConfig();return this.getClassName()===cN.className&&(t.cell={className:this.cell.getClassName(),config:n}),Object.assign(Object.assign(Object.assign({},n),e),t)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const s=oI(t.cell,n);return new e(Object.assign(t,{cell:s}))}}cN.className="RNN",Up(cN);class hN extends ES{}class dN extends hN{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,sk(this.units,"units"),this.activation=_C(null==e.activation?this.DEFAULT_ACTIVATION:e.activation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=fS(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=fS(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=fS(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=MC(e.kernelRegularizer),this.recurrentRegularizer=MC(e.recurrentRegularizer),this.biasRegularizer=MC(e.biasRegularizer),this.kernelConstraint=qS(e.kernelConstraint),this.recurrentConstraint=qS(e.recurrentConstraint),this.biasConstraint=qS(e.biasConstraint),this.dropout=Nk([1,Tk([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=Nk([1,Tk([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=xS(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return Bd((()=>{if(2!==e.length)throw new Lw(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let n=e[1];e=e[0];const s=null!=t.training&&t.training;let r;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=yN({ones:()=>om(e),rate:this.dropout,training:s,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=yN({ones:()=>om(n),rate:this.recurrentDropout,training:s,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,a=this.recurrentDropoutMask;r=Bk(null!=i?Dp(e,i):e,this.kernel.read()),null!=this.bias&&(r=Gk(r,this.bias.read())),null!=a&&(n=Dp(n,a));let o=$p(r,Bk(n,this.recurrentKernel.read()));return null!=this.activation&&(o=this.activation.apply(o)),[o,o]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:NC(this.activation),useBias:this.useBias,kernelInitializer:pS(this.kernelInitializer),recurrentInitializer:pS(this.recurrentInitializer),biasInitializer:pS(this.biasInitializer),kernelRegularizer:DC(this.kernelRegularizer),recurrentRegularizer:DC(this.recurrentRegularizer),biasRegularizer:DC(this.biasRegularizer),activityRegularizer:DC(this.activityRegularizer),kernelConstraint:KS(this.kernelConstraint),recurrentConstraint:KS(this.recurrentConstraint),biasConstraint:KS(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}}dN.className="SimpleRNNCell",Up(dN);class pN extends cN{constructor(e){e.cell=new dN(e),super(e)}call(e,t){return Bd((()=>{null!=this.cell.dropoutMask&&(Wd(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Wd(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,s=null==t?null:t.training,r=null==t?null:t.initialState;return super.call(e,{mask:n,training:s,initialState:r})}))}static fromConfig(e,t){return new e(t)}}pN.className="SimpleRNN",Up(pN);class fN extends hN{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new Lw("GRUCell does not support reset_after parameter set to true.");this.units=e.units,sk(this.units,"units"),this.activation=_C(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=_C(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=fS(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=fS(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=fS(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=MC(e.kernelRegularizer),this.recurrentRegularizer=MC(e.recurrentRegularizer),this.biasRegularizer=MC(e.biasRegularizer),this.kernelConstraint=qS(e.kernelConstraint),this.recurrentConstraint=qS(e.recurrentConstraint),this.biasConstraint=qS(e.biasConstraint),this.dropout=Nk([1,Tk([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=Nk([1,Tk([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){const t=(e=xS(e))[e.length-1];this.kernel=this.addWeight("kernel",[t,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return Bd((()=>{if(2!==e.length)throw new Lw(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const n=null!=t.training&&t.training;let s=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=yN({ones:()=>om(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=yN({ones:()=>om(s),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));const r=this.dropoutMask,i=this.recurrentDropoutMask;let a,o,l;0<this.dropout&&this.dropout<1&&(e=Dp(e,r[0]));let u=Bk(e,this.kernel.read());this.useBias&&(u=Gk(u,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(s=Dp(s,i[0]));const c=this.recurrentKernel.read(),[h,d]=_m(c,[2*this.units,this.units],c.rank-1),p=Bk(s,h),[f,g,m]=_m(u,3,u.rank-1),[b,x]=_m(p,2,p.rank-1);a=this.recurrentActivation.apply($p(f,b)),o=this.recurrentActivation.apply($p(g,x));const y=Bk(Dp(o,s),d);l=this.activation.apply($p(m,y));const v=$p(Dp(a,s),Dp($p(1,nm(a)),l));return[v,v]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:NC(this.activation),recurrentActivation:NC(this.recurrentActivation),useBias:this.useBias,kernelInitializer:pS(this.kernelInitializer),recurrentInitializer:pS(this.recurrentInitializer),biasInitializer:pS(this.biasInitializer),kernelRegularizer:DC(this.kernelRegularizer),recurrentRegularizer:DC(this.recurrentRegularizer),biasRegularizer:DC(this.biasRegularizer),activityRegularizer:DC(this.activityRegularizer),kernelConstraint:KS(this.kernelConstraint),recurrentConstraint:KS(this.recurrentConstraint),biasConstraint:KS(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}}fN.className="GRUCell",Up(fN);class gN extends cN{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new fN(e),super(e)}call(e,t){return Bd((()=>{null!=this.cell.dropoutMask&&(Wd(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Wd(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,s=null==t?null:t.training,r=null==t?null:t.initialState;return super.call(e,{mask:n,training:s,initialState:r})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}gN.className="GRU",Up(gN);class mN extends hN{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,sk(this.units,"units"),this.activation=_C(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=_C(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=fS(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=fS(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=fS(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=MC(e.kernelRegularizer),this.recurrentRegularizer=MC(e.recurrentRegularizer),this.biasRegularizer=MC(e.biasRegularizer),this.kernelConstraint=qS(e.kernelConstraint),this.recurrentConstraint=qS(e.recurrentConstraint),this.biasConstraint=qS(e.biasConstraint),this.dropout=Nk([1,Tk([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=Nk([1,Tk([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;const n=(e=xS(e))[e.length-1];let s;if(this.kernel=this.addWeight("kernel",[n,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const e=this.biasInitializer,n=this.units;s=new((t=class extends qk{apply(t,s){const r=e.apply([n]),i=(new Qk).apply([n]),a=e.apply([2*n]);return Lk(Lk(r,i),a)}}).className="CustomInit",t)}else s=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,s,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return Bd((()=>{const n=null!=t.training&&t.training;if(3!==e.length)throw new Lw(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let s=e[1];const r=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=yN({ones:()=>om(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=yN({ones:()=>om(s),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const i=this.dropoutMask,a=this.recurrentDropoutMask;let o,l,u,c;0<this.dropout&&this.dropout<1&&(e=Dp(e,i[0]));let h=Bk(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(s=Dp(s,a[0])),h=$p(h,Bk(s,this.recurrentKernel.read())),this.useBias&&(h=Gk(h,this.bias.read()));const[d,p,f,g]=_m(h,4,h.rank-1);o=this.recurrentActivation.apply(d),l=this.recurrentActivation.apply(p),u=$p(Dp(l,r),Dp(o,this.activation.apply(f))),c=this.recurrentActivation.apply(g);const m=Dp(c,this.activation.apply(u));return[m,m,u]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:NC(this.activation),recurrentActivation:NC(this.recurrentActivation),useBias:this.useBias,kernelInitializer:pS(this.kernelInitializer),recurrentInitializer:pS(this.recurrentInitializer),biasInitializer:pS(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:DC(this.kernelRegularizer),recurrentRegularizer:DC(this.recurrentRegularizer),biasRegularizer:DC(this.biasRegularizer),activityRegularizer:DC(this.activityRegularizer),kernelConstraint:KS(this.kernelConstraint),recurrentConstraint:KS(this.recurrentConstraint),biasConstraint:KS(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}}mN.className="LSTMCell",Up(mN);class bN extends cN{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new mN(e),super(e)}call(e,t){return Bd((()=>{null!=this.cell.dropoutMask&&(Wd(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Wd(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,s=null==t?null:t.training,r=null==t?null:t.initialState;return super.call(e,{mask:n,training:s,initialState:r})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}bN.className="LSTM",Up(bN);class xN extends hN{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return Bd((()=>{let n=e.slice(1);const s=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?s.push(n.splice(0,e.stateSize.length)):s.push(n.splice(0,1));s.reverse();const r=[];let i;for(let a=0;a<this.cells.length;++a){const o=this.cells[a];n=s[a],i=0===a?[e[0]].concat(n):[i[0]].concat(n),i=o.call(i,t),r.push(i.slice(1))}n=[];for(const e of r.slice().reverse())n.push(...e);return[i[0]].concat(n)}))}build(e){let t;gS(e)&&(e=e[0]),this.cells.forEach(((n,s)=>{vk(`RNNCell_${s}`,(()=>{n.build(e),t=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,e=[e[0],t]}))})),this.built=!0}getConfig(){const e=super.getConfig(),t={cells:this.cells.map((e=>({className:e.getClassName(),config:e.getConfig()})))};return Object.assign(Object.assign({},e),t)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const s=[];for(const r of t.cells)s.push(oI(r,n));return new e({cells:s})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return kS(e)}setWeights(e){const t=[];for(const n of this.cells){const s=n.weights.length,r=e.splice(s);for(let e=0;e<n.weights.length;++e)t.push([n.weights[e],r[e]])}SS(t)}}function yN(e){const{ones:t,rate:n,training:s=!1,count:r=1,dropoutFunc:i}=e,a=()=>null!=i?i(t(),n):Hk(t(),n),o=()=>jk(a,t,s);if(!r||r<=1)return Vd(o().clone());return Array(r).fill(void 0).map(o).map((e=>Vd(e.clone())))}xN.className="StackedRNNCells",Up(xN);var vN=function(e,t){var n={};for(var s in e)Object.prototype.hasOwnProperty.call(e,s)&&t.indexOf(s)<0&&(n[s]=e[s]);if(null!=e&&"function"===typeof Object.getOwnPropertySymbols){var r=0;for(s=Object.getOwnPropertySymbols(e);r<s.length;r++)t.indexOf(s[r])<0&&Object.prototype.propertyIsEnumerable.call(e,s[r])&&(n[s[r]]=e[s[r]])}return n};class wN extends cN{constructor(e){if(e.unroll)throw new Pw("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new Pw("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new IS({ndim:5})]}call(e,t){return Bd((()=>{if(null!=this.cell.dropoutMask&&(Wd(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Wd(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new Lw("ConvRNN2D cell does not support constants");const n=null==t?null:t.mask,s=null==t?null:t.training,r=null==t?null:t.initialState;return super.call(e,{mask:n,training:s,initialState:r})}))}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return Bd((()=>{const{stateSize:t}=this.cell,n=e.shape,s=this.computeSingleOutputShape(n),r=im([s[0],...s.slice(2)]);return Array.isArray(t)?Array(t.length).fill(r):[r]}))}resetStates(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];Bd((()=>{if(!this.stateful)throw new Mw("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape,s=this.computeSingleOutputShape(n),r=[s[0],...s.slice(2)];if(null==n[0])throw new Lw("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>im(r))):this.states_=[im(r)];else if(null==e)Wd(this.states_),null!=this.keptStates&&(Wd(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>im(r))):this.states_[0]=im(r);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new Lw(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):Wd(this.states_);for(let t=0;t<this.states_.length;++t){const n=e[t],s=r;if(!yo(n.shape,s))throw new Lw(`State ${t} is incompatible with layer ${this.name}: expected shape=${s}, received shape=${n.shape}`);this.states_[t]=n}}this.states_=this.states_.map((e=>Vd(e.clone())))}))}computeSingleOutputShape(e){const{dataFormat:t,filters:n,kernelSize:s,padding:r,strides:i,dilationRate:a}=this.cell,o="channelsFirst"===t,l=e[o?3:2],u=e[o?4:3],c=UC(l,s[0],r,i[0],a[0]),h=UC(u,s[1],r,i[1],a[1]);return[...e.slice(0,2),...o?[n,c,h]:[c,h,n]]}}wN.className="ConvRNN2D";class kN extends mN{constructor(e){const{filters:t,kernelSize:n,strides:s,padding:r,dataFormat:i,dilationRate:a}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,sk(this.filters,"filters"),this.kernelSize=VC(n,2,"kernelSize"),this.kernelSize.forEach((e=>sk(e,"kernelSize"))),this.strides=VC(s||1,2,"strides"),this.strides.forEach((e=>sk(e,"strides"))),this.padding=r||"valid",bk(this.padding),this.dataFormat=i||"channelsLast",mk(this.dataFormat),this.dilationRate=VC(a||1,2,"dilationRate"),this.dilationRate.forEach((e=>sk(e,"dilationRate")))}build(e){var t;e=xS(e);const n="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[n])throw new Lw(`The channel dimension of the input should be defined. Found ${e[n]}`);const s=e[n],r=this.kernelSize.concat([s,4*this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const i=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",i,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let e;if(this.unitForgetBias){const n=this.biasInitializer,s=this.filters;e=new((t=class extends qk{apply(e,t){return Ok([n.apply([s]),am([s]),n.apply([2*s])])}}).className="CustomInit",t)}else e=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,e,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return Bd((()=>{if(3!==e.length)throw new Lw(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const n=t.training||!1,s=e[0],r=e[1],i=e[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=yN({ones:()=>om(s),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,o=(e,t,n)=>t&&t[n]?Dp(t[n],e):e;let l=o(s,a,0),u=o(s,a,1),c=o(s,a,2),h=o(s,a,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=yN({ones:()=>om(r),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const d=this.recurrentDropoutMask;let p=o(r,d,0),f=o(r,d,1),g=o(r,d,2),m=o(r,d,3);const[b,x,y,v]=_m(this.kernel.read(),4,3),[w,k,S,I]=this.useBias?_m(this.bias.read(),4):[null,null,null,null];l=this.inputConv(l,b,w,this.padding),u=this.inputConv(u,x,k,this.padding),c=this.inputConv(c,y,S,this.padding),h=this.inputConv(h,v,I,this.padding);const[C,N,T,_]=_m(this.recurrentKernel.read(),4,3);p=this.recurrentConv(p,C),f=this.recurrentConv(f,N),g=this.recurrentConv(g,T),m=this.recurrentConv(m,_);const E=this.recurrentActivation.apply($p(l,p)),$=this.recurrentActivation.apply($p(u,f)),R=$p(Dp($,i),Dp(E,this.activation.apply($p(c,g)))),A=Dp(this.recurrentActivation.apply($p(h,m)),this.activation.apply(R));return[A,A,R]}))}getConfig(){const e=super.getConfig(),{units:t}=e,n=vN(e,["units"]),s={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},n),s)}inputConv(e,t,n,s){const r=pg(e,t,this.strides,s||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return n?Gk(r,n,this.dataFormat):r}recurrentConv(e,t){return pg(e,t,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}kN.className="ConvLSTM2DCell",Up(kN);class SN extends wN{constructor(e){const t=new kN(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}}SN.className="ConvLSTM2D",Up(SN);class IN extends ES{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;const t=e.shape,n=[];for(let s=0;s<this.noiseShape.length;++s)n.push(null==this.noiseShape[s]?t[s]:this.noiseShape[s]);return n}call(e,t){return Bd((()=>{this.invokeCallHook(e,t);const n=bS(e);if(0<this.rate&&this.rate<1){const e=null!=t.training&&t.training,s=this.getNoiseShape(n);return jk((()=>Hk(n,this.rate,s,this.seed)),(()=>n),e)}return e}))}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}}IN.className="Dropout",Up(IN);class CN extends IN{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}}CN.className="SpatialDropout1D",Up(CN);class NN extends ES{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let t=null;null!=e.batchSize&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,sk(this.units,"units"),this.activation=_C(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=fS(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=fS(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=qS(e.kernelConstraint),this.biasConstraint=qS(e.biasConstraint),this.kernelRegularizer=MC(e.kernelRegularizer),this.biasRegularizer=MC(e.biasRegularizer),this.activityRegularizer=MC(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){const t=(e=xS(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){const t=(e=xS(e)).slice();return t[t.length-1]=this.units,t}call(e,t){return Bd((()=>{this.invokeCallHook(e,t);const n=bS(e),s=ik(this.activation.getClassName());let r;return null!=s?r=Bk(n,this.kernel.read(),s,this.bias?this.bias.read():null):(r=Bk(n,this.kernel.read()),null!=this.bias&&(r=Gk(r,this.bias.read())),null!=this.activation&&(r=this.activation.apply(r))),r}))}getConfig(){const e={units:this.units,activation:NC(this.activation),useBias:this.useBias,kernelInitializer:pS(this.kernelInitializer),biasInitializer:pS(this.biasInitializer),kernelRegularizer:DC(this.kernelRegularizer),biasRegularizer:DC(this.biasRegularizer),activityRegularizer:DC(this.activityRegularizer),kernelConstraint:KS(this.kernelConstraint),biasConstraint:KS(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}NN.className="Dense",Up(NN);class TN extends ES{constructor(e){super(e=e||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=xS(e);for(const t of e.slice(1))if(null==t)throw new Lw(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],Ck(e,1)]}call(e,t){return Bd((()=>{this.invokeCallHook(e,t);let n=bS(e);if("channelsFirst"===this.dataFormat&&n.rank>1){const e=[0];for(let t=2;t<n.rank;++t)e.push(t);e.push(1),n=zm(n,e)}return function(e){if(e.rank<=1)throw new Lw(`batchFlatten requires a minimum rank of 2. Got rank: ${e.rank}.`);const t=[e.shape[0],Ck(e.shape,1)];return Jf(e,t)}(n)}))}getConfig(){const e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}}TN.className="Flatten",Up(TN);class _N extends ES{constructor(e){super(e),this.supportsMasking=!0,this.activation=_C(e.activation)}call(e,t){return Bd((()=>{this.invokeCallHook(e,t);const n=bS(e);return this.activation.apply(n)}))}getConfig(){const e={activation:NC(this.activation)},t=super.getConfig();return Object.assign(e,t),e}}_N.className="Activation",Up(_N);class EN extends ES{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return Bd((()=>{return e=bS(e),t=e,n=this.n,Bd((()=>{if(2!==t.shape.length)throw new Lw(`repeat() expects a rank-2 tensor, but received a rank-${t.shape.length} tensor.`);return Pk(Ak(t,1),[1,n,1])}));var t,n}))}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}}EN.className="RepeatVector",Up(EN);class $N extends ES{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,t){const n="Total size of new array must be unchanged.",s=t.slice();let r=1,i=null;for(let o=0;o<s.length;++o){const e=s[o];if(this.isUnknown(e)){if(null!==i)throw new Lw("Can only specifiy one unknown dimension.");i=o}else r*=e}const a=Ck(e);if(null!==i){if(0===r||a%r!==0)throw new Lw(n);s[i]=a/r}else if(a!==r)throw new Lw(n);return s}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return Bd((()=>{this.invokeCallHook(e,t);const n=bS(e),s=n.shape,r=s.slice(0,1).concat(this.fixUnknownDimension(s.slice(1),this.targetShape));return Jf(n,r)}))}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}}$N.className="Reshape",Up($N);class RN extends ES{constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const t=_k(1,e.dims.length+1);if(!yo(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new IS({ndim:this.dims.length+1})]}computeOutputShape(e){const t=(e=xS(e)).slice();return this.dims.forEach(((n,s)=>{t[s+1]=e[n]})),t}call(e,t){return zm(bS(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}}RN.className="Permute",Up(RN);class AN extends ES{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,this.maskValue=null!=e?null==e.maskValue?0:e.maskValue:0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const n=bS(e);return Of(sm(n,this.maskValue),-1)}call(e,t){return Bd((()=>{this.invokeCallHook(e,t);const n=bS(e),s=Of(sm(n,this.maskValue),-1,!0);return Dp(n,_p(s,n.dtype))}))}}AN.className="Masking",Up(AN);class DN extends ES{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let t=null;null!=e.batchSize&&(t=e.batchSize),null==e.inputLength?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(Hw(e.inputLength))}this.inputDim=e.inputDim,sk(this.inputDim,"inputDim"),this.outputDim=e.outputDim,sk(this.outputDim,"outputDim"),this.embeddingsInitializer=fS(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=MC(e.embeddingsRegularizer),this.activityRegularizer=MC(e.activityRegularizer),this.embeddingsConstraint=qS(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return Bd((()=>this.maskZero?(e=bS(e),sm(e,Op(e))):null))}computeOutputShape(e){if(e=xS(e),null==this.inputLength)return[...e,this.outputDim];const t=Hw(this.inputLength);if(t.length!==e.length-1)throw new Lw(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let n=0;for(let s=0;s<t.length;++s){const r=t[s],i=e[s+1];if(null!=r&&null!=i&&r!==i)throw new Lw(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);null==r&&(t[n]=i),n++}}return[e[0],...t,this.outputDim]}call(e,t){return Bd((()=>{this.invokeCallHook(e,t);let n=bS(e);"int32"!==n.dtype&&(n=Rk(n,"int32"));const s=Wk(this.embeddings.read(),Jf(n,[n.size]));return Jf(s,xS(this.computeOutputShape(n.shape)))}))}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:pS(this.embeddingsInitializer),embeddingsRegularizer:DC(this.embeddingsRegularizer),activityRegularizer:DC(this.activityRegularizer),embeddingsConstraint:KS(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}}DN.className="Embedding",Up(DN);class FN extends ES{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new Pw}computeElementwiseOpOutputShape(e,t){if(null==e||null==t)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(0===t.length)return e;const n=e.slice(0,e.length-t.length);for(let s=0;s<t.length;++s){const r=e[e.length-t.length+s],i=t[s];if(null==r||null==i||r<0||i<0)n.push(null);else if(1===r)n.push(i);else if(1===i)n.push(r);else{if(r!==i)throw new Lw("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(r)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[xS(e)]),e.length<2)throw new Lw(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(const r of e)null!=r&&null!==r[0]&&t.push(r[0]);if(t=Jw(t),t.length>1)throw new Lw(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let n=null==e[0]?null:e[0].slice(1);for(let r=1;r<e.length;++r){const t=null==e[r]?null:e[r].slice(1);n=this.computeElementwiseOpOutputShape(n,t)}const s=e.map((e=>e.length));-1===e.indexOf(null)&&1===Jw(s).length?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return Bd((()=>{if(this.reshapeRequired){const t=[],n=e.map((e=>e.rank));if(-1===n.indexOf(null)){const s=Tk(n);for(let n of e){const e=n.rank;for(let t=0;t<s-e;++t)n=Ak(n,1);t.push(n)}return this.mergeFunction(t)}{let n=!1;for(const i of e){const e=i.rank;if(null==e){const e=i.shape,s=e[0],r=e.slice(1).concat([s]);let a=Jf(i,[s].concat(Ck(e.slice(1))));a=zm(a,[1,0]),a=Jf(a,r),t.push(a),n=!0}else if(e>1){const s=_k(1,e).concat([0]);t.push(zm(i,s)),n=!0}else t.push(i)}let s=this.mergeFunction(t);const r=s.rank;if(n)if(null==r){const e=s.shape,t=e[e.length-1],n=[t].concat(e.slice(0,e.length-1));s=Jf(zm(Jf(s,[-1,t]),[1,0]),n)}else if(r>1){const e=[r-1].concat(_k(0,r-1));s=zm(s,e)}return s}}return this.mergeFunction(e)}))}computeOutputShape(e){let t;t=null==e[0]?null:e[0].slice(1);for(let s=1;s<e.length;++s){const n=null==e[s]?null:e[s].slice(1);t=this.computeElementwiseOpOutputShape(t,n)}let n=[];for(const s of e)null!=s&&null!==s[0]&&n.push(s[0]);return n=Jw(n),t=1===n.length?n.concat(t):[null].concat(t),t}computeMask(e,t){return Bd((()=>{if(null==t)return null;if(!Array.isArray(t))throw new Lw("`mask` should be an Array");if(!Array.isArray(e))throw new Lw("`inputs` should be an Array");if(t.length!==e.length)throw new Lw(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every((e=>null==e)))return null;let n=(t=t.map((e=>null==e?e:Ng(e,0))))[0];for(let e=1;e<t.length-1;++e)n=Xg(n,t[e]);return n}))}}class MN extends FN{constructor(e){super(e)}mergeFunction(e){return Bd((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=$p(t,e[n]);return t}))}}MN.className="Add",Up(MN);class ON extends FN{constructor(e){super(e)}mergeFunction(e){return Bd((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=Dp(t,e[n]);return t}))}}ON.className="Multiply",Up(ON);class LN extends FN{constructor(e){super(e)}mergeFunction(e){return Bd((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=$p(t,e[n]);return Dp(1/e.length,t)}))}}LN.className="Average",Up(LN);class PN extends FN{constructor(e){super(e)}mergeFunction(e){return Bd((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=tf(t,e[n]);return t}))}}PN.className="Maximum",Up(PN);class zN extends FN{constructor(e){super(e)}mergeFunction(e){return Bd((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=em(t,e[n]);return t}))}}zN.className="Minimum",Up(zN);class BN extends FN{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new Lw("A `Concatenate` layer should be called on a list of at least 2 inputs");let t=!0;for(const s of e)if(null!=s){t=!1;break}if(t)return;const n=[];for(let s=0;s<e.length;++s){const t=e[s].slice();t.splice(this.axis,1);let r=!1;for(const e of n)if(yo(e,t)){r=!0;break}r||n.push(t)}if(n.length>1)throw new Lw("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return Bd((()=>Ok(e,this.axis)))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new Lw("A `Concatenate` layer should be called on a list of inputs.");const t=e,n=t[0].slice(),s=this.axis<0?n.length+this.axis:this.axis;for(const r of t.slice(1)){if(null==n[s]||null==r[s]){n[s]=null;break}n[s]+=r[s]}return n}computeMask(e,t){if(null==t)return null;if(!Array.isArray(t))throw new Lw("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new Lw("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new Lw(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return Bd((()=>{let n=!0;if(t.forEach((e=>{null==e||(n=!1)})),n)return null;const s=[];for(let i=0;i<e.length;++i)null==t[i]?s.push(_p(om(e[i]),"bool")):t[i].rank<e[i].rank?s.push(Ng(t[i],-1)):s.push(t[i]);const r=lg(s,this.axis);return Mf(r,-1,!1)}))}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function WN(e,t){for(;e<0;)e+=t;return e}BN.className="Concatenate",Up(BN);class VN extends FN{constructor(e){super(e),this.axes=e.axes,this.normalize=null!=e.normalize&&e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){go(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const t=e[0],n=e[1];if(t.length>3||n.length>3)throw new Pw("Dot layer does not support tensors of 4D or higher rank yet.");const s=this.interpretAxes(t,n);if(t[s[0]]!==n[s[1]])throw new Lw(`Dimension incompatibility: ${t[s[0]]} !== ${n[s[1]]}`)}mergeFunction(e){if(2!==e.length)throw new Lw(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t,n=e[0],s=e[1];return t=Array.isArray(this.axes)?this.axes.map(((t,n)=>WN(t,e[n].shape.length))):[WN(this.axes,n.shape.length),WN(this.axes,s.shape.length)],this.normalize&&(n=lI(n,t[0]),s=lI(s,t[1])),function(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new Pw("batchDot is not implemented for tensors of 4D or higher rank yet");if(go(e.shape.length>=2,(()=>`batchDot requires the rank of x to be >= 2, but got ${e.shape.length}`)),go(e.shape.length>=2,(()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`)),"number"===typeof n&&(n=[n,n]),"complex64"===e.dtype||"complex64"===t.dtype)throw new Pw("batchDot is not implemented for complex64-type Tensors yet.");const s=e.shape.length,r=t.shape.length;null==n&&(n=[s-1,r-2]);const i=n;return Bd((()=>{let n,a;if(s>r){n=s-r;const e=[];for(let t=0;t<n;++t)e.push(1);t=Jf(t,t.shape.concat(e))}else if(r>s){n=r-s;const t=[];for(let e=0;e<n;++e)t.push(1);e=Jf(e,e.shape.concat(t))}else n=0;if(2===e.shape.length&&2===t.shape.length)a=i[0]===i[1]?Lg(Dp(e,t),i[0]):Lg(Dp(zm(e,[1,0]),t),i[1]);else{const n=i[0]!==e.shape.length-1,s=i[1]===t.shape.length-1;a=qg(e,t,n,s)}if(n>0){let e;e=s>r?s+r-3:s-1;const t=[];for(let s=e;s<e+n;++s)t.push(s);a=Em(a,t)}return 1===a.shape.length&&(a=Ng(a,1)),a}))}(n,s,t)}interpretAxes(e,t){let n;return n=Array.isArray(this.axes)?this.axes:[WN(this.axes,e.length),WN(this.axes,t.length)],n}computeOutputShape(e){go(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new Pw("Dot layer does not support tensors of 4D or higher rank yet.");const s=this.interpretAxes(t,n);t.splice(s[0],1),n.splice(s[1],1),n.splice(0,1);const r=t.concat(n);return 1===r.length&&r.push(1),r}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}}VN.className="Dot",Up(VN);class UN extends ES{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return Bd((()=>{this.invokeCallHook(e,t);const n=bS(e);return jk((()=>$p(zk(n.shape,0,this.stddev),n)),(()=>n),t.training||!1)}))}}UN.className="GaussianNoise",Up(UN);class GN extends ES{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return Bd((()=>{this.invokeCallHook(e,t);const n=bS(e);if(this.rate>0&&this.rate<1){return jk((()=>{const e=Math.sqrt(this.rate/(1-this.rate));return Dp(n,zk(n.shape,1,e))}),(()=>n),t.training||!1)}return n}))}}GN.className="GaussianDropout",Up(GN);class HN extends ES{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||bS(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return Bd((()=>{if(this.rate<1&&this.rate>0){const n=this._getNoiseShape(e),s=()=>{const t=bS(e),s=-1.7580993408473766;let r=Ag(fm(n),this.rate);r=Rk(r,"float32");const i=((1-this.rate)*(1+this.rate*s**2))**-.5,a=-i*s*this.rate,o=$p(Dp(t,r),Dp($p(r,-1),s));return $p(Dp(o,i),a)};return jk(s,(()=>bS(e)),t.training||!1)}return e}))}}function jN(e,t,n,s,r){let i,a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:.001;if(2===e.rank)i=sg(e,t,n,s,r,a);else if(3===e.rank)i=rg(e,t,n,s,r,a);else{if(4!==e.rank)throw new Pw(`batchNormalization is not implemented for array of rank ${e.rank} yet`);i=ig(e,t,n,s,r,a)}return i}function KN(e,t,n,s){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return yo(s.slice().sort(),_k(0,e.rank-1))?function(e,t,n,s){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return Bd((()=>{const i=tm(e,s),a=i.mean,o=i.variance;return[jN(e,a,o,n,t,r),a,o]}))}(e,t,n,s,r):function(e,t,n,s){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return Bd((()=>{const i=tm(e,s),a=i.mean,o=i.variance,l=[];for(const t of _k(0,e.rank))-1!==s.indexOf(t)?l.push(1):l.push(e.shape[t]);const u=Jf(a,l),c=Jf(o,l),h=null==t?null:Jf(t,l),d=null==n?null:Jf(n,l);return[jN(e,u,c,d,h,r),a,o]}))}(e,t,n,s,r)}HN.className="AlphaDropout",Up(HN);class XN extends ES{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=null==e.axis?-1:e.axis,this.momentum=null==e.momentum?.99:e.momentum,this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=fS(e.betaInitializer||"zeros"),this.gammaInitializer=fS(e.gammaInitializer||"ones"),this.movingMeanInitializer=fS(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=fS(e.movingVarianceInitializer||"ones"),this.betaConstraint=qS(e.betaConstraint),this.gammaConstraint=qS(e.gammaConstraint),this.betaRegularizer=MC(e.betaRegularizer),this.gammaRegularizer=MC(e.gammaRegularizer)}build(e){e=xS(e);const t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(null==n)throw new Lw(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new IS({ndim:e.length,axes:{[t]:n}})];const s=[n];this.scale&&(this.gamma=this.addWeight("gamma",s,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",s,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",s,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",s,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return Bd((()=>{const n=null!=t.training&&t.training,s=bS(e),r=s.shape,i=r.length,a=_k(0,i),o=this.axis>=0?this.axis:this.axis+i;a.splice(o,1);const l=Ww(1,i);l[o]=r[o];const u=a.slice();u.sort();const c=!yo(u,_k(0,i).slice(0,i-1));if(!n)return(()=>{if(c){const e=Jf(this.movingMean.read(),l),t=Jf(this.movingVariance.read(),l),n=this.center?Jf(this.beta.read(),l):null,r=this.scale?Jf(this.gamma.read(),l):null;return jN(s,e,t,n,r,this.epsilon)}return jN(s,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[h,d,p]=KN(s,this.gamma.read(),this.beta.read(),a,this.epsilon),f=(e,t,n)=>{Bd((()=>{const s=1-n,r=e.read(),i=Dp(qp(r,t),s);e.write(qp(r,i))}))};return(()=>{f(this.movingMean,d,this.momentum),f(this.movingVariance,p,this.momentum)})(),h}))}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:pS(this.betaInitializer),gammaInitializer:pS(this.gammaInitializer),movingMeanInitializer:pS(this.movingMeanInitializer),movingVarianceInitializer:pS(this.movingVarianceInitializer),betaRegularizer:DC(this.betaRegularizer),gammaRegularizer:DC(this.gammaRegularizer),betaConstraint:KS(this.betaConstraint),gammaConstraint:KS(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}}XN.className="BatchNormalization",Up(XN);class qN extends ES{constructor(e){if(null==e&&(e={}),super(e),this.axis=null==e.axis?-1:e.axis,"number"===typeof this.axis){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else{if(!Array.isArray(this.axis))throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);for(const e of this.axis)if(!Number.isInteger(e))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=fS(e.betaInitializer||"zeros"),this.gammaInitializer=fS(e.gammaInitializer||"ones"),this.betaRegularizer=MC(e.betaRegularizer),this.gammaRegularizer=MC(e.gammaRegularizer),this.supportsMasking=!0}build(e){const t=(e=xS(e)).length;"number"===typeof this.axis&&(this.axis=[this.axis]);for(let r=0;r<this.axis.length;++r)this.axis[r]<0&&(this.axis[r]+=t);for(const r of this.axis)if(r<0||r>=t)throw new Error(`Invalid axis: ${r}`);if(this.axis.length!==Jw(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const n=this.axis.map((t=>e[t])),s=!0;this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,s):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,s):this.beta=null,this.built=!0}call(e,t){const n=bS(e),s=n.shape,r=s.length;return Bd((()=>{let{mean:e,variance:t}=tm(n,this.axis,!0);const i=Ww(1,r);for(const n of this.axis)i[n]=s[n];const a=e=>null!=e&&e.shape.length!==r?Jf(e,i):e;let o=this.scale?a(this.gamma.read()):null,l=this.center?a(this.beta.read()):null;const u=[],c=[];for(let n=0;n<r;++n)-1!==this.axis.indexOf(n)?(u.push(s[n]),c.push(1)):(u.push(1),c.push(s[n]));return e=Tg(e,u),t=Tg(t,u),null!=o&&(o=Tg(o,c)),null!=l&&(l=Tg(l,c)),jN(n,e,t,l,o,this.epsilon)}))}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:pS(this.betaInitializer),gammaInitializer:pS(this.gammaInitializer),betaRegularizer:DC(this.betaRegularizer),gammaRegularizer:DC(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}}qN.className="LayerNormalization",Up(qN);class YN extends ES{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,null==e.padding)this.padding=[[1,1],[1,1]];else if("number"===typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new Lw(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,n;if("number"===typeof e.padding[0])t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new Lw(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],2!==e.padding[1].length)throw new Lw(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new IS({ndim:4})]}computeOutputShape(e){let t,n;return e=xS(e),"channelsFirst"===this.dataFormat?(t=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],t,n]):(t=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],t,n,e[3]])}call(e,t){return Bd((()=>{return t=bS(e),n=this.padding,s=this.dataFormat,Bd((()=>{if(4!==t.rank)throw new Lw(`temporalPadding expects input tensor to be 4-D, but received a ${t.rank}-D tensor.`);if(null==n&&(n=[[1,1],[1,1]]),2!==n.length||2!==n[0].length||2!==n[1].length)throw new Lw("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==s&&(s="channelsLast"),"channelsLast"!==s&&"channelsFirst"!==s)throw new Lw(`Unknown data format: ${s}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let e;return e="channelsFirst"===s?[[0,0],[0,0],n[0],n[1]]:[[0,0],n[0],n[1],[0,0]],lm(t,e)}));var t,n,s}))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}function QN(e,t,n,s,r,i){return Bd((()=>{let a;mk(r),xk(i),bk(s),null==n&&(n=[1,1]),null==s&&(s="valid"),null==r&&(r="channelsLast"),null==i&&(i="max"),e=HC(e,r);const o="same"===s?"same":"valid";return a="max"===i?Yg(e,t,n,o):eg(e,t,n,o),"channelsFirst"===r&&(a=zm(a,[0,3,1,2])),a}))}function ZN(e,t,n,s,r,i){return Bd((()=>{let a;mk(r),xk(i),bk(s),null==n&&(n=[1,1,1]),null==s&&(s="valid"),null==r&&(r="channelsLast"),null==i&&(i="max"),e=jC(e,r);const o="same"===s?"same":"valid";return a="max"===i?Qg(e,t,n,o):tg(e,t,n,o),"channelsFirst"===r&&(a=zm(a,[0,4,1,2,3])),a}))}YN.className="ZeroPadding2D",Up(YN);class JN extends ES{constructor(e){if(null==e.poolSize&&(e.poolSize=2),super(e),"number"===typeof e.poolSize)this.poolSize=[e.poolSize];else{if(!Array.isArray(e.poolSize)||1!==e.poolSize.length||"number"!==typeof e.poolSize[0])throw new Lw(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);this.poolSize=e.poolSize}if(sk(this.poolSize,"poolSize"),null==e.strides)this.strides=this.poolSize;else if("number"===typeof e.strides)this.strides=[e.strides];else{if(!Array.isArray(e.strides)||1!==e.strides.length||"number"!==typeof e.strides[0])throw new Lw(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);this.strides=e.strides}sk(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,bk(this.padding),this.inputSpec=[new IS({ndim:3})]}computeOutputShape(e){const t=UC((e=xS(e))[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return Bd((()=>{this.invokeCallHook(e,t),e=Ak(bS(e),2);const n=this.poolingFunction(bS(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Em(n,[2])}))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}}class eT extends JN{constructor(e){super(e)}poolingFunction(e,t,n,s,r){return mk(r),bk(s),QN(e,t,n,s,r,"max")}}eT.className="MaxPooling1D",Up(eT);class tT extends JN{constructor(e){super(e)}poolingFunction(e,t,n,s,r){return mk(r),bk(s),QN(e,t,n,s,r,"avg")}}tT.className="AveragePooling1D",Up(tT);class nT extends ES{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(2!==e.strides.length)throw new Lw(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];sk(this.poolSize,"poolSize"),sk(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,mk(this.dataFormat),bk(this.padding),this.inputSpec=[new IS({ndim:4})]}computeOutputShape(e){e=xS(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2];return t=UC(t,this.poolSize[0],this.padding,this.strides[0]),n=UC(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return Bd((()=>(this.invokeCallHook(e,t),this.poolingFunction(bS(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class sT extends nT{constructor(e){super(e)}poolingFunction(e,t,n,s,r){return mk(r),bk(s),QN(e,t,n,s,r,"max")}}sT.className="MaxPooling2D",Up(sT);class rT extends nT{constructor(e){super(e)}poolingFunction(e,t,n,s,r){return mk(r),bk(s),QN(e,t,n,s,r,"avg")}}rT.className="AveragePooling2D",Up(rT);class iT extends ES{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(3!==e.strides.length)throw new Lw(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];sk(this.poolSize,"poolSize"),sk(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,mk(this.dataFormat),bk(this.padding),this.inputSpec=[new IS({ndim:5})]}computeOutputShape(e){e=xS(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],s="channelsFirst"===this.dataFormat?e[4]:e[3];return t=UC(t,this.poolSize[0],this.padding,this.strides[0]),n=UC(n,this.poolSize[1],this.padding,this.strides[1]),s=UC(s,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n,s]:[e[0],t,n,s,e[4]]}call(e,t){return Bd((()=>(this.invokeCallHook(e,t),this.poolingFunction(bS(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class aT extends iT{constructor(e){super(e)}poolingFunction(e,t,n,s,r){return mk(r),bk(s),ZN(e,t,n,s,r,"max")}}aT.className="MaxPooling3D",Up(aT);class oT extends iT{constructor(e){super(e)}poolingFunction(e,t,n,s,r){return mk(r),bk(s),ZN(e,t,n,s,r,"avg")}}oT.className="AveragePooling3D",Up(oT);class lT extends ES{constructor(e){super(e),this.inputSpec=[new IS({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new Pw}}class uT extends lT{constructor(e){super(e||{})}call(e,t){return Bd((()=>{const t=bS(e);return Zg(t,1)}))}}uT.className="GlobalAveragePooling1D",Up(uT);class cT extends lT{constructor(e){super(e||{})}call(e,t){return Bd((()=>{const t=bS(e);return Og(t,1)}))}}cT.className="GlobalMaxPooling1D",Up(cT);class hT extends ES{constructor(e){super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,mk(this.dataFormat),this.inputSpec=[new IS({ndim:4})]}computeOutputShape(e){return"channelsLast"===this.dataFormat?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new Pw}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class dT extends hT{call(e,t){return Bd((()=>{const t=bS(e);return"channelsLast"===this.dataFormat?Zg(t,[1,2]):Zg(t,[2,3])}))}}dT.className="GlobalAveragePooling2D",Up(dT);class pT extends hT{call(e,t){return Bd((()=>{const t=bS(e);return"channelsLast"===this.dataFormat?Og(t,[1,2]):Og(t,[2,3])}))}}pT.className="GlobalMaxPooling2D",Up(pT);class fT extends ES{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(e){null!=this.layer&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const s=oI(t.layer,n);delete t.layer;const r={layer:s};return Object.assign(r,t),new e(r)}}class gT extends fT{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=xS(e)).length<3)throw new Lw(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){const t=[(e=xS(e))[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),s=e[1];return[n[0],s].concat(n.slice(1))}call(e,t){return Bd((()=>uN(((e,n)=>[bS(this.layer.call(e,t)),[]]),e=bS(e),[],!1,null,null,!1,!0)[1]))}}gT.className="TimeDistributed",Up(gT);class mT extends fT{constructor(e){super(e);const t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=oI(n),t.goBackwards=!0!==t.goBackwards;const s={};var r;if(s.className=e.layer.getClassName(),s.config=t,this.backwardLayer=oI(s),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,r=this.mergeMode,tk(fk,"BidirectionalMergeMode",r),e.weights)throw new Pw("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t,n,s,r=this.forwardLayer.computeOutputShape(e);return Array.isArray(r)&&Array.isArray(r[0])||(r=[r]),this.returnState?(s=r.slice(1),t=r[0]):t=r[0],"concat"===this.mergeMode?(t[t.length-1]*=2,n=[t]):n=null==this.mergeMode?[t,t.slice()]:[t],this.returnState?null==this.mergeMode?n.concat(s).concat(s.slice()):[t].concat(s).concat(s.slice()):Gw(n)}apply(e,t){let n=null==t?null:t.initialState,s=null==t?null:t.constants;null==t&&(t={});const r=lN(e,n,s,this.numConstants);if(e=r.inputs,n=r.initialState,s=r.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(null==n||0===n.length)&&null==s)return super.apply(e,t);const i=[],a=[];if(null!=n){const e=n.length;if(e%2>0)throw new Lw("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,i.push(...n);const s=n.map((e=>new IS({shape:e.shape})));this.forwardLayer.stateSpec=s.slice(0,e/2),this.backwardLayer.stateSpec=s.slice(e/2),a.push(...s)}if(null!=s)throw new Pw("Support for constants in Bidirectional layers is not implemented yet.");const o=i[0]instanceof CS;for(const l of i)if(l instanceof CS!==o)throw new Lw("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(o){const n=[e].concat(i),s=this.inputSpec.concat(a),r=this.inputSpec;this.inputSpec=s;const o=super.apply(n,t);return this.inputSpec=r,o}return super.apply(e,t)}call(e,t){return Bd((()=>{const n=t.initialState;let s,r,i,a;if(null==n)s=this.forwardLayer.call(e,t),r=this.backwardLayer.call(e,t);else{const i=n.slice(0,n.length/2),a=n.slice(n.length/2);s=this.forwardLayer.call(e,Object.assign(t,{initialState:i})),r=this.backwardLayer.call(e,Object.assign(t,{initialState:a}))}return this.returnState&&(Array.isArray(s)&&(i=s.slice(1).concat(r.slice(1))),s=s[0],r=r[0]),this.returnSequences&&(r=bm(r,1)),"concat"===this.mergeMode?a=Ok([s,r]):"sum"===this.mergeMode?a=$p(s,r):"ave"===this.mergeMode?a=Dp(.5,$p(s,r)):"mul"===this.mergeMode?a=Dp(s,r):null==this.mergeMode&&(a=[s,r]),this.returnState?null==this.mergeMode?a.concat(i):[a].concat(i):a}))}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){vk(this.forwardLayer.name,(()=>{this.forwardLayer.build(e)})),vk(this.backwardLayer.name,(()=>{this.backwardLayer.build(e)})),this.built=!0}computeMask(e,t){let n;if(Array.isArray(t)&&(t=t[0]),n=this.returnSequences?null==this.mergeMode?[t,t]:t:null==this.mergeMode?[null,null]:null,this.returnState){const e=this.forwardLayer.states.map((e=>null));return Array.isArray(n)?n.concat(e).concat(e):[n].concat(e).concat(e)}return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const n=oI(t.layer);if(delete t.layer,null!=t.numConstants)throw new Pw("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const s=t;return s.layer=n,new e(s)}}mT.className="Bidirectional",Up(mT);class bT extends ES{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){const e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return Bd((()=>("float32"!==(e=bS(e)).dtype&&(e=Rk(e,"float32")),$p(Dp(e,this.scale),this.offset))))}}bT.className="Rescaling",Up(bT);const{resizeBilinear:xT,cropAndResize:yT}=Bb;class vT extends ES{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,n,s,r,i,a,o){return Bd((()=>{let l,u=!1;const c=[t/i,n/a,(s+t)/i,(r+n)/a],h=[];3===e.rank?(u=!0,l=$m([e])):l=e;for(let e=0;e<l.shape[0];e++)h.push(c);const d=Od(h,[h.length,4]),p=gm(0,h.length,1,"int32"),f=yT(l,d,p,[s,r],"nearest");return Rk(u?bS(Mm(f)):f,o)}))}upsize(e,t,n,s){return Bd((()=>Rk(xT(e,[t,n]),s)))}call(e,t){return Bd((()=>{const t=bS(e),n=t.dtype,s=t.shape,r=s[s.length-3],i=s[s.length-2];let a=0;r!==this.height&&(a=Math.floor((r-this.height)/2));let o=0;return i!==this.width&&(o=Math.floor((i-this.width)/2),0===o&&(o=1)),a>=0&&o>=0?this.centerCrop(t,a,o,this.height,this.width,r,i,n):this.upsize(e,this.height,this.width,n)}))}getConfig(){const e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){const t=(e=xS(e)).length-3,n=e.length-2;return e[t]=this.height,e[n]=this.width,e}}vT.className="CenterCrop",Up(vT);class wT extends ES{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return null==(e=xS(e))?[this.numTokens]:"oneHot"===this.outputMode&&1!==e[e.length-1]?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return Bd((()=>{let n;if("int32"!==(e=bS(e)).dtype&&(e=Rk(e,"int32")),"undefined"!==typeof t.countWeights){if("count"!==this.outputMode)throw new Lw(`countWeights is not used when outputMode !== count.\n              Received countWeights=${t.countWeights}`);n=bS(t.countWeights)}const s=Og(e),r=Jg(e),i=Rg(this.numTokens,s).bufferSync().get(0),a=Ag(r,0).bufferSync().get(0);if(!i||!a)throw new Lw(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return function(e,t,n,s){let r=bS(e);if("int32"!==r.dtype&&(r=Rk(r,"int32")),"int"===t)return r;const i=r.shape;if(0===r.rank&&(r=Ng(r,-1)),"oneHot"===t&&1!==r.shape[r.shape.length-1]&&(r=Ng(r,-1)),r.rank>2)throw new Lw(`When outputMode is not int, maximum output rank is 2 Received outputMode ${t} and input shape ${i} which would result in output rank ${r.rank}.`);const a=["multiHot","oneHot"].includes(t),o=r;let l;if(l=vg(o,"undefined"!==typeof s&&"count"===t?s:[],n,a),"tfIdf"!==t)return l;if(s)return Dp(l,s);throw new Lw("When outputMode is 'tfIdf', weights must be provided.")}(e,this.outputMode,this.numTokens,n)}))}}wT.className="CategoryEncoding",Up(wT);const kT=new Set(["bilinear","nearest"]);class ST extends ES{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation){if(!kT.has(e.interpolation))throw new Lw(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);this.interpolation=e.interpolation}else this.interpolation="bilinear";this.cropToAspectRatio=Boolean(e.cropToAspectRatio)}computeOutputShape(e){const t=(e=xS(e))[2];return[this.height,this.width,t]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return Bd((()=>{const t=[this.height,this.width];if("bilinear"===this.interpolation)return Bb.resizeBilinear(e,t,!this.cropToAspectRatio);if("nearest"===this.interpolation)return Bb.resizeNearestNeighbor(e,t,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...kT]} are supported`)}))}}ST.className="Resizing",Up(ST);class IT{constructor(e){this.seed=e}next(){if(void 0!==this.seed)return this.seed++}}IT.className="RandomSeed";class CT extends ES{constructor(e){super(e),this.randomGenerator=new IT(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}}CT.className="BaseRandomLayer";const NT=new Set(["bilinear","nearest"]);class TT extends CT{constructor(e){super(e);const{factor:t,interpolation:n="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&2===this.factor.length)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else{if(Array.isArray(this.factor)||!(this.factor>0))throw new Lw(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);this.widthLower=-this.factor,this.widthUpper=this.factor}if(this.widthLower<-1||this.widthUpper<-1)throw new Lw(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new Lw(`factor cannot have upper bound less than lower bound.\n        Got upper bound: ${this.widthUpper}.\n        Got lower bound: ${this.widthLower}\n      `);if(n){if(!NT.has(n))throw new Lw(`Invalid interpolation parameter: ${n} is not implemented`);this.interpolation=n}}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){const t=(e=xS(e))[2];return[this.imgHeight,-1,t]}call(e,t){return Bd((()=>{const t=bS(e);this.imgHeight=t.shape[t.shape.length-3];const n=t.shape[t.shape.length-2];this.widthFactor=fm([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let s=this.widthFactor.dataSync()[0]*n;s=Math.round(s);const r=[this.imgHeight,s];switch(this.interpolation){case"bilinear":return Bb.resizeBilinear(e,r);case"nearest":return Bb.resizeNearestNeighbor(e,r);default:throw new Error(`Interpolation is ${this.interpolation}\n          but only ${[...NT]} are supported`)}}))}}function _T(e){return new NN(e)}TT.className="RandomWidth",Up(TT);var ET,$T;qo().registerFlag("KEEP_INTERMEDIATE_TENSORS",(()=>!1),(e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")})),function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"}(ET||(ET={})),function(e){let t;!function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))}($T||($T={}));Error;new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function RT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Map,s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new Set;if(null==e)return null;if("function"===typeof Blob&&e instanceof Blob)return e.slice();if(s.has(e))throw new Error("Circular references are not supported.");if(n.has(e))return n.get(e);const r=t(e);if(r.recurse&&null!==r.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(r.recurse){if(MT(e)){const r=Array.isArray(e)?[]:{};s.add(e);for(const i in e){const a=RT(e[i],t,n,s);r[i]=a}return s.delete(e),e.__proto__&&(r.__proto__=e.__proto__),r}throw new Error(`Can't recurse into non-iterable type: ${e}`)}return n.set(e,r.value),r.value}function AT(e){return DT(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:FT)}function DT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Set;const s=e[0];if(n.has(s))throw new Error("Circular references are not supported.");const r=t(e);if(r.recurse&&null!==r.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(r.recurse){if(MT(s)){const r=Array.isArray(s)?[]:{};n.add(s);for(const i in s){const s=DT(e.map((e=>e[i])),t,n);r[i]=s}return n.delete(s),r}throw new Error(`Can't recurse into non-iterable type: ${s}`)}return r.value}function FT(e){return null===e?null:MT(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}function MT(e){let t=!1;if(qo().get("IS_BROWSER"))t=e instanceof TextDecoder;else{const{StringDecoder:s}=n(551);t=e instanceof s}return null!=e&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||"object"===typeof e&&!(e instanceof td)&&!(e instanceof Promise)&&!t)}function OT(e){return function(e,t){return RT(e,t)}(e,LT)}function LT(e){return e instanceof td?{value:e.clone(),recurse:!1}:MT(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}class PT{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,null==e)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(const t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}}class zT extends PT{constructor(){super(zT.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){const e=2*this.capacity,t=new Array(e),n=this.length();for(let s=0;s<n;s++)t[s]=this.get(this.wrap(this.begin+s));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}}function BT(e){return new GT(e)}function WT(e,t){return new t_(e,t)}zT.INITIAL_CAPACITY=32;class VT{async toArray(){const e=[];let t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){const e=this.prefetch(100),t=[];let n=await e.next();for(;!n.done;)t.push(n.value),n=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),n=e(t.value);for(;!t.done&&n;)t=await this.next(),n=e(t.value)}handleErrors(e){return new QT(this,e)}filter(e){return new qT(this,e)}map(e){return new YT(this,e)}mapAsync(e){return new ZT(this,e)}serialMapAsync(e){return new ZT(this,e).serial()}flatmap(e){return new e_(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile((e=>!0===e))}rowMajorBatch(e){return new XT(this,e,!(arguments.length>1&&void 0!==arguments[1])||arguments[1])}columnMajorBatch(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:FT;return this.rowMajorBatch(e,t).map((e=>AT(e,n)))}concatenate(e,t){return new t_(new UT([this,e]),t)}take(e){return e<0||null==e?this:new KT(this,e)}skip(e){return e<0||null==e?this:new jT(this,e)}prefetch(e){return new s_(this,e)}shuffle(e,t){return new r_(this,e,t)}serial(){return new HT(this)}}class UT extends VT{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const e=this.items[this.trav];return this.trav++,{value:OT(e),done:!1}}}class GT extends VT{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(e){throw e.message=`Error thrown while iterating through a dataset: ${e.message}`,e}}}class HT extends VT{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){return this.upstream.next()}}class jT extends VT{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const e=await this.upstream.next();if(e.done)return e;Wd(e.value)}return this.upstream.next()}}class KT extends VT{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class XT extends VT{constructor(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){const e=[];for(;e.length<this.batchSize;){const t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}}class qT extends VT{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;){const e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;Wd(e.value)}}}class YT extends VT{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=md(e.value),n=this.transform(e.value),s=md(n);for(const r of t)gd(r,s)||r.dispose();return{value:n,done:!1}}}class QT extends VT{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(e){if(!this.handler(e))return{value:null,done:!0}}}}class ZT extends VT{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=md(e.value),n=await this.transform(e.value),s=md(n);for(const r of t)gd(r,s)||r.dispose();return{value:n,done:!1}}}class JT extends VT{constructor(){super(),this.outputQueue=new zT,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;0===this.outputQueue.length();)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class e_ extends JT{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){const e=await this.upstream.next();if(e.done)return!1;const t=md(e.value),n=this.transform(e.value),s=md(n);this.outputQueue.pushAll(n);for(const r of t)gd(r,s)||r.dispose();return!0}}class t_ extends VT{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,null==this.iterator){const e=await this.moreIterators.next();if(e.done)return{value:null,done:!0};this.iterator=e.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}}var n_;!function(e){e[e.FAIL=0]="FAIL",e[e.SHORTEST=1]="SHORTEST",e[e.LONGEST=2]="LONGEST"}(n_||(n_={}));class s_ extends VT{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new PT(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){const e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}}class r_ extends s_{constructor(e,t,n){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=cm.alea(n||Ph().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(!t.done)return this.refill(),t;this.upstreamExhausted=!0}return{value:null,done:!0}}}class i_{constructor(){this.size=null}batch(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n=this;let s;return go(e>0,(()=>`batchSize needs to be positive, but it is\n      ${e}`)),s=this.size===1/0||null==this.size?this.size:t?Math.ceil(this.size/e):Math.floor(this.size/e),a_((async()=>(await n.iterator()).columnMajorBatch(e,t,o_)),s)}concatenate(e){const t=this;let n;return n=this.size===1/0||e.size===1/0?1/0:null!=this.size&&null!=e.size?this.size+e.size:null,a_((async()=>(await t.iterator()).concatenate(await e.iterator())),n)}filter(e){const t=this;let n;return n=this.size===1/0?1/0:null,a_((async()=>(await t.iterator()).filter((t=>Bd((()=>e(t)))))),n)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){const t=this;return a_((async()=>(await t.iterator()).map((t=>Bd((()=>e(t)))))),this.size)}mapAsync(e){const t=this;return a_((async()=>(await t.iterator()).mapAsync(e)),this.size)}prefetch(e){if(null==e)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const t=this;return a_((async()=>(await t.iterator()).prefetch(e)),this.size)}repeat(e){const t=this;let n;return n=null!=this.size&&e>0?this.size*e:0===e?0:null!=this.size&&(void 0===e||e<0)?1/0:null,a_((async()=>WT(BT((async()=>({value:await t.iterator(),done:!1}))).take(e))),n)}skip(e){const t=this;let n;return n=null!=this.size&&e>=0&&this.size>=e?this.size-e:null!=this.size&&(this.size<e||void 0===e||e<0)?0:null,a_((async()=>(await t.iterator()).skip(e)),n)}shuffle(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(null==e||e<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);const s=this,r=cm.alea(t||Ph().toString());return a_((async()=>{let t=r.int32();return n&&(t+=r.int32()),(await s.iterator()).shuffle(e,t.toString())}),this.size)}take(e){const t=this;let n;return n=null!=this.size&&this.size>e?e:null!=this.size&&this.size<=e?this.size:null,a_((async()=>(await t.iterator()).take(e)),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}}function a_(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return new class extends i_{constructor(){super(...arguments),this.size=t}async iterator(){return e()}}}function o_(e){if(null===e)return null;if(function(e){return null==e||null===(t=e)||"object"!==typeof t&&"function"!==typeof t||Array.isArray(e)||"object"===typeof e&&e instanceof td||Wh(e);var t}(e[0])){return{value:function(e){if(0===e.length)throw new Error("Can't make a batch of zero elements.");return e[0]instanceof td?$m(e):Od(e)}(e),recurse:!1}}return{value:null,recurse:!0}}i_.MAX_BUFFER_SIZE=1e4;Symbol("out"),Symbol("field"),Symbol("quote"),Symbol("quoteafterquote"),Symbol("quoteinquote");function l_(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&go("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the CPU backend.`))}))}const u_=ey;class c_ extends lo{nextDataId(){return c_.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new oo(this,Pd())}write(e,t,n){this.firstUse&&(this.firstUse=!1,qo().get("IS_NODE")&&hh("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));const s={id:this.nextDataId()};return this.data.set(s,{values:e,dtype:n,refCount:1}),s}makeTensorInfo(e,t,n){let s;if("string"===t&&null!=n&&n.length>0&&Ro(n[0])){const r=n.map((e=>zh(e)));s=this.write(r,e,t)}else s=this.write(n,e,t);return{dataId:s,shape:e,dtype:t}}refCount(e){if(this.data.has(e)){return this.data.get(e).refCount}return 0}incRef(e){this.data.get(e).refCount++}decRef(e){if(this.data.has(e)){this.data.get(e).refCount--}}move(e,t,n,s,r){this.data.set(e,{values:t,dtype:s,refCount:r})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:n}=this.data.get(e);if("complex64"===t){return xx(this.readSync(n.real.dataId),this.readSync(n.imag.dataId))}return function(e,t){if(Array.isArray(e))return e;if("float32"===t)return e instanceof Float32Array?e:new Float32Array(e);if("int32"===t)return e instanceof Int32Array?e:new Int32Array(e);if("bool"===t||"string"===t)return Uint8Array.from(new Int32Array(e));throw new Error(`Unknown dtype ${t}`)}(this.data.get(e).values,t)}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map((e=>Bh(e)));return Tp(e.shape,e.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return Tp(e.shape,e.dtype,t)}makeOutput(e,t,n){return Pd().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,e),this)}disposeData(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:n}=this.data.get(e);null!=n&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=Ph();e();return{kernelMs:Ph()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){l_([e],"where");const t=this.readSync(e.dataId);return u_(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}c_.nextDataId=0;function h_(e){return(t,n,s)=>{const r=_o(n,t.length);for(let i=0;i<t.length;++i)r[i]=e(t[i],s);return r}}function d_(e,t,n){return p_(e,h_(t),n)}function p_(e,t,n){return s=>{let{inputs:r,attrs:i,backend:a}=s;const{x:o}=r;l_(o,e);const l=a,u=l.data.get(o.dataId).values;let c;if("string"===o.dtype){if(!Array.isArray(u))throw new Error("String tensor's value was not an instance of Array");c=Zx(u)}else c=u;const h=n||o.dtype,d=t(c,h,i);return l.makeTensorInfo(o.shape,h,d)}}Ud("cpu",(()=>new c_),1);const f_=d_(Zl,(e=>e>=0?e:Math.exp(e)-1)),g_={kernelName:Zl,backendName:"cpu",kernelFunc:f_};function m_(e){const{inputs:t,backend:n}=e,{x:s}=t;return n.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const b_={kernelName:gu,backendName:"cpu",kernelFunc:m_};function x_(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{alpha:i}=s;l_([r],"leakyRelu");const a=xo(r.shape),o=n.data.get(r.dataId).values,l=To("float32",a);for(let u=0;u<o.length;u++)l[u]=o[u]<0?i*o[u]:o[u];return n.makeTensorInfo(r.shape,"float32",l)}const y_={kernelName:wu,backendName:"cpu",kernelFunc:x_};function v_(e){return(t,n,s,r,i)=>{const a=ef(t,n),o=a.length,l=Oo(a),u=To(i,xo(a)),c=t.length,h=n.length,d=Oo(t),p=Oo(n),f=Zp(t,a),g=Zp(n,a);if(f.length+g.length===0)for(let m=0;m<u.length;++m)u[m]=e(s[m%s.length],r[m%r.length]);else for(let m=0;m<u.length;++m){const t=Go(m,o,l),n=t.slice(-c);f.forEach((e=>n[e]=0));const i=Uo(n,c,d),a=t.slice(-h);g.forEach((e=>a[e]=0));const b=Uo(a,h,p);u[m]=e(s[i],r[b])}return[u,a]}}const w_=v_(((e,t)=>e<0?t*e:e));function k_(e){const{inputs:t,backend:n}=e,{x:s,alpha:r}=t;l_([s,r],"prelu");const i=n.data.get(s.dataId).values,a=n.data.get(r.dataId).values,[o,l]=w_(s.shape,r.shape,i,a,"float32");return n.makeTensorInfo(l,"float32",o)}const S_={kernelName:nc,backendName:"cpu",kernelFunc:k_},I_=d_(cc,(e=>Math.max(0,e))),C_={kernelName:cc,backendName:"cpu",kernelFunc:I_},N_=d_(mc,(e=>Math.min(Math.max(0,e),6))),T_={kernelName:mc,backendName:"cpu",kernelFunc:N_},__=h_((e=>1/(1+Math.exp(-e)))),E_=d_(Ec,(e=>1/(1+Math.exp(-e)))),$_={kernelName:Ec,backendName:"cpu",kernelFunc:E_};function R_(e,t,n,s,r){if("linear"===n)return m_({inputs:{x:t},backend:e});if("relu"===n)return I_({inputs:{x:t},backend:e});if("elu"===n)return f_({inputs:{x:t},backend:e});if("relu6"===n)return N_({inputs:{x:t},backend:e});if("prelu"===n)return k_({inputs:{x:t,alpha:s},backend:e});if("leakyrelu"===n)return x_({inputs:{x:t},backend:e,attrs:{alpha:r}});if("sigmoid"===n)return E_({inputs:{x:t},backend:e});throw new Error(`Activation ${n} has not been implemented for the CPU backend.`)}function A_(e){const{inputs:t,backend:n}=e,{real:s,imag:r}=t,i=n.data.get(s.dataId).values,a=n.data.get(r.dataId).values,o=n.makeTensorInfo(s.shape,"complex64");return n.data.get(o.dataId).complexTensorInfos={real:n.makeTensorInfo(s.shape,"float32",i),imag:n.makeTensorInfo(r.shape,"float32",a)},o}const D_={kernelName:Nl,backendName:"cpu",kernelFunc:A_};function F_(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"float32";if("complex64"===n){return A_({inputs:{real:F_(e,t,"float32"),imag:F_(e,t,"float32")},backend:e})}const s=Bo(xo(t),n);return e.makeTensorInfo(t,n,s)}function M_(e){const{inputs:t,backend:n}=e,{input:s}=t,r=n.data.get(s.dataId).complexTensorInfos.real,i=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,i)}const O_={kernelName:lc,backendName:"cpu",kernelFunc:M_};function L_(e,t,n,s){if("int32"===s){return[t,"int32",Int32Array.from(e)]}if("bool"===s){const s=Lh([0],n),[r,i]=v_(((e,t)=>e!==t?1:0))(t,[],e,s,"bool");return[i,"bool",r]}throw new Error(`Error in Cast: failed to cast ${n} to ${s}`)}function P_(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{dtype:i}=s;if("complex64"===i){if("complex64"===r.dtype)return m_({inputs:{x:r},backend:n});const e=F_(n,r.shape,r.dtype),t=P_({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),s=A_({inputs:{real:t,imag:e},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),s}if("complex64"===r.dtype){const e=M_({inputs:{input:r},backend:n}),t=P_({inputs:{x:e},backend:n,attrs:{dtype:i}});return n.disposeIntermediateTensorInfo(e),t}if(!Eo(r.dtype,i)){const e=m_({inputs:{x:r},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:i}}const a=n.data.get(r.dataId).values,[o,l,u]=L_(a,r.shape,r.dtype,i);return n.makeTensorInfo(o,l,u)}const z_={kernelName:Sl,backendName:"cpu",kernelFunc:P_};function B_(e,t,n,s){return null==n?n=>{let{inputs:r,backend:i}=n;const{a:a,b:o}=r,l=i;l_([a,o],e);const u=l.data.get(a.dataId).values,c=l.data.get(o.dataId).values,h="string"===a.dtype?Zx(u):u,d="string"===a.dtype?Zx(c):c,p=s||a.dtype,[f,g]=t(a.shape,o.shape,h,d,p);return l.makeTensorInfo(g,p,f)}:e=>{let{inputs:r,backend:i}=e;const{a:a,b:o}=r,l=i;if("complex64"===a.dtype||"complex64"===o.dtype){const e=P_({inputs:{x:a},backend:l,attrs:{dtype:"complex64"}}),t=l.data.get(e.dataId),s=t.complexTensorInfos.real,r=t.complexTensorInfos.imag,i=l.data.get(s.dataId).values,u=l.data.get(r.dataId).values,c=P_({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),h=l.data.get(c.dataId),d=h.complexTensorInfos.real,p=h.complexTensorInfos.imag,f=l.data.get(d.dataId).values,g=l.data.get(p.dataId).values,[m,b,x]=n(a.shape,o.shape,i,u,f,g),y=l.makeTensorInfo(x,"float32",m),v=l.makeTensorInfo(x,"float32",b),w=A_({inputs:{real:y,imag:v},backend:l});return l.disposeIntermediateTensorInfo(e),l.disposeIntermediateTensorInfo(c),l.disposeIntermediateTensorInfo(y),l.disposeIntermediateTensorInfo(v),w}{const e=l.data.get(a.dataId).values,n=l.data.get(o.dataId).values,r=s||a.dtype,[i,u]=t(a.shape,o.shape,e,n,r);return l.makeTensorInfo(u,r,i)}}}function W_(e){return(t,n,s,r,i,a)=>{const o=ef(t,n),l=xo(o),u=o.length,c=Oo(o),h=To("float32",l),d=To("float32",l),p=Zp(t,o),f=Zp(n,o),g=xx(s,r),m=xx(i,a),b=t.length,x=Oo(t),y=n.length,v=Oo(n);if(p.length+f.length===0)for(let w=0;w<h.length;w++){const t=w%g.length,n=w%m.length,s=e(g[2*t],g[2*t+1],m[2*n],m[2*n+1]);h[w]=s.real,d[w]=s.imag}else for(let w=0;w<h.length;w++){const t=Go(w,u,c),n=t.slice(-b);p.forEach((e=>n[e]=0));const s=Uo(n,b,x),r=t.slice(-y);f.forEach((e=>r[e]=0));const i=Uo(r,y,v),a=e(g[2*s],g[2*s+1],m[2*i],m[2*i+1]);h[w]=a.real,d[w]=a.imag}return[h,d,o]}}const V_=v_(((e,t)=>e+t)),U_=W_(((e,t,n,s)=>({real:e+n,imag:t+s}))),G_=B_(sl,V_,U_),H_={kernelName:sl,backendName:"cpu",kernelFunc:G_};function j_(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{shape:i}=s,a=xo(r.shape),o=Io(i,a),l=xo(o);go(a===l,(()=>`The new shape (${o}) has ${l} elements and the old shape (${r.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`)),n.incRef(r.dataId);const u=n.data.get(r.dataId);if(null!=u.complexTensorInfos){const e=u.complexTensorInfos.real,t=u.complexTensorInfos.imag;e.shape=o,t.shape=o}return{dataId:r.dataId,shape:o,dtype:r.dtype}}const K_={kernelName:hc,backendName:"cpu",kernelFunc:j_};function X_(e){const{inputs:t,backend:n,attrs:s}=e,{a:r,b:i}=t,{transposeA:a,transposeB:o}=s;l_([r,i],"matMul");const l=r.shape.length,u=i.shape.length,c=a?r.shape[l-2]:r.shape[l-1],h=o?i.shape[u-1]:i.shape[u-2],d=a?r.shape[l-1]:r.shape[l-2],p=o?i.shape[u-2]:i.shape[u-1],f=r.shape.slice(0,-2),g=i.shape.slice(0,-2),m=xo(f),b=xo(g),x=ef(r.shape.slice(0,-2),i.shape.slice(0,-2)).concat([d,p]);go(c===h,(()=>`Error in matMul: inner shapes (${c}) and (${h}) of Tensors with shapes ${r.shape} and ${i.shape} and transposeA=${a} and transposeB=${o} must match.`));const y=o?[b,p,h]:[b,h,p],v=j_({inputs:{x:r},backend:n,attrs:{shape:a?[m,c,d]:[m,d,c]}}),w=j_({inputs:{x:i},backend:n,attrs:{shape:y}}),k=a?v.shape[1]:v.shape[2],S=a?v.shape[2]:v.shape[1],I=o?w.shape[1]:w.shape[2],C=Math.max(m,b),N=n.data.get(v.dataId).values,T=n.data.get(w.dataId).values,_=Oo(v.shape),E=Oo(w.shape),[$,R,A]=a?[_[0],1,_[1]]:[_[0],_[1],1],[D,F,M]=o?[1,E[1],E[0]]:[E[1],1,E[0]],O=S*I,L=Tp([C,S,I],v.dtype),P=L.values,z=n.blockSize;for(let B=0;B<C;B++){const e=B%m,t=B%b;for(let n=0;n<S;n+=z){const s=Math.min(n+z,S);for(let r=0;r<I;r+=z){const i=Math.min(r+z,I);for(let a=0;a<k;a+=z){const o=Math.min(a+z,k);for(let l=n;l<s;l++)for(let n=r;n<i;n++){let s=0;for(let r=a;r<o;r++){s+=N[e*$+l*R+r*A]*T[r*D+n*F+t*M]}P[B*O+(l*I+n)]+=s}}}}}return n.disposeIntermediateTensorInfo(v),n.disposeIntermediateTensorInfo(w),n.makeTensorInfo(x,L.dtype,L.values)}const q_={kernelName:xl,backendName:"cpu",kernelFunc:X_};const Y_={kernelName:lh,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{a:r,b:i,bias:a,preluActivationWeights:o}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:h}=s;let d,p,f;const g=[];d=X_({inputs:{a:r,b:i},attrs:{transposeA:l,transposeB:u},backend:n}),a&&(p=G_({inputs:{a:d,b:a},backend:n}),g.push(d),d=p),c&&(f=R_(n,d,c,o,h),g.push(d),d=f);for(const m of g)n.disposeIntermediateTensorInfo(m);return d}};function Q_(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}const Z_={kernelName:el,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend;l_(t,"abs");let s=new Float32Array(xo(t.shape));return s=Q_(n.data.get(t.dataId).values),n.makeOutput(s,t.shape,t.dtype)}},J_=d_(tl,(e=>Math.acos(e))),eE={kernelName:tl,backendName:"cpu",kernelFunc:J_},tE=d_(nl,(e=>Math.acosh(e))),nE={kernelName:nl,backendName:"cpu",kernelFunc:tE};const sE={kernelName:rl,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,s=t;l_(t,"addN");const r=s.map((e=>n.data.get(e.dataId).values)),i=Tp(s[0].shape,s[0].dtype),a=i.values;for(let o=0;o<s.length;o++){const e=r[o];for(let t=0;t<a.length;t++)a[t]+=e[t]}return n.makeTensorInfo(i.shape,i.dtype,i.values)}};function rE(e,t,n,s,r){const i=t.length,a=xo(t),o=Oo(t),l=Oo(r),u=To(n,xo(r));for(let c=0;c<a;++c){const t=Go(c,i,o),n=new Array(t.length);for(let e=0;e<n.length;e++)n[e]=t[s[e]];u[Uo(n,i,l)]=e[c]}return u}function iE(e){const{inputs:t,attrs:n,backend:s}=e,{x:r}=t,{perm:i}=n;l_(r,"transpose");const a=r.shape.length,o=new Array(a);for(let u=0;u<o.length;u++)o[u]=r.shape[i[u]];const l=rE(s.data.get(r.dataId).values,r.shape,r.dtype,i,o);return{dataId:s.write(l,o,r.dtype),shape:o,dtype:r.dtype}}const aE={kernelName:eh,backendName:"cpu",kernelFunc:iE};const oE={kernelName:il,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:i,keepDims:a}=s;l_(r,"all");const o=Co(i,r.shape);let l=o;const u=Gg(l,r.shape.length);let c=r;null!=u&&(c=iE({inputs:{x:r},backend:n,attrs:{perm:u}}),l=jg(l.length,r.shape.length)),Ug("all",l,c.shape.length);const[h,d]=Wg(c.shape,l),p=xo(d),f=Bo(xo(h),c.dtype),g=n.data.get(c.dataId).values;for(let b=0;b<f.length;++b){const e=b*p;let t=g[e];for(let n=0;n<p;++n){const s=g[e+n];t=t&&s}f[b]=t}null!=u&&n.disposeIntermediateTensorInfo(c);const m=n.makeTensorInfo(h,c.dtype,f);if(a){const e=j_({inputs:{x:m},backend:n,attrs:{shape:Vg(h,o)}});return n.disposeIntermediateTensorInfo(m),e}return m}};const lE={kernelName:al,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:i,keepDims:a}=s;l_(r,"any");const o=Co(i,r.shape);let l=o;const u=Gg(l,r.shape.length);let c=r;null!=u&&(c=iE({inputs:{x:r},backend:n,attrs:{perm:u}}),l=jg(l.length,r.shape.length)),Ug("any",l,c.shape.length);const[h,d]=Wg(c.shape,l),p=xo(d),f=Bo(xo(h),c.dtype),g=n.data.get(c.dataId).values;for(let b=0;b<f.length;++b){const e=b*p;let t=g[e];for(let n=0;n<p;++n){const s=g[e+n];t=t||s}f[b]=t}null!=u&&n.disposeIntermediateTensorInfo(c);const m=n.makeTensorInfo(h,c.dtype,f);if(a){const e=j_({inputs:{x:m},backend:n,attrs:{shape:Vg(h,o)}});return n.disposeIntermediateTensorInfo(m),e}return m}};const uE={kernelName:ol,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:i}=s;l_(r,"argMax");let a=Co(i,r.shape);const o=Gg(a,r.shape.length);let l=r;const u=[];null!=o&&(l=iE({inputs:{x:r},backend:n,attrs:{perm:o}}),u.push(l),a=jg(a.length,l.shape.length)),a=[a[0]],Ug("argMax",a,l.shape.length);const[c,h]=Wg(l.shape,a),d=Bo(xo(c),"int32"),p=xo(h),f=n.data.get(l.dataId).values;for(let g=0;g<d.length;++g){const e=g*p;let t=f[e],n=0;for(let s=0;s<p;++s){const r=f[e+s];r>t&&(t=r,n=s)}d[g]=n}return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(c,"int32",d)}};const cE={kernelName:ll,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:i}=s;l_(r,"argMin");let a=Co(i,r.shape);const o=Gg(a,r.shape.length);let l=r;const u=[];null!=o&&(l=iE({inputs:{x:r},backend:n,attrs:{perm:o}}),u.push(l),a=jg(a.length,l.shape.length)),a=[a[0]],Ug("argMin",a,l.shape.length);const[c,h]=Wg(l.shape,a),d=Bo(xo(c),"int32"),p=xo(h),f=n.data.get(l.dataId).values;for(let g=0;g<d.length;++g){const e=g*p;let t=f[e],n=0;for(let s=0;s<p;++s){const r=f[e+s];r<t&&(t=r,n=s)}d[g]=n}return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(c,"int32",d)}},hE=d_(ul,(e=>Math.asin(e))),dE={kernelName:ul,backendName:"cpu",kernelFunc:hE},pE=d_(cl,(e=>Math.asinh(e))),fE={kernelName:cl,backendName:"cpu",kernelFunc:pE},gE=d_(hl,(e=>Math.atan(e))),mE={kernelName:hl,backendName:"cpu",kernelFunc:gE},bE=v_(((e,t)=>Math.atan2(e,t))),xE=B_(pl,bE),yE={kernelName:pl,backendName:"cpu",kernelFunc:xE},vE=d_(dl,(e=>Math.atanh(e))),wE={kernelName:dl,backendName:"cpu",kernelFunc:vE};function kE(e,t,n,s,r,i){const a=r.strideHeight,o=r.strideWidth,l=r.dilationHeight,u=r.dilationWidth,c=r.effectiveFilterHeight,h=r.effectiveFilterWidth,d=r.padInfo.top,p=r.padInfo.left,f="max"===i?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,g=Tp(r.outShape,n),m=g.values,b=r.outShape[1]*r.outShape[2]*r.outShape[3],x=r.outShape[2]*r.outShape[3],y=r.outShape[3];for(let v=0;v<r.batchSize;++v){const t=v*b,n=v*s[0];for(let g=0;g<r.inChannels;++g)for(let b=0;b<r.outHeight;++b){const v=b*a-d,w=Math.max(0,v),k=Math.min(r.inHeight,c+v),S=t+b*x;for(let t=0;t<r.outWidth;++t){const a=t*o-p,c=Math.max(0,a),d=Math.min(r.inWidth,h+a);let b=f,x=0,v=0;for(let t=w;t<k;t+=l){const r=n+t*s[1];for(let t=c;t<d;t+=u){const n=e[r+t*s[2]+g];"max"===i&&n>b?b=n:"avg"===i&&(x+=n,v++)}if(isNaN(b))break}m[S+t*y+g]="avg"===i?x/v:b}}}return g}function SE(e,t,n,s){let r=arguments.length>4&&void 0!==arguments[4]&&arguments[4],i=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const a=Tp(s.outShape,"int32"),o=s.strideHeight,l=s.strideWidth,u=s.dilationHeight,c=s.dilationWidth,h=s.effectiveFilterHeight,d=s.effectiveFilterWidth,p=s.padInfo.top,f=s.padInfo.left,g=Tp(t,n,e);for(let m=0;m<s.batchSize;++m)for(let e=0;e<s.inChannels;++e)for(let t=0;t<s.outHeight;++t){const n=t*o-p;let b=n;for(;b<0;)b+=u;const x=Math.min(s.inHeight,h+n);for(let o=0;o<s.outWidth;++o){const h=o*l-f;let p=h;for(;p<0;)p+=c;const y=Math.min(s.inWidth,d+h);let v=Number.NEGATIVE_INFINITY,w=-1;for(let t=b;t<x;t+=u){const a=t-n;for(let n=p;n<y;n+=c){const o=n-h,l=g.get(m,t,n,e);l>v&&(v=l,w=r?i?((m*s.inHeight+t)*s.inWidth+n)*s.inChannels+e:(t*s.inWidth+n)*s.inChannels+e:a*d+o)}}a.set(w,m,t,o,e)}}return a}function IE(e,t,n,s,r,i){const a=r.strideDepth,o=r.strideHeight,l=r.strideWidth,u=r.dilationDepth,c=r.dilationHeight,h=r.dilationWidth,d=r.effectiveFilterDepth,p=r.effectiveFilterHeight,f=r.effectiveFilterWidth,g=r.padInfo.front,m=r.padInfo.top,b=r.padInfo.left,x="max"===i?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,y=Tp(r.outShape,n),v=y.values,w=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],k=r.outShape[2]*r.outShape[3]*r.outShape[4],S=r.outShape[3]*r.outShape[4],I=r.outShape[4];for(let C=0;C<r.batchSize;++C){const t=C*w,n=C*s[0];for(let y=0;y<r.inChannels;++y)for(let w=0;w<r.outDepth;++w){const C=w*a-g;let N=C;for(;N<0;)N+=u;const T=Math.min(r.inDepth,d+C),_=t+w*k;for(let t=0;t<r.outHeight;++t){const a=t*o-m;let d=a;for(;d<0;)d+=c;const g=Math.min(r.inHeight,p+a),w=_+t*S;for(let t=0;t<r.outWidth;++t){const a=t*l-b;let o=a;for(;o<0;)o+=h;const p=Math.min(r.inWidth,f+a),m=w+t*I;let k=x,S=0,C=0;for(let t=N;t<T;t+=u){const r=n+t*s[1];for(let t=d;t<g;t+=c){const n=r+t*s[2];for(let t=o;t<p;t+=h){const r=e[n+t*s[3]+y];if("max"===i&&r>k?k=r:"avg"===i&&(S+=r,C++),isNaN(k))break}if(isNaN(k))break}if(isNaN(k))break}v[m+y]="avg"===i?S/Math.max(C,1):k}}}}return y}const CE={kernelName:fl,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t;l_(r,"avgPool");const{filterSize:i,strides:a,pad:o,dimRoundingMode:l}=s;go(qf(a,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '1'`));const u=zf(r.shape,i,a,1,o,l);let c;if(1===u.filterWidth&&1===u.filterHeight&&yo(u.inShape,u.outShape))c=m_({inputs:{x:r},backend:n});else{const e=n.data.get(r.dataId).values,t=Oo(r.shape),s=kE(e,r.shape,r.dtype,t,u,"avg");c=n.makeTensorInfo(u.outShape,r.dtype,s.values)}return c}};const NE={kernelName:ml,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{filterSize:i,strides:a,pad:o,dimRoundingMode:l,dataFormat:u}=s;l_(r,"avgPool3d");const c=Bf(r.shape,i,a,1,o,l,u),h=IE(n.data.get(r.dataId).values,r.shape,r.dtype,Oo(r.shape),c,"avg");return n.makeTensorInfo(h.shape,"float32",h.values)}};const TE={kernelName:bl,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,input:i}=t,{filterSize:a,strides:o,pad:l,dimRoundingMode:u}=s;l_([r,i],"avgPool3DGrad");const c=Bf(i.shape,a,o,1,l,u),h=c.strideDepth,d=c.strideHeight,p=c.strideWidth,f=c.filterDepth,g=c.filterHeight,m=c.filterWidth,b=c.dilationDepth,x=c.dilationHeight,y=c.dilationWidth,v=c.effectiveFilterDepth,w=c.effectiveFilterHeight,k=c.effectiveFilterWidth,S=v-1-c.padInfo.front,I=k-1-c.padInfo.left,C=w-1-c.padInfo.top,N=Tp(i.shape,"float32"),T=1/(f*g*m),_=n.bufferSync(r);for(let E=0;E<c.batchSize;++E)for(let e=0;e<c.inChannels;++e)for(let t=0;t<c.inDepth;++t)for(let n=0;n<c.inHeight;++n)for(let s=0;s<c.inWidth;++s){const r=t-S,i=n-C,a=s-I;let o=0;for(let t=0;t<v;t+=b){const n=(r+t)/h;if(!(n<0||n>=c.outDepth||Math.floor(n)!==n))for(let t=0;t<w;t+=x){const s=(i+t)/d;if(!(s<0||s>=c.outHeight||Math.floor(s)!==s))for(let t=0;t<k;t+=y){const r=(a+t)/p;if(r<0||r>=c.outWidth||Math.floor(r)!==r)continue;o+=_.get(E,n,s,r,e)}}}N.set(o*T,E,t,n,s,e)}return n.makeTensorInfo(N.shape,N.dtype,N.values)}};const _E={kernelName:gl,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,input:i}=t,a=i;l_([r,i],"avgPoolGrad");const{filterSize:o,strides:l,pad:u}=s,c=zf(a.shape,o,l,1,u),h=c.strideHeight,d=c.strideWidth,p=c.filterHeight,f=c.filterWidth,g=c.dilationHeight,m=c.dilationWidth,b=c.effectiveFilterHeight,x=c.effectiveFilterWidth,y=x-1-c.padInfo.left,v=b-1-c.padInfo.top,w=Tp(a.shape,"float32"),k=1/(p*f),S=n.data.get(r.dataId).values,I=Tp(r.shape,"float32",S);for(let C=0;C<c.batchSize;++C)for(let e=0;e<c.inChannels;++e)for(let t=0;t<c.inHeight;++t)for(let n=0;n<c.inWidth;++n){const s=t-v,r=n-y;let i=0;for(let t=0;t<b;t+=g){const n=(s+t)/h;if(!(n<0||n>=c.outHeight||Math.floor(n)!==n))for(let t=0;t<x;t+=m){const s=(r+t)/d;if(s<0||s>=c.outWidth||Math.floor(s)!==s)continue;i+=I.get(C,n,s,e)}}w.set(i*k,C,t,n,e)}return n.makeTensorInfo(w.shape,w.dtype,w.values)}};const EE={kernelName:cu,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,scale:i,offset:a,mean:o,variance:l}=t;go(o.shape.length===l.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),go(null==a||o.shape.length===a.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),go(null==i||o.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks.")),l_([r,o,l,i,a],"batchNorm");let{varianceEpsilon:u}=s;null==u&&(u=.001);const c=n.data.get(r.dataId).values,h=n.data.get(o.dataId).values,d=n.data.get(l.dataId).values,p=i?n.data.get(i.dataId).values:new Float32Array([1]),f=a?n.data.get(a.dataId).values:new Float32Array([0]),g=new Float32Array(c.length),m=f.length,b=p.length,x=d.length,y=h.length;let v=0,w=0,k=0,S=0;for(let I=0;I<c.length;++I)g[I]=f[v++]+(c[I]-h[w++])*p[k++]/Math.sqrt(d[S++]+u),v>=m&&(v=0),w>=y&&(w=0),k>=b&&(k=0),S>=x&&(S=0);return n.makeTensorInfo(r.shape,r.dtype,g)}};function $E(e,t,n,s,r){const i=$f(s,t,n),a=xo(n),o=Oo(s);if(i){const n=Rf(t,o);return"string"===r?e.slice(n,n+a):e.subarray(n,n+a)}const l=Tp(s,r,"string"===r?Zx(e):e),u=Tp(n,r);for(let c=0;c<u.size;++c){const e=u.indexToLoc(c),n=e.map(((e,n)=>e+t[n]));u.set(l.get(...n),...e)}return"string"===r?Jx(u.values):u.values}function RE(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{begin:i,size:a}=s;l_(r,"slice");const[o,l]=Af(r,i,a);xf(r,o,l);const u=$E(n.data.get(r.dataId).values,o,l,r.shape,r.dtype);return n.makeTensorInfo(l,r.dtype,u)}const AE={kernelName:Cc,backendName:"cpu",kernelFunc:RE};const DE={kernelName:yl,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{blockShape:i,crops:a}=s;l_([r],"batchToSpaceND");const o=i.reduce(((e,t)=>e*t)),l=tx(r.shape,i,o),u=nx(l.length,i.length),c=sx(r.shape,i,o),h=rx(a,i.length),d=ix(c,a,i.length),p=j_({inputs:{x:r},backend:n,attrs:{shape:l}}),f=iE({inputs:{x:p},backend:n,attrs:{perm:u}}),g=j_({inputs:{x:f},backend:n,attrs:{shape:c}}),m=RE({inputs:{x:g},backend:n,attrs:{begin:h,size:d}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),m}};function FE(e,t,n,s,r){const i=xo(s),a=Bo(r,n);for(let o=0;o<e.length;o++){const n=e[o];if(n<0)throw new Error("Input x must be non-negative!");n>=r||(a[n]+=i>0?t[o]:1)}return a}function ME(e,t,n){let s=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=e.shape[0],i=e.shape[1],a=Tp([r,n],t.dtype);for(let o=0;o<r;o++)for(let r=0;r<i;r++){const i=e.get(o,r);if(i<0)throw new Error("Input x must be non-negative!");i>=n||(s?a.set(1,o,i):t.size>0?a.set(a.get(o,i)+t.get(o,r),o,i):a.set(a.get(o,i)+1,o,i))}return a}const OE={kernelName:vl,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,weights:i}=t,{size:a}=s,o=FE(n.data.get(r.dataId).values,n.data.get(i.dataId).values,i.dtype,i.shape,a);return n.makeTensorInfo([a],i.dtype,o)}},LE=v_(((e,t)=>e&t)),PE={kernelName:wl,backendName:"cpu",kernelFunc:B_(wl,LE)};const zE={kernelName:kl,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:s,s1:r}=t,i=n.data.get(s.dataId).values,a=n.data.get(r.dataId).values,o=ef(Array.from(i),Array.from(a));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}},BE=h_((e=>Math.ceil(e))),WE=p_(Il,BE),VE={kernelName:Il,backendName:"cpu",kernelFunc:WE},UE=d_(Cl,((e,t)=>{const n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e})),GE={kernelName:Cl,backendName:"cpu",kernelFunc:UE},HE={kernelName:Tl,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend,s=new Float32Array(xo(t.shape)),r=n.data.get(t.dataId),i=r.complexTensorInfos.real,a=r.complexTensorInfos.imag,o=n.data.get(i.dataId).values,l=n.data.get(a.dataId).values;for(let u=0;u<o.length;u++){const e=o[u],t=l[u];s[u]=Math.hypot(e,t)}return n.makeOutput(s,t.shape,"float32")}};function jE(e,t,n,s){const r=_o(n,xo(t));if(s&&"string"!==n){let t=0;e.forEach((e=>{const n=xo(e.shape);r.set(e.vals,t),t+=n}))}else{let s=0;e.forEach((e=>{const i="string"===n?Zx(e.vals):e.vals;let a=0;for(let n=0;n<e.shape[0];++n){const o=n*t[1]+s;for(let t=0;t<e.shape[1];++t)r[o+t]=i[a++]}s+=e.shape[1]}))}return r}function KE(e){const{inputs:t,backend:n}=e,{input:s}=t,r=n.data.get(s.dataId).complexTensorInfos.imag,i=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,i)}const XE={kernelName:bu,backendName:"cpu",kernelFunc:KE};function qE(e){const{inputs:t,backend:n,attrs:s}=e,{axis:r}=s,i=Co(r,t[0].shape)[0];Hb(t.map((e=>e.shape)),i);let a=jb(t.map((e=>e.shape)),i);if(0===xo(a))return n.makeTensorInfo(a,t[0].dtype,[]);const o=t.filter((e=>xo(e.shape)>0));if(1===o.length)return m_({inputs:{x:o[0]},backend:n});if("complex64"===o[0].dtype){const e=o.map((e=>M_({inputs:{input:e},backend:n}))),t=o.map((e=>KE({inputs:{input:e},backend:n}))),s=qE({inputs:e,backend:n,attrs:{axis:i}}),r=qE({inputs:t,backend:n,attrs:{axis:i}}),a=A_({inputs:{real:s,imag:r},backend:n});return e.forEach((e=>n.disposeIntermediateTensorInfo(e))),t.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(r),a}const l=o.map((e=>{const t=xo(e.shape.slice(i));return j_({inputs:{x:e},backend:n,attrs:{shape:[-1,t]}})})),u=l.map((e=>({vals:n.data.get(e.dataId).values,shape:e.shape})));a=jb(l.map((e=>e.shape)),1);const c=1===l[0].shape[0],h=jE(u,a,t[0].dtype,c),d=jb(o.map((e=>e.shape)),i),p=n.makeTensorInfo(d,t[0].dtype,h);return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),p}const YE={kernelName:_l,backendName:"cpu",kernelFunc:qE};function QE(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,filter:i}=t,{strides:a,pad:o,dataFormat:l,dilations:u,dimRoundingMode:c}=s;l_([r,i],"conv2d");const h=Qf(l),d=Wf(r.shape,i.shape,a,u,o,c,!1,h),p=d.filterHeight,f=d.filterWidth,g=d.dilationHeight,m=d.dilationWidth,b=d.padInfo.left,x=d.padInfo.top,y="channelsLast"===d.dataFormat,v=new Qh(d.outShape,r.dtype),w=Oo(r.shape),k=Oo(i.shape),S=w[0],I=y?w[1]:w[2],C=y?w[2]:1,N=y?1:w[1],T=v.strides[0],_=y?v.strides[1]:v.strides[2],E=y?v.strides[2]:1,$=y?1:v.strides[1],R=n.data.get(r.dataId).values,A=n.data.get(i.dataId).values,D=v.values;for(let F=0;F<d.batchSize;++F){const e=F*S,t=F*T;for(let n=0;n<d.outHeight;++n){const s=t+n*_,r=n*d.strideHeight-x;for(let t=0;t<p;++t){const n=r+t*g;if(n<0||n>=d.inHeight)continue;const i=t*k[0],a=e+n*I;for(let e=0;e<d.outWidth;++e){const t=s+e*E,n=e*d.strideWidth-b;for(let e=0;e<f;++e){const s=n+e*m;if(s<0||s>=d.inWidth)continue;const r=a+s*C;let o=i+e*k[1];for(let e=0;e<d.inChannels;++e){const n=R[r+e*N];for(let e=0;e<d.outChannels;++e)D[t+e*$]+=n*A[o+e];o+=d.outChannels}}}}}}return n.makeTensorInfo(v.shape,v.dtype,D)}const ZE={kernelName:El,backendName:"cpu",kernelFunc:QE};const JE={kernelName:$l,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,dy:i}=t,{strides:a,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=s;l_([r,i],"conv2dBackpropFilter");const h=Qf(l),d=Wf(r.shape,c,a,1,o,u,!1,h),{strideHeight:p,strideWidth:f,filterHeight:g,filterWidth:m}=d,b="channelsLast"===d.dataFormat,x=new Qh(d.filterShape,"float32"),y=d.padInfo.left,v=d.padInfo.top,w=n.data.get(r.dataId).values,k=n.data.get(i.dataId).values,S=new Qh(r.shape,r.dtype,w),I=new Qh(i.shape,i.dtype,k);for(let C=0;C<g;++C){const e=Math.max(0,Math.ceil((v-C)/p)),t=Math.min(d.outHeight,(d.inHeight+v-C)/p);for(let n=0;n<m;++n){const s=Math.max(0,Math.ceil((y-n)/f)),r=Math.min(d.outWidth,(d.inWidth+y-n)/f);for(let i=0;i<d.inChannels;++i)for(let a=0;a<d.outChannels;++a){let o=0;for(let l=0;l<d.batchSize;++l)for(let u=e;u<t;++u){const e=C+u*p-v;for(let t=s;t<r;++t){const s=n+t*f-y;o+=b?S.get(l,e,s,i)*I.get(l,u,t,a):S.get(l,i,e,s)*I.get(l,a,u,t)}}x.set(o,C,n,i,a)}}}return n.makeTensorInfo(x.shape,x.dtype,x.values)}};const e$={kernelName:Rl,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,filter:i}=t,{inputShape:a,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=s;l_([r,i],"conv2dBackpropInput");const h=Oo(i.shape),d=Oo(r.shape);let p=Qf(u);const f=Wf(a,i.shape,o,1,l,c,!1,p),g=new Qh(f.inShape,"float32"),m=g.values,b=n.data.get(r.dataId).values,x=n.data.get(i.dataId).values,[y,v,w]=h,{batchSize:k,filterHeight:S,filterWidth:I,inChannels:C,inHeight:N,inWidth:T,outChannels:_,outHeight:E,outWidth:$,strideHeight:R,strideWidth:A}=f;p=f.dataFormat;const D=S-1-f.padInfo.top,F=I-1-f.padInfo.left,M="channelsLast"===p,O=g.strides[0],L=M?g.strides[1]:g.strides[2],P=M?g.strides[2]:1,z=M?1:g.strides[1],B=d[0],W=M?d[1]:d[2],V=M?d[2]:1,U=M?1:d[1];for(let G=0;G<k;++G)for(let e=0;e<C;++e)for(let t=0;t<N;++t){const n=t-D,s=Math.max(0,Math.ceil(n/R)),r=Math.min(E,(S+n)/R);for(let i=0;i<T;++i){const a=i-F,o=Math.max(0,Math.ceil(a/A)),l=Math.min($,(I+a)/A);let u=0;for(let t=s;t<r;++t){const s=t*R-n;for(let n=o;n<l;++n){const r=B*G+W*t+V*n,i=y*(S-1-s)+v*(I-1-(n*A-a))+w*e;for(let e=0;e<_;++e){u+=b[r+U*e]*x[i+e]}}}m[O*G+L*t+P*i+z*e]=u}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}};const t$={kernelName:Al,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,filter:i}=t,{strides:a,pad:o,dilations:l}=s;l_([r,i],"conv3d");const u=Vf(r.shape,i.shape,a,l,o),{filterDepth:c,filterHeight:h,filterWidth:d,dilationDepth:p,dilationHeight:f,dilationWidth:g,padInfo:m}=u,b=m.front,x=m.left,y=m.top,v=new Qh(u.outShape,r.dtype),w=n.data.get(r.dataId).values,k=n.data.get(i.dataId).values,S=v.values,I=Oo(r.shape),C=Oo(i.shape);for(let N=0;N<u.batchSize;++N){const e=N*I[0],t=N*v.strides[0];for(let n=0;n<u.outDepth;++n){const s=t+n*v.strides[1],r=n*u.strideDepth-b;for(let t=0;t<c;++t){const n=r+t*p;if(n<0||n>=u.inDepth)continue;const i=t*C[0],a=e+n*I[1];for(let e=0;e<u.outHeight;++e){const t=s+e*v.strides[2],n=e*u.strideHeight-y;for(let e=0;e<h;++e){const s=n+e*f;if(s<0||s>=u.inHeight)continue;const r=i+e*C[1],o=a+s*I[2];for(let e=0;e<u.outWidth;++e){const n=t+e*u.outChannels,s=e*u.strideWidth-x;for(let e=0;e<d;++e){const t=s+e*g;if(t<0||t>=u.inWidth)continue;const i=r+e*C[2],a=o+t*u.inChannels;let l=i;for(let e=0;e<u.inChannels;++e){const t=w[a+e];for(let e=0;e<u.outChannels;++e)S[n+e]+=t*k[l+e];l+=u.outChannels}}}}}}}}return n.makeTensorInfo(v.shape,v.dtype,v.values)}};const n$={kernelName:Dl,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,dy:i}=t,{strides:a,pad:o,filterShape:l}=s;l_([r,i],"conv3dBackpropFilterV2");const u=Oo(r.shape),c=Oo(i.shape),h=Vf(r.shape,l,a,1,o),d=h.strideDepth,p=h.strideHeight,f=h.strideWidth,g=h.filterDepth,m=h.filterHeight,b=h.filterWidth,x=new Qh(h.filterShape,"float32"),y=x.values,[v,w,k,S]=x.strides,I=n.data.get(i.dataId).values,[C,N,T,_]=c,E=n.data.get(r.dataId).values,[$,R,A,D]=u,F=h.padInfo.front,M=h.padInfo.left,O=h.padInfo.top;for(let L=0;L<g;++L){const e=Math.max(0,Math.ceil((F-L)/d)),t=Math.min(h.outDepth,(h.inDepth+F-L)/d),n=L*v;for(let s=0;s<m;++s){const r=Math.max(0,Math.ceil((O-s)/p)),i=Math.min(h.outHeight,(h.inHeight+O-s)/p),a=s*w+n;for(let n=0;n<b;++n){const o=Math.max(0,Math.ceil((M-n)/f)),l=Math.min(h.outWidth,(h.inWidth+M-n)/f),u=n*k+a;for(let a=0;a<h.inChannels;++a){const c=a*S+u;for(let u=0;u<h.outChannels;++u){let g=0;for(let c=0;c<h.batchSize;++c){const h=c*$,m=c*C;for(let c=e;c<t;++c){const e=(L+c*d-F)*R+h,t=c*N+m;for(let c=r;c<i;++c){const r=(s+c*p-O)*A+e,i=c*T+t;for(let e=o;e<l;++e){const t=e*_+i;g+=E[(n+e*f-M)*D+r+a]*I[t+u]}}}}y[c+u]=g}}}}}return n.makeTensorInfo(x.shape,x.dtype,x.values)}};const s$={kernelName:Fl,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,filter:i}=t,{pad:a,strides:o,inputShape:l}=s;l_([r],"conv3dBackpropInputV2");const u=Oo(r.shape),c=Oo(i.shape),h=Vf(l,i.shape,o,1,a),d=new Qh(h.inShape,"float32"),p=d.values,[f,g,m,b]=d.strides,x=n.data.get(r.dataId).values,[y,v,w,k]=u,S=n.data.get(i.dataId).values,[I,C,N,T]=c,{batchSize:_,filterDepth:E,filterHeight:$,filterWidth:R,inChannels:A,inDepth:D,inHeight:F,inWidth:M,outChannels:O,outDepth:L,outHeight:P,outWidth:z,strideDepth:B,strideHeight:W,strideWidth:V}=h,U=E-1-h.padInfo.front,G=$-1-h.padInfo.top,H=R-1-h.padInfo.left;for(let j=0;j<_;++j)for(let e=0;e<A;++e)for(let t=0;t<D;++t){const n=t-U,s=Math.max(0,Math.ceil(n/B)),r=Math.min(L,(E+n)/B);for(let i=0;i<F;++i){const a=i-G,o=Math.max(0,Math.ceil(a/W)),l=Math.min(P,($+a)/W);for(let u=0;u<M;++u){const c=u-H,h=Math.max(0,Math.ceil(c/V)),d=Math.min(z,(R+c)/V);let _=0;for(let t=s;t<r;++t){const s=t*B-n;for(let n=o;n<l;++n){const r=n*W-a;for(let i=h;i<d;++i){const a=y*j+v*t+w*n+k*i,o=I*(E-1-s)+C*($-1-r)+N*(R-1-(i*V-c))+T*e;for(let e=0;e<O;++e){_+=x[a+e]*S[o+e]}}}}p[f*j+g*t+m*i+b*u+e]=_}}}return n.makeTensorInfo(d.shape,d.dtype,d.values)}},r$=d_(Ml,(e=>Math.cos(e))),i$={kernelName:Ml,backendName:"cpu",kernelFunc:r$},a$=d_(Ol,(e=>Math.cosh(e))),o$={kernelName:Ol,backendName:"cpu",kernelFunc:a$};const l$={kernelName:zl,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{image:r,boxes:i,boxInd:a}=t,{cropSize:o,method:l,extrapolationValue:u}=s,[c,h,d,p]=r.shape,f=i.shape[0],[g,m]=o,b=Tp([f,g,m,p],"float32"),x=n.data.get(i.dataId).values,y=n.data.get(a.dataId).values,v=n.data.get(r.dataId).values,w=Oo(r.shape),k=Oo(b.shape);for(let S=0;S<f;S++){const e=4*S,t=x[e],n=x[e+1],s=x[e+2],r=x[e+3],i=y[S];if(i>=c)continue;const a=g>1?(s-t)*(h-1)/(g-1):0,o=m>1?(r-n)*(d-1)/(m-1):0;for(let c=0;c<g;c++){const e=g>1?t*(h-1)+c*a:.5*(t+s)*(h-1);if(e<0||e>h-1)for(let t=0;t<m;t++)for(let e=0;e<p;e++){const n=e+t*k[2]+c*k[1]+S*k[0];b.values[n]=u}else if("bilinear"===l){const t=Math.floor(e),s=Math.ceil(e),a=e-t;for(let e=0;e<m;e++){const l=m>1?n*(d-1)+e*o:.5*(n+r)*(d-1);if(l<0||l>d-1){for(let t=0;t<p;t++){const n=t+e*k[2]+c*k[1]+S*k[0];b.values[n]=u}continue}const h=Math.floor(l),f=Math.ceil(l),g=l-h;for(let n=0;n<p;n++){let r=n+h*w[2]+t*w[1]+i*w[0];const o=v[r];r=n+f*w[2]+t*w[1]+i*w[0];const l=v[r];r=n+h*w[2]+s*w[1]+i*w[0];const u=v[r];r=n+f*w[2]+s*w[1]+i*w[0];const d=o+(l-o)*g,p=u+(v[r]-u)*g;r=n+e*k[2]+c*k[1]+S*k[0],b.values[r]=d+(p-d)*a}}}else for(let t=0;t<m;++t){const s=m>1?n*(d-1)+t*o:.5*(n+r)*(d-1);if(s<0||s>d-1){for(let e=0;e<p;e++){const n=e+t*k[2]+c*k[1]+S*k[0];b.values[n]=u}continue}const a=Math.round(s),l=Math.round(e);for(let e=0;e<p;e++){const n=e+a*w[2]+l*w[1]+i*w[0],s=e+t*k[2]+c*k[1]+S*k[0];b.values[s]=v[n]}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}};const u$={kernelName:Ll,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:i,exclusive:a,reverse:o}=s;l_(r,"cumprod");const l=Gg([i],r.shape.length);let u=r;null!=l&&(u=iE({inputs:{x:r},backend:n,attrs:{perm:l}}));const c=jg(1,r.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const h=cd(u.dtype,"int32"),d=zo(xo(u.shape),h),p=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],g=o?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let b=0;b<p.length;b+=f)for(let e=0;e<f;e++){const t=g(b,e);if(0===e)d[t]=a?1:p[t];else{const n=g(b,e-1);d[t]=a?p[n]*d[n]:p[t]*d[n]}}const m=n.makeTensorInfo(u.shape,h,d);if(null!=l){const e=iE({inputs:{x:m},backend:n,attrs:{perm:Hg(l)}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(u),e}return m}};const c$={kernelName:Pl,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:i,exclusive:a,reverse:o}=s;l_(r,"cumsum");const l=Gg([i],r.shape.length);let u=r;null!=l&&(u=iE({inputs:{x:r},backend:n,attrs:{perm:l}}));const c=jg(1,r.shape.length)[0];if(c!==u.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${u.shape.length-1} but got axis=${c}`);const h=cd(u.dtype,"int32"),d=Bo(xo(u.shape),h),p=n.data.get(u.dataId).values,f=u.shape[u.shape.length-1],g=o?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let b=0;b<p.length;b+=f)for(let e=0;e<f;e++){const t=g(b,e);if(0===e)d[t]=a?0:p[t];else{const n=g(b,e-1);d[t]=a?p[n]+d[n]:p[t]+d[n]}}const m=n.makeTensorInfo(u.shape,h,d);if(null!=l){const e=iE({inputs:{x:m},backend:n,attrs:{perm:Hg(l)}});return n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(u),e}return m}};const h$={kernelName:Bl,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,weights:i}=t,{size:a,binaryOutput:o}=s;if(1===r.shape.length){const e=FE(n.data.get(r.dataId).values,n.data.get(i.dataId).values,i.dtype,i.shape,a);return n.makeTensorInfo([a],i.dtype,e)}if(2===r.shape.length){const e=ME(n.bufferSync(r),n.bufferSync(i),a,o);return n.makeTensorInfo(e.shape,i.dtype,e.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}};const d$={kernelName:Wl,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{blockSize:i,dataFormat:a}=s;go("NHWC"===a,(()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${a}`));const o=r.shape[0],l=r.shape[1],u=r.shape[2],c=r.shape[3],h=l*i,d=u*i,p=c/(i*i),f=n.data.get(r.dataId).values,g=new Float32Array(o*h*d*p);let m=0;for(let b=0;b<o;++b)for(let e=0;e<h;++e){const t=Math.floor(e/i),n=e%i;for(let e=0;e<d;++e){const s=Math.floor(e/i),r=(n*i+e%i)*p;for(let e=0;e<p;++e){const n=e+r+c*(s+u*(t+l*b));g[m++]=f[n]}}}return n.makeTensorInfo([o,h,d,p],r.dtype,g)}};function p$(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,filter:i}=t,{strides:a,pad:o,dilations:l,dimRoundingMode:u}=s;l_([r,i],"depthwiseConv2DNative");const c=Oo(r.shape),h=Oo(i.shape);let d=l;null==d&&(d=[1,1]),go(qf(a,d),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${d}'`));const p=Wf(r.shape,i.shape,a,d,o,u,!0),{filterHeight:f,filterWidth:g,dilationHeight:m,dilationWidth:b,padInfo:x}=p,y=x.left,v=x.top,w=p.outChannels/p.inChannels,k=new Qh(p.outShape,r.dtype),S=n.data.get(r.dataId).values,I=n.data.get(i.dataId).values,C=k.values;for(let N=0;N<p.batchSize;++N){const e=N*c[0],t=N*k.strides[0];for(let n=0;n<p.outHeight;++n){const s=t+n*k.strides[1],r=n*p.strideHeight-v;for(let t=0;t<f;++t){const n=r+t*m;if(n<0||n>=p.inHeight)continue;const i=t*h[0],a=e+n*c[1];for(let e=0;e<p.outWidth;++e){const t=s+e*k.strides[2],n=e*p.strideWidth-y;for(let e=0;e<g;++e){const s=n+e*b;if(s<0||s>=p.inWidth)continue;const r=i+e*h[1],o=a+s*p.inChannels;let l=t,u=r;for(let e=0;e<p.inChannels;++e){const t=S[o+e];for(let e=0;e<w;++e)C[l+e]+=t*I[u+e];l+=w,u+=w}}}}}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}const f$={kernelName:Vl,backendName:"cpu",kernelFunc:p$};const g$={kernelName:Ul,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,dy:i}=t,{strides:a,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=s;l_([r,i],"depthwiseConv2dNativeBackpropFilter");const h=Wf(r.shape,c,a,o,l,u,!0),{strideHeight:d,strideWidth:p,filterHeight:f,filterWidth:g}=h,m=new Qh(h.filterShape,"float32"),b=h.padInfo.left,x=h.padInfo.top,y=h.outChannels/h.inChannels,v=n.data.get(r.dataId).values,w=new Qh(r.shape,r.dtype,v),k=n.data.get(i.dataId).values,S=new Qh(i.shape,i.dtype,k);for(let I=0;I<f;++I){const e=Math.max(0,Math.ceil((x-I)/d)),t=Math.min(h.outHeight,(h.inHeight+x-I)/d);for(let n=0;n<g;++n){const s=Math.max(0,Math.ceil((b-n)/p)),r=Math.min(h.outWidth,(h.inWidth+b-n)/p);for(let i=0;i<h.outChannels;++i){const a=Math.trunc(i/y),o=i%y;let l=0;for(let u=0;u<h.batchSize;++u)for(let o=e;o<t;++o){const e=I+o*d-x;for(let t=s;t<r;++t){const s=n+t*p-b;l+=w.get(u,e,s,a)*S.get(u,o,t,i)}}m.set(l,I,n,a,o)}}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}};const m$={kernelName:Gl,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,filter:i}=t,{strides:a,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=s;l_([r,i],"depthwiseConv2DNativeBackpropInput");const h=Oo(r.shape),d=Oo(i.shape),p=Wf(c,i.shape,a,o,l,u,!0),f=new Qh(p.inShape,"float32"),g=f.values,[m,b,x]=f.strides,y=n.data.get(r.dataId).values,[v,w,k]=h,S=n.data.get(i.dataId).values,[I,C,N]=d,{batchSize:T,filterHeight:_,filterWidth:E,inChannels:$,inHeight:R,inWidth:A,outChannels:D,outHeight:F,outWidth:M,strideHeight:O,strideWidth:L}=p,P=_-1-p.padInfo.top,z=E-1-p.padInfo.left,B=D/$;for(let W=0;W<T;++W)for(let e=0;e<$;++e)for(let t=0;t<R;++t){const n=t-P,s=Math.max(0,Math.ceil(n/O)),r=Math.min(F,(_+n)/O);for(let i=0;i<A;++i){const a=i-z,o=Math.max(0,Math.ceil(a/L)),l=Math.min(M,(E+a)/L);let u=0;for(let t=s;t<r;++t){const s=t*O-n;for(let n=o;n<l;++n){const r=v*W+w*t+k*n,i=I*(_-1-s)+C*(E-1-(n*L-a))+N*e;for(let t=0;t<B;++t){u+=y[r+(e*B+t)]*S[i+t]}}}g[m*W+b*t+x*i+e]=u}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}};const b$={kernelName:Hl,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:s}=t,r=xo(s.shape),i=n.data.get(s.dataId).values,a=Tp([r,r],s.dtype),o=a.values;for(let u=0;u<i.length;u++)o[u*r+u]=i[u];const l=[...s.shape,...s.shape];return n.makeTensorInfo(l,a.dtype,a.values)}},x$={kernelName:jl,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:s}=e;const{x:r,filter:i}=t,{strides:a,pad:o,dilations:l}=s,u=n,c=u.data.get(r.dataId).values,h=r.shape.length,d=u.data.get(i.dataId).values,p=i.shape.length,{batchSize:f,inHeight:g,inWidth:m,inChannels:b,outHeight:x,outWidth:y,padInfo:v,strideHeight:w,strideWidth:k,filterHeight:S,filterWidth:I,dilationHeight:C,dilationWidth:N,outShape:T}=Pf(r.shape,i.shape,a,o,"NHWC",l),_=xo(T),E=T.length,$=_o(r.dtype,_);for(let R=0;R<f;++R)for(let e=0;e<x;++e){const t=e*w-v.top;for(let n=0;n<y;++n){const s=n*k-v.left;for(let a=0;a<b;++a){let o=Number.MIN_SAFE_INTEGER;for(let e=0;e<S;++e){const n=t+e*C;if(n>=0&&n<g)for(let t=0;t<I;++t){const l=s+t*N;if(l>=0&&l<m){const s=Uo([R,n,l,a],h,Oo(r.shape)),u=Uo([e,t,a],p,Oo(i.shape)),f=c[s]+d[u];f>o&&(o=f)}}}$[Uo([R,e,n,a],E,Oo(T))]=o}}}return{dataId:u.write(Lh($,r.dtype),T,r.dtype),shape:T,dtype:r.dtype}}},y$={kernelName:Xl,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:s}=e;const{x:r,filter:i,dy:a}=t,{strides:o,pad:l,dilations:u}=s,c=n,h=Po(r.shape,c.data.get(r.dataId).values),d=Po(i.shape,c.data.get(i.dataId).values),{batchSize:p,inHeight:f,inWidth:g,inChannels:m,outHeight:b,outWidth:x,padInfo:y,strideHeight:v,strideWidth:w,filterHeight:k,filterWidth:S,dilationHeight:I,dilationWidth:C,outShape:N}=Pf(r.shape,i.shape,o,l,"NHWC",u);go(a.rank===N.length,(()=>`Error in ${Xl}, dy must have the same rank as output ${N.length}, but got ${a.rank}`));const T=Po(N,c.data.get(a.dataId).values),_=Wo(i.shape,i.dtype);for(let E=0;E<p;++E)for(let e=0;e<b;++e){const t=e*v-y.top;for(let n=0;n<x;++n){const s=n*w-y.left;for(let r=0;r<m;++r){let i=Number.MIN_SAFE_INTEGER,a=0,o=0;for(let e=0;e<k;++e){const n=t+e*I;if(n>=0&&n<f)for(let t=0;t<S;++t){const l=s+t*C;if(l>=0&&l<g){const s=h[E][n][l][r]+d[e][t][r];s>i&&(i=s,a=e,o=t)}}}_[a][o][r]+=T[E][e][n][r]}}}return{dataId:c.write(Lh(_,r.dtype),i.shape,i.dtype),shape:i.shape,dtype:i.dtype}}},v$={kernelName:Kl,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:s}=e;const{x:r,filter:i,dy:a}=t,{strides:o,pad:l,dilations:u}=s,c=n,h=Po(r.shape,c.data.get(r.dataId).values),d=Po(i.shape,c.data.get(i.dataId).values),{batchSize:p,inHeight:f,inWidth:g,inChannels:m,outHeight:b,outWidth:x,padInfo:y,strideHeight:v,strideWidth:w,filterHeight:k,filterWidth:S,dilationHeight:I,dilationWidth:C,outShape:N}=Pf(r.shape,i.shape,o,l,"NHWC",u);go(a.rank===N.length,(()=>`Error in ${Kl}, dy must have the same rank as output ${N.length}, but got ${a.rank}`));const T=Po(N,c.data.get(a.dataId).values),_=Wo(r.shape,r.dtype);for(let E=0;E<p;++E)for(let e=0;e<b;++e){const t=e*v-y.top;for(let n=0;n<x;++n){const s=n*w-y.left;for(let r=0;r<m;++r){let i=Number.MIN_SAFE_INTEGER,a=t<0?0:t,o=s<0?0:s;for(let e=0;e<k;++e){const n=t+e*I;if(n>=0&&n<f)for(let t=0;t<S;++t){const l=s+t*C;if(l>=0&&l<g){const s=h[E][n][l][r]+d[e][t][r];s>i&&(i=s,a=n,o=l)}}}_[E][a][o][r]+=T[E][e][n][r]}}}return{dataId:c.write(Lh(_,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};const w$={kernelName:ql,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{image:r}=t,{canvas:i,options:a}=s,{contextOptions:o,imageOptions:l}=a||{},u=(null===l||void 0===l?void 0:l.alpha)||1,c=(null===o||void 0===o?void 0:o.contextType)||"2d";if("2d"!==c)throw new Error(`Context type ${o.contextType} is not supported by the CPU backend.`);const h=i.getContext(c,(null===o||void 0===o?void 0:o.contextAttributes)||{});if(null==h)throw new Error(`Could not get the context with ${c} type.`);const[d,p]=r.shape.slice(0,2),f=2===r.shape.length?1:r.shape[2],g=n.data.get(r.dataId).values,m="float32"===r.dtype?255:1,b=new Uint8ClampedArray(p*d*4);for(let y=0;y<d*p;++y){const e=[0,0,0,255*u];for(let n=0;n<f;n++){const t=g[y*f+n];if("float32"===r.dtype){if(t<0||t>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${t}.`)}else if("int32"===r.dtype&&(t<0||t>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${t}.`);1===f?(e[0]=t*m,e[1]=t*m,e[2]=t*m):e[n]=t*m}const t=4*y;b[t+0]=Math.round(e[0]),b[t+1]=Math.round(e[1]),b[t+2]=Math.round(e[2]),b[t+3]=Math.round(e[3])}i.width=p,i.height=d;const x=new ImageData(b,p,d);return h.putImageData(x,0,0),r}},k$=v_(((e,t)=>e*t)),S$=W_(((e,t,n,s)=>({real:e*n-t*s,imag:e*s+t*n}))),I$=B_(Hu,k$,S$),C$={kernelName:Hu,backendName:"cpu",kernelFunc:I$};function N$(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:i,keepDims:a}=s;let o;l_(r,"sum"),o="bool"===r.dtype?P_({inputs:{x:r},backend:n,attrs:{dtype:"int32"}}):m_({inputs:{x:r},backend:n});const l=o.shape.length,u=Co(i,o.shape),c=Gg(u,l);let h=u,d=o;null!=c&&(d=iE({inputs:{x:o},backend:n,attrs:{perm:c}}),h=jg(h.length,l)),Ug("sum",h,d.shape.length);const[p,f]=Wg(d.shape,h);let g=F_(n,p,cd(d.dtype,"int32"));const m=xo(f),b=n.data.get(g.dataId).values,x=n.data.get(d.dataId).values;for(let y=0;y<b.length;++y){const e=y*m;let t=0;for(let n=0;n<m;++n)t+=x[e+n];b[y]=t}if(a){const e=g;g=j_({inputs:{x:g},backend:n,attrs:{shape:Vg(g.shape,u)}}),n.disposeIntermediateTensorInfo(e)}return n.disposeIntermediateTensorInfo(o),null!=c&&n.disposeIntermediateTensorInfo(d),g}const T$={kernelName:Ac,backendName:"cpu",kernelFunc:N$};const _$={kernelName:Ql,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{equation:r}=s,i=t,{allDims:a,summedDims:o,idDims:l}=$x(r,i.length);Ax(a.length,l,i);const{path:u,steps:c}=Dx(o,l),h=c.length;let d=null,p=a.length;const f=[];for(let g=0;g<h;++g){for(const e of c[g]){const{permutationIndices:t,expandDims:s}=Rx(p,l[e]);let r;Fx(t)?r=i[e]:(r=iE({inputs:{x:i[e]},backend:n,attrs:{perm:t}}),f.push(r));const a=r.shape.slice();for(let e=0;e<s.length;++e)a.splice(s[e],0,1);yo(r.shape,a)||(r=j_({inputs:{x:r},backend:n,attrs:{shape:a}}),f.push(r)),null===d?d=r:(d=I$({inputs:{a:r,b:d},backend:n}),f.push(d))}g<h-1&&(u[g]>=0&&(d=N$({inputs:{x:d},backend:n,attrs:{axis:u[g]-(a.length-p),keepDims:!1}}),f.push(d)),p--)}for(const g of f)g!==d&&n.disposeIntermediateTensorInfo(g);return d}};const E$={kernelName:Jl,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{dy:s,y:r}=t;l_([s,r],"eluGrad");const i=new Float32Array(xo(r.shape)),a=n.data.get(r.dataId).values,o=n.data.get(s.dataId).values;for(let l=0;l<a.length;++l){const e=a[l];i[l]=e>=0?o[l]:o[l]*(e+1)}return n.makeTensorInfo(r.shape,"float32",i)}},$$=v_(((e,t)=>e===t?1:0)),R$=B_(tu,$$,null,"bool"),A$={kernelName:tu,backendName:"cpu",kernelFunc:R$},D$=dx,F$=px,M$=fx,O$=gx,L$=mx,P$=bx,z$=d_(eu,(e=>{const t=Math.sign(e),n=Math.abs(e),s=1/(1+D$*n);return t*(1-((((P$*s+L$)*s+O$)*s+M$)*s+F$)*s*Math.exp(-n*n))})),B$={kernelName:eu,backendName:"cpu",kernelFunc:z$},W$=h_((e=>Math.exp(e))),V$=p_(nu,W$,"float32"),U$={kernelName:nu,backendName:"cpu",kernelFunc:V$};function G$(e){const{inputs:t,backend:n,attrs:s}=e,{input:r}=t,{dim:i}=s,a=r.shape.length,o=r.shape.slice();let l=i;return i<0&&(go(-(a+1)<=i,(()=>`Axis must be in the interval [${-(a+1)}, ${a}]`)),l=a+i+1),o.splice(l,0,1),j_({inputs:{x:r},backend:n,attrs:{shape:o}})}const H$={kernelName:su,backendName:"cpu",kernelFunc:G$},j$=h_((e=>Math.expm1(e))),K$=p_(ru,j$),X$={kernelName:ru,backendName:"cpu",kernelFunc:K$},q$=v_(((e,t)=>e/t)),Y$=B_(Yl,q$),Q$={kernelName:Yl,backendName:"cpu",kernelFunc:Y$},Z$=v_(((e,t)=>e-t)),J$=W_(((e,t,n,s)=>({real:e-n,imag:t-s}))),eR=B_(Xc,Z$,J$),tR={kernelName:Xc,backendName:"cpu",kernelFunc:eR};function nR(e,t,n){const s=e.shape,r=s[0],i=s[1],a=n.data.get(e.dataId),o=a.complexTensorInfos.real,l=a.complexTensorInfos.imag,u=[r,i],c=xo(u),h=To("float32",c),d=To("float32",c);for(let m=0;m<r;m++){const e=RE({inputs:{x:o},backend:n,attrs:{begin:[m,0],size:[1,i]}}),s=RE({inputs:{x:l},backend:n,attrs:{begin:[m,0],size:[1,i]}}),r=A_({inputs:{real:e,imag:s},backend:n}),{real:a,imag:u}=sR(r,t,n),c=xx(a,u);for(let t=0;t<i;t++){const e=kx(c,t);h[m*i+t]=e.real,d[m*i+t]=e.imag}n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(r)}const p=n.makeTensorInfo(u,"float32",h),f=n.makeTensorInfo(u,"float32",d),g=A_({inputs:{real:p,imag:f},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),g}function sR(e,t,n){const s=xo(e.shape),r=n.data.get(e.dataId),i=n.data.get(r.complexTensorInfos.real.dataId).values,a=n.data.get(r.complexTensorInfos.imag.dataId).values;if(0===((o=s)&o-1)){const r=rR(i,a,s,t,n),o=[e.shape[0],e.shape[1]];if(t){const e=n.makeTensorInfo(o,"float32",r.real),t=n.makeTensorInfo(o,"float32",r.imag),i=n.makeTensorInfo([],"float32",Oh(s,"float32")),a=m_({inputs:{x:i},backend:n}),l=Q$.kernelFunc({inputs:{a:e,b:i},backend:n}),u=Q$.kernelFunc({inputs:{a:t,b:a},backend:n}),c=n.data.get(l.dataId).values,h=n.data.get(u.dataId).values;return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),{real:c,imag:h}}return r}{const e=function(e,t,n){const s=new Float32Array(2*t);for(let r=0;r<t;r++){let i=0,a=0;for(let s=0;s<t;s++){const o=Cx(r*s,t,n),l=kx(e,s);i+=l.real*o.real-l.imag*o.imag,a+=l.real*o.imag+l.imag*o.real}n&&(i/=t,a/=t),Sx(s,i,a,r)}return s}(xx(i,a),s,t);return yx(e)}var o}function rR(e,t,n,s,r){if(1===n)return{real:e,imag:t};const i=xx(e,t),a=n/2,o=vx(i),l=o.real,u=o.imag,c=[l.length],h=r.makeTensorInfo(c,"float32",l),d=r.makeTensorInfo(c,"float32",u),p=A_({inputs:{real:h,imag:d},backend:r}),f=wx(i),g=f.real,m=f.imag,b=[g.length],x=r.makeTensorInfo(b,"float32",g),y=r.makeTensorInfo(b,"float32",m),v=A_({inputs:{real:x,imag:y},backend:r}),w=rR(l,u,a,s,r),k=w.real,S=w.imag,I=[k.length],C=r.makeTensorInfo(I,"float32",k),N=r.makeTensorInfo(I,"float32",S),T=A_({inputs:{real:C,imag:N},backend:r}),_=rR(g,m,a,s,r),E=_.real,$=_.imag,R=[E.length],A=r.makeTensorInfo(R,"float32",E),D=r.makeTensorInfo(R,"float32",$),F=A_({inputs:{real:A,imag:D},backend:r}),M=Ix(n,s),O=[M.real.length],L=r.makeTensorInfo(O,"float32",M.real),P=r.makeTensorInfo(O,"float32",M.imag),z=A_({inputs:{real:L,imag:P},backend:r}),B=I$({inputs:{a:z,b:F},backend:r}),W=G_({inputs:{a:T,b:B},backend:r}),V=eR({inputs:{a:T,b:B},backend:r}),U=M_({inputs:{input:W},backend:r}),G=M_({inputs:{input:V},backend:r}),H=KE({inputs:{input:W},backend:r}),j=KE({inputs:{input:V},backend:r}),K=qE({inputs:[U,G],backend:r,attrs:{axis:0}}),X=qE({inputs:[H,j],backend:r,attrs:{axis:0}}),q=r.data.get(K.dataId).values,Y=r.data.get(X.dataId).values;return r.disposeIntermediateTensorInfo(h),r.disposeIntermediateTensorInfo(d),r.disposeIntermediateTensorInfo(p),r.disposeIntermediateTensorInfo(x),r.disposeIntermediateTensorInfo(y),r.disposeIntermediateTensorInfo(v),r.disposeIntermediateTensorInfo(C),r.disposeIntermediateTensorInfo(N),r.disposeIntermediateTensorInfo(T),r.disposeIntermediateTensorInfo(A),r.disposeIntermediateTensorInfo(D),r.disposeIntermediateTensorInfo(F),r.disposeIntermediateTensorInfo(L),r.disposeIntermediateTensorInfo(P),r.disposeIntermediateTensorInfo(z),r.disposeIntermediateTensorInfo(B),r.disposeIntermediateTensorInfo(W),r.disposeIntermediateTensorInfo(V),r.disposeIntermediateTensorInfo(U),r.disposeIntermediateTensorInfo(H),r.disposeIntermediateTensorInfo(G),r.disposeIntermediateTensorInfo(j),r.disposeIntermediateTensorInfo(K),r.disposeIntermediateTensorInfo(X),{real:q,imag:Y}}const iR={kernelName:iu,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:s}=t,r=xo(s.shape),i=s.shape[s.shape.length-1],a=j_({inputs:{x:s},backend:n,attrs:{shape:[r/i,i]}}),o=nR(a,!1,n),l=j_({inputs:{x:o},backend:n,attrs:{shape:s.shape}});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(o),l}};function aR(e){const{backend:t,attrs:n}=e,{shape:s,value:r,dtype:i}=n,a=i||Do(r),o=_o(a,xo(s));return function(e,t){e.fill(t)}(o,r),t.makeTensorInfo(s,a,o)}const oR={kernelName:au,backendName:"cpu",kernelFunc:aR};const lR={kernelName:ou,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:s}=e;const{image:r}=t,i=s,a=To(r.dtype,xo(r.shape)),[o,l,u,c]=r.shape,h=i.data.get(r.dataId).values;for(let d=0;d<o;d++){const e=d*u*l*c;for(let t=0;t<l;t++){const n=t*(u*c);for(let t=0;t<u;t++){const s=t*c;for(let r=0;r<c;r++){const i=Math.round(u-t-1),o=e+n+s+r;let l=h[o];if(i>=0&&i<u){l=h[e+n+i*c+r]}a[o]=l}}}}return{dataId:i.write(a,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},uR=h_((e=>Math.floor(e))),cR=p_(lu,uR),hR={kernelName:lu,backendName:"cpu",kernelFunc:cR},dR=v_(((e,t)=>Math.floor(e/t))),pR=B_(uu,dR,null,"int32"),fR={kernelName:uu,backendName:"cpu",kernelFunc:pR};const gR={kernelName:uh,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,filter:i,bias:a,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=s;let g=QE({inputs:{x:r,filter:i},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d}});if(a){const e=g;if("NCHW"===c&&1===a.shape.length&&1!==a.shape[0]){const e=j_({inputs:{x:a},backend:n,attrs:{shape:[a.shape[0],1,1]}});g=G_({inputs:{a:g,b:e},backend:n}),n.disposeIntermediateTensorInfo(e)}else g=G_({inputs:{a:g,b:a},backend:n});n.disposeIntermediateTensorInfo(e)}if(p){const e=g;if("NCHW"===c&&"prelu"===p&&1===o.shape.length&&1!==o.shape[0]){const e=j_({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});g=R_(n,g,p,e,f),n.disposeIntermediateTensorInfo(e)}else g=R_(n,g,p,o,f);n.disposeIntermediateTensorInfo(e)}return g}};const mR={kernelName:ch,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,filter:i,bias:a,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=s;let g=p$({inputs:{x:r,filter:i},backend:n,attrs:{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d}});if(a){const e=g;g=G_({inputs:{a:g,b:a},backend:n}),n.disposeIntermediateTensorInfo(e)}if(p){const e=g;g=R_(n,g,p,o,f),n.disposeIntermediateTensorInfo(e)}return g}};function bR(e,t,n,s,r,i,a,o,l){const u=Tp([s,i],n);for(let c=0;c<s;c++){const n=[];let s=0;for(let t=0;t<r;t++){const i=e[c*r+t];s+=i*a[t],n.push(i)}if(s<0||s>=l/i)throw new Error(`Invalid indices: ${n} does not index into ${o}`);for(let e=0;e<i;e++)u.values[c*i+e]=t.get(...t.indexToLoc(s*i+e))}return u}const xR={kernelName:du,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:s,indices:r}=t,i=xo(s.shape),a=r.shape,o=a[a.length-1],[l,u,c,h]=ax(s,r);if(0===u)return n.makeTensorInfo(l,s.dtype,[]);const d=bR(n.data.get(r.dataId).values,n.bufferSync(s),s.dtype,u,o,c,h,s.shape,i);return n.makeTensorInfo(l,s.dtype,d.values)}};function yR(e,t,n){const s=Tp(n,e.dtype);for(let r=0;r<s.size;++r){const n=s.indexToLoc(r).slice(),i=n[0],a=n[2],o=t.locToIndex([i,a]);n[2]=t.values[o];const l=e.locToIndex(n);0<=l&&l<e.values.length&&(s.values[r]=e.values[l])}return s}const vR={kernelName:hu,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,indices:i}=t,{axis:a,batchDims:o}=s;l_([r,i],"gatherV2");const l=Co(a,r.shape)[0],u=n.data.get(i.dataId).values,c=r.shape[l];for(let y=0;y<u.length;++y){const e=u[y];go(e<=c-1&&e>=0,(()=>`GatherV2: the index value ${e} is not in [0, ${c-1}]`))}let h=o;null==o&&(h=0);const d=xo(i.shape),p=Qx(r,i,l,h),f=j_({inputs:{x:r},backend:n,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),g=j_({inputs:{x:i},backend:n,attrs:{shape:[p.batchSize,d/p.batchSize]}}),m=[p.batchSize,p.outerSize,d/p.batchSize,p.sliceSize],b=n.bufferSync(g),x=yR(n.bufferSync(f),b,m);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),n.makeTensorInfo(p.outputShape,x.dtype,x.values)}},wR=v_(((e,t)=>e>t?1:0)),kR=B_(pu,wR,null,"bool"),SR={kernelName:pu,backendName:"cpu",kernelFunc:kR},IR=v_(((e,t)=>e>=t?1:0)),CR=B_(fu,IR,null,"bool"),NR={kernelName:fu,backendName:"cpu",kernelFunc:CR};const TR={kernelName:mu,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:s}=t,r=xo(s.shape),i=s.shape[s.shape.length-1],a=j_({inputs:{x:s},backend:n,attrs:{shape:[r/i,i]}}),o=nR(a,!0,n),l=j_({inputs:{x:o},backend:n,attrs:{shape:s.shape}});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(o),l}},_R=d_(xu,(e=>Number.isFinite(e)?1:0),"bool"),ER={kernelName:xu,backendName:"cpu",kernelFunc:_R},$R=d_(yu,(e=>Math.abs(e)===1/0?1:0),"bool"),RR={kernelName:yu,backendName:"cpu",kernelFunc:$R},AR=d_(vu,(e=>Number.isNaN(e)?1:0),"bool"),DR={kernelName:vu,backendName:"cpu",kernelFunc:AR},FR=v_(((e,t)=>e<t?1:0)),MR=B_(ku,FR,null,"bool"),OR={kernelName:ku,backendName:"cpu",kernelFunc:MR},LR=v_(((e,t)=>e<=t?1:0)),PR=B_(Su,LR,null,"bool"),zR={kernelName:Su,backendName:"cpu",kernelFunc:PR};function BR(e,t,n){const s=(t-e)/(n-1),r=Bo(n,"float32");r[0]=e;for(let i=1;i<r.length;i++)r[i]=r[i-1]+s;return r}const WR={kernelName:Iu,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:s,stop:r,num:i}=n,a=BR(s,r,i);return t.makeTensorInfo([a.length],"float32",a)}},VR=h_((e=>Math.log(e))),UR=p_(Cu,VR),GR={kernelName:Cu,backendName:"cpu",kernelFunc:UR},HR=d_(Nu,(e=>Math.log1p(e))),jR={kernelName:Nu,backendName:"cpu",kernelFunc:HR},KR=v_(((e,t)=>e&&t)),XR=B_(Tu,KR,null,"bool"),qR={kernelName:Tu,backendName:"cpu",kernelFunc:XR},YR=d_(_u,(e=>e?0:1),"bool"),QR={kernelName:_u,backendName:"cpu",kernelFunc:YR},ZR=v_(((e,t)=>e||t)),JR=B_(Eu,ZR,null,"bool"),eA={kernelName:Eu,backendName:"cpu",kernelFunc:JR};const tA={kernelName:$u,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{depthRadius:i,bias:a,alpha:o,beta:l}=s;l_(r,"LRN");const u=r.shape[3],c=u-1,h=n.data.get(r.dataId).values,d=xo(r.shape),p=new Float32Array(d);function f(e){const t=e%u;let n=e-t+Math.max(0,t-i);const s=e-t+Math.min(t+i,c);let r=0;for(;n<=s;n++){const e=h[n];r+=e*e}return r}for(let g=0;g<d;g++){const e=f(g),t=h[g]*Math.pow(a+o*e,-l);p[g]=t}return n.makeTensorInfo(r.shape,r.dtype,p)}};const nA={kernelName:Ru,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,y:i,dy:a}=t,{depthRadius:o,bias:l,alpha:u,beta:c}=s;l_(a,"LRNGrad");const h=xo(a.shape),d=a.shape[3],p=n.data.get(a.dataId).values,f=n.data.get(r.dataId).values,g=n.data.get(i.dataId).values,m=new Float32Array(h),b=h;for(let x=0;x<b;x++){const e=x%d,t=x-e+Math.max(0,e-o),n=x-e+Math.min(d,e+o+1);let s=0;for(let r=t;r<n;r++)s+=Math.pow(f[r],2);s=u*s+l;for(let r=t;r<n;r++){let e=-2*u*c*f[r]*g[x]/s;x===r&&(e+=Math.pow(s,-c)),e*=p[x],m[r]+=e}}return n.makeTensorInfo(a.shape,r.dtype,m)}};function sA(e,t,n,s){const r=To(s,xo(n));for(let i=0;i<r.length;++i){const n=i*t;let s=e[n];for(let r=0;r<t;++r){const t=e[n+r];(Number.isNaN(t)||t>s)&&(s=t)}r[i]=s}return r}function rA(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{reductionIndices:i,keepDims:a}=s,o=n;let l=r.shape;const u=l.length,c=Co(i,l);let h=c;const d=Gg(h,u);let p=o.data.get(r.dataId).values;if(null!=d){const e=new Array(u);for(let t=0;t<e.length;t++)e[t]=l[d[t]];p=rE(p,l,r.dtype,d,e),h=jg(h.length,u),l=e}l_(r,"max"),Ug("max",h,u);const[f,g]=Wg(l,h),m=sA(p,xo(g),f,r.dtype),b=o.write(m,f,r.dtype);let x=f;if(a){x=Vg(f,c)}return{dataId:b,shape:x,dtype:r.dtype}}const iA={kernelName:Au,backendName:"cpu",kernelFunc:rA},aA=v_(((e,t)=>Math.max(e,t))),oA=B_(Du,aA),lA={kernelName:Du,backendName:"cpu",kernelFunc:oA};const uA={kernelName:Fu,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t;l_(r,"maxPool");const{filterSize:i,strides:a,pad:o,dimRoundingMode:l}=s;go(qf(a,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '1'`));const u=zf(r.shape,i,a,1,o,l);let c;if(1===u.filterWidth&&1===u.filterHeight&&yo(u.inShape,u.outShape))c=m_({inputs:{x:r},backend:n});else{const e=n.data.get(r.dataId).values,t=Oo(r.shape),s=kE(e,r.shape,r.dtype,t,u,"max");c=n.makeTensorInfo(u.outShape,r.dtype,s.values)}return c}};const cA={kernelName:Ou,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{filterSize:i,strides:a,pad:o,dimRoundingMode:l,dataFormat:u}=s;l_(r,"maxPool3d");const c=Bf(r.shape,i,a,1,o,l,u),h=IE(n.data.get(r.dataId).values,r.shape,r.dtype,Oo(r.shape),c,"max");return n.makeTensorInfo(h.shape,"float32",h.values)}};const hA={kernelName:Lu,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,input:i}=t,{filterSize:a,strides:o,pad:l,dimRoundingMode:u}=s;l_([r,i],"maxPool3DGrad");const c=Bf(i.shape,a,o,1,l,u),h=function(e,t){const n=Tp(t.outShape,"int32"),s=t.strideDepth,r=t.strideHeight,i=t.strideWidth,a=t.dilationDepth,o=t.dilationHeight,l=t.dilationWidth,u=t.effectiveFilterDepth,c=t.effectiveFilterHeight,h=t.effectiveFilterWidth,d=t.padInfo.front,p=t.padInfo.top,f=t.padInfo.left;for(let g=0;g<t.batchSize;++g)for(let m=0;m<t.inChannels;++m)for(let b=0;b<t.outDepth;++b){const x=b*s-d;let y=x;for(;y<0;)y+=a;const v=Math.min(t.inDepth,u+x);for(let s=0;s<t.outHeight;++s){const u=s*r-p;let d=u;for(;d<0;)d+=o;const w=Math.min(t.inHeight,c+u);for(let r=0;r<t.outWidth;++r){const p=r*i-f;let k=p;for(;k<0;)k+=l;const S=Math.min(t.inWidth,h+p);let I=Number.NEGATIVE_INFINITY,C=-1;for(let t=y;t<v;t+=a){const n=t-x;for(let s=d;s<w;s+=o){const r=s-u;for(let i=k;i<S;i+=l){const a=i-p,o=e.get(g,t,s,i,m);o>=I&&(I=o,C=n*c*h+r*c+a)}}}n.set(C,g,b,s,r,m)}}}return n}(n.bufferSync(i),c),d=c.strideDepth,p=c.strideHeight,f=c.strideWidth,g=c.dilationDepth,m=c.dilationHeight,b=c.dilationWidth,x=c.effectiveFilterDepth,y=c.effectiveFilterHeight,v=c.effectiveFilterWidth,w=x-1-c.padInfo.front,k=v-1-c.padInfo.left,S=y-1-c.padInfo.top,I=Tp(i.shape,"float32"),C=n.bufferSync(r);for(let N=0;N<c.batchSize;++N)for(let e=0;e<c.inChannels;++e)for(let t=0;t<c.inDepth;++t)for(let n=0;n<c.inHeight;++n)for(let s=0;s<c.inWidth;++s){const r=t-w,i=n-S,a=s-k;let o=0;for(let t=0;t<x;t+=g){const n=(r+t)/d;if(!(n<0||n>=c.outDepth||Math.floor(n)!==n))for(let s=0;s<y;s+=m){const r=(i+s)/p;if(!(r<0||r>=c.outHeight||Math.floor(r)!==r))for(let i=0;i<v;i+=b){const l=(a+i)/f;if(l<0||l>=c.outWidth||Math.floor(l)!==l)continue;const u=x*y*v-1-h.get(N,n,r,l,e)===t*y*v+s*v+i?1:0;if(0===u)continue;o+=C.get(N,n,r,l,e)*u}}}I.set(o,N,t,n,s,e)}return n.makeTensorInfo(I.shape,I.dtype,I.values)}};const dA={kernelName:Mu,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,input:i,output:a}=t,o=i;l_([i,a],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:h}=s,d=zf(o.shape,l,u,1,c,h),p=n.data.get(o.dataId).values,f=Tp(d.outShape,o.dtype,SE(p,o.shape,o.dtype,d).values),g=d.strideHeight,m=d.strideWidth,b=d.dilationHeight,x=d.dilationWidth,y=d.effectiveFilterHeight,v=d.effectiveFilterWidth,w=v-1-d.padInfo.left,k=y-1-d.padInfo.top,S=Tp(o.shape,"float32"),I=n.data.get(r.dataId).values,C=Tp(r.shape,"float32",I);for(let N=0;N<d.batchSize;++N)for(let e=0;e<d.inChannels;++e)for(let t=0;t<d.inHeight;++t)for(let n=0;n<d.inWidth;++n){const s=t-k,r=n-w;let i=0;for(let t=0;t<y;t+=b){const n=(s+t)/g;if(!(n<0||n>=d.outHeight||Math.floor(n)!==n))for(let s=0;s<v;s+=x){const a=(r+s)/m;if(a<0||a>=d.outWidth||Math.floor(a)!==a)continue;const o=y*v-1-f.get(N,n,a,e)===t*v+s?1:0;if(0===o)continue;i+=C.get(N,n,a,e)*o}}S.set(i,N,t,n,e)}return n.makeTensorInfo(S.shape,S.dtype,S.values)}};const pA={kernelName:Pu,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:s}=e;const{x:r}=t,{filterSize:i,strides:a,pad:o,includeBatchInIndex:l}=n,u=s;l_(r,"MaxPoolWithArgmax");const c=u.data.get(r.dataId).values,h=zf(r.shape,i,a,[1,1],o),[d,p]=function(e,t,n,s,r){const i=kE(e,0,n,Oo(t),r,"max"),a=SE(e,t,n,r,!0,s);return[i.values,a.values]}(c,r.shape,r.dtype,l,h),f=u.write(d,h.outShape,r.dtype),g=u.write(p,h.outShape,r.dtype);return[{dataId:f,shape:h.outShape,dtype:r.dtype},{dataId:g,shape:h.outShape,dtype:"int32"}]}};const fA={kernelName:zu,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:i,keepDims:a}=s,o=Co(i,r.shape),l=xo(Wg(r.shape,o)[1]),u=[],c=n.makeTensorInfo([],"float32",new Float32Array([l]));u.push(c);const h=P_({inputs:{x:r},backend:n,attrs:{dtype:"float32"}});u.push(h);const d=Y$({inputs:{a:h,b:c},backend:n});u.push(d);const p=N$({inputs:{x:d},backend:n,attrs:{axis:i,keepDims:a}});return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),p}};const gA={kernelName:Bu,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:i,keepDims:a}=s;l_(r,"min");const o=Co(i,r.shape);let l=o;const u=Gg(l,r.shape.length);let c=r;null!=u&&(c=iE({inputs:{x:r},backend:n,attrs:{perm:u}}),l=jg(l.length,r.shape.length)),Ug("min",l,c.shape.length);const[h,d]=Wg(c.shape,l),p=xo(d),f=Bo(xo(h),c.dtype),g=n.data.get(c.dataId).values;for(let b=0;b<f.length;++b){const e=b*p;let t=g[e];for(let n=0;n<p;++n){const s=g[e+n];(Number.isNaN(s)||s<t)&&(t=s)}f[b]=t}null!=u&&n.disposeIntermediateTensorInfo(c);const m=n.makeTensorInfo(h,c.dtype,f);if(a){const e=j_({inputs:{x:m},backend:n,attrs:{shape:Vg(h,o)}});return n.disposeIntermediateTensorInfo(m),e}return m}},mA=v_(((e,t)=>Math.min(e,t))),bA=B_(Wu,mA),xA={kernelName:Wu,backendName:"cpu",kernelFunc:bA};const yA={kernelName:Vu,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{paddings:i,mode:a}=s;l_(r,"mirrorPad");const o=i.map(((e,t)=>e[0]+r.shape[t]+e[1])),l=i.map((e=>e[0])),u=i.map(((e,t)=>e[0]+r.shape[t])),c="reflect"===a?0:1,h=n.data.get(r.dataId).values,d=r.shape.length,p=Oo(r.shape),f=xo(o),g=o.length,m=Oo(o),b=To(r.dtype,f);for(let x=0;x<f;x++){let e=Go(x,g,m);for(let n=0;n<g;n++)e[n]<l[n]?e[n]=2*l[n]-e[n]-c:e[n]>=u[n]&&(e[n]=2*(u[n]-1)-e[n]+c);e=e.map(((e,t)=>e-l[t]));const t=Uo(e,d,p);b[x]=h[t]}return{dataId:n.write(b,o,r.dtype),shape:o,dtype:r.dtype}}},vA=v_(((e,t)=>{const n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t})),wA=B_(Uu,vA),kA={kernelName:Uu,backendName:"cpu",kernelFunc:wA};function SA(e){const{inputs:t,backend:n,attrs:s}=e,{logits:r}=t,{dim:i}=s,a=r.shape.length;let o=i;if(-1===o&&(o=a-1),o!==a-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${a} and dim was ${o}`);const l=Co([o],r.shape),u=rA({inputs:{x:r},backend:n,attrs:{reductionIndices:l,keepDims:!1}}),c=Vg(u.shape,l),h=j_({inputs:{x:u},backend:n,attrs:{shape:c}}),d=eR({inputs:{a:r,b:h},backend:n}),p=V$({inputs:{x:d},backend:n}),f=N$({inputs:{x:p},backend:n,attrs:{axis:l,keepDims:!1}}),g=j_({inputs:{x:f},backend:n,attrs:{shape:c}}),m=Y$({inputs:{a:p,b:g},backend:n});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),m}const IA={kernelName:Mc,backendName:"cpu",kernelFunc:SA};const CA={kernelName:Gu,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{logits:r}=t,{numSamples:i,seed:a,normalized:o}=s;l_(r,"multinomial");const l=o?r:SA({inputs:{logits:r},backend:n,attrs:{dim:-1}}),u=l.shape[0],c=l.shape[1],h=n.data.get(l.dataId).values,d=[u,i],p=Bo(xo(d),"int32");for(let f=0;f<u;++f){const e=f*c,t=new Float32Array(c-1);t[0]=h[e];for(let r=1;r<t.length;++r)t[r]=t[r-1]+h[e+r];const n=cm.alea(a.toString()),s=f*i;for(let r=0;r<i;++r){const e=n();p[s+r]=t.length;for(let n=0;n<t.length;n++)if(e<t[n]){p[s+r]=n;break}}}return o||n.disposeIntermediateTensorInfo(l),n.makeTensorInfo(d,"int32",p)}};function NA(e,t,n){const s=Oh(-1,n);return k$([],t,s,e,n)}const TA={kernelName:ju,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:s}=t;l_(s,"neg");const r=n.data.get(s.dataId).values,[i,a]=NA(r,s.shape,s.dtype);return n.makeTensorInfo(a,s.dtype,i)}},_A=db;const EA={kernelName:Xu,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{boxes:r,scores:i}=t,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l}=s;l_(r,"NonMaxSuppression");const u=n.data.get(r.dataId).values,c=n.data.get(i.dataId).values,{selectedIndices:h}=_A(u,c,a,o,l);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},$A=pb;const RA={kernelName:qu,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{boxes:r,scores:i}=t,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=s;l_(r,"NonMaxSuppressionPadded");const c=n.data.get(r.dataId).values,h=n.data.get(i.dataId).values,{selectedIndices:d,validOutputs:p}=$A(c,h,a,o,l,u);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},AA=fb;const DA={kernelName:Yu,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{boxes:r,scores:i}=t,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=s;l_(r,"NonMaxSuppressionWithScore");const c=n.data.get(r.dataId).values,h=n.data.get(i.dataId).values,d=a,p=o,f=l,g=u,{selectedIndices:m,selectedScores:b}=AA(c,h,d,p,f,g);return[n.makeTensorInfo([m.length],"int32",new Int32Array(m)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}},FA=v_(((e,t)=>e!==t?1:0)),MA=B_(Ku,FA,null,"bool"),OA={kernelName:Ku,backendName:"cpu",kernelFunc:MA};const LA={kernelName:Zu,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{indices:r}=t,{dtype:i,depth:a,onValue:o,offValue:l}=s;l_(r,"oneHot");const u=xo(r.shape),c=new Float32Array(u*a);c.fill(l);const h=n.data.get(r.dataId).values;for(let d=0;d<u;++d)h[d]>=0&&h[d]<a&&(c[d*a+h[d]]=o);return n.makeTensorInfo([...r.shape,a],i,c)}};function PA(e){const{inputs:t,backend:n}=e,{x:s}=t;if("string"===s.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===s.dtype){const e=M_({inputs:{input:s},backend:n}),t=PA({inputs:{x:e},backend:n}),r=KE({inputs:{input:s},backend:n}),i=PA({inputs:{x:r},backend:n}),a=A_({inputs:{real:t,imag:i},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(i),a}return aR({backend:n,attrs:{shape:s.shape,value:0,dtype:s.dtype}})}const zA={kernelName:rh,backendName:"cpu",kernelFunc:PA};const BA={kernelName:Qu,backendName:"cpu",kernelFunc:function e(t){const{inputs:n,backend:s}=t,{x:r}=n;if("string"===r.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===r.dtype){const t=M_({inputs:{input:r},backend:s}),n=e({inputs:{x:t},backend:s}),i=KE({inputs:{input:r},backend:s}),a=PA({inputs:{x:i},backend:s}),o=A_({inputs:{real:n,imag:a},backend:s});return s.disposeIntermediateTensorInfo(t),s.disposeIntermediateTensorInfo(n),s.disposeIntermediateTensorInfo(i),s.disposeIntermediateTensorInfo(a),o}return aR({backend:s,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}};function WA(e){const{inputs:t,backend:n,attrs:s}=e,{axis:r}=s;if(1===t.length)return G$({inputs:{input:t[0]},backend:n,attrs:{dim:r}});const i=t[0].shape,a=t[0].dtype;t.forEach((e=>{mo(i,e.shape,"All tensors passed to stack must have matching shapes"),go(a===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const o=[],l=qE({inputs:t.map((e=>{const t=G$({inputs:{input:e},backend:n,attrs:{dim:r}});return o.push(t),t})),backend:n,attrs:{axis:r}});return o.forEach((e=>n.disposeIntermediateTensorInfo(e))),l}const VA={kernelName:Ju,backendName:"cpu",kernelFunc:WA};const UA={kernelName:ec,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{paddings:i,constantValue:a}=s;l_(r,"pad");const o=i.map(((e,t)=>e[0]+r.shape[t]+e[1])),l=i.map((e=>e[0])),u=n.data.get(r.dataId).values,c=xo(r.shape),h=r.shape.length,d=Oo(r.shape),p=xo(o),f=o.length,g=Oo(o),m=To(r.dtype,p);0!==a&&m.fill(a);for(let b=0;b<c;b++){m[Uo(Go(b,h,d).map(((e,t)=>e+l[t])),f,g)]=u[b]}return{dataId:n.write(m,o,r.dtype),shape:o,dtype:r.dtype}}},GA=v_(((e,t)=>Math.pow(e,t))),HA=B_(tc,GA),jA={kernelName:tc,backendName:"cpu",kernelFunc:HA};function KA(e,t,n,s){const[r,i]=Wg(e,s),a=cd(t,"int32"),o=Bo(xo(r),a),l=xo(i);for(let u=0;u<o.length;++u){const e=u*l;let t=1;for(let s=0;s<l;++s)t*=n[e+s];o[u]=t}return{outVals:o,outShape:r,outDtype:a}}const XA={kernelName:sc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:i,keepDims:a}=s;l_(r,"prod");const o=r.shape.length,l=Co(i,r.shape),u=Gg(l,o);let c=l,h=r;const d=[];null!=u&&(h=iE({inputs:{x:r},backend:n,attrs:{perm:u}}),d.push(h),c=jg(c.length,o));const p=n.data.get(h.dataId).values,{outVals:f,outShape:g,outDtype:m}=KA(h.shape,h.dtype,p,c);let b=g;return a&&(b=Vg(g,l)),d.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(b,m,f)}};function qA(e,t,n,s){const r=[];let i=0;const a=t.length-1+n.length,o=new Array(a).fill(null).map((()=>[0]));!function(e,t){for(let n=0;n<e.length;++n){const s=e[n],r=n===e.length-1?t:e[n+1].length;if(0===s.length)throw new Error("Ragged splits may not be empty");if(s[0]<0)throw new Error("Ragged splits must be non-negative");if(s[s.length-1]>r)throw new Error("Ragged splits must not point past values");for(let e=1;e<s.length;++e)if(s[e-1]>s[e])throw new Error("Ragged splits must be sorted in ascending order")}}(n,s);let l=1;for(let u=0;u<t.length-1;++u){l*=t[u];const e=t[u+1];for(let t=1;t<l+1;++t)o[u].push(t*e)}for(let u=0;u<e.length;++u){let s=e[u],a=e[u]+1;for(let e=0;e<n.length;++e){const r=n[e],i=e+t.length-1;if(i>=0){const e=o[i],t=e[e.length-1]-r[s];for(let n=s;n<a;++n)o[i].push(r[n+1]+t)}s=r[s],a=r[a]}a!==s&&(r.push([s,a]),i+=a-s)}return{outSplits:o,valueSlices:r,numValues:i}}function YA(e,t){const n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let s=t;s<e.length;s++)n[t-1]*=e[s];return n}function QA(e,t,n,s,r){const i=t.slice();i[0]=r;const a=_o(n,xo(i)),o=e.length;return function(e,t,n,s,r,i){const a=YA(t,2)[1],o=YA(i,2)[1];let l=0;for(const u of n)for(let t=u[0];t<u[1];++t){for(let n=0;n<s;++n)r[l*o+n]=e[t*a+n];++l}}(e,t,s,0===o?0:o/t[0],a,i),[a,i]}function ZA(e,t,n,s,r,i,a,o){if(0===e.length)throw new Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw new Error("Split tensors must not be scalars");if(function(e,t,n){e.forEach(((e,s)=>{if(e<0||e>=n){const r=Go(s,t.length,Oo(t)).join(",");throw new Error(`indices[${r}] = ${e} is not in [0, ${n})`)}}))}(i,a,t[0][0]-1),0===s.length)throw new Error("params.rank must be nonzero");const l=s[0],{outSplits:u,valueSlices:c,numValues:h}=qA(i,a,e,l),d=function(e){const t=[];for(let n=0;n<e.length;++n){const s=_o("int32",e[n].length);t.push(s),e[n].forEach(((e,t)=>s[t]=e))}return t}(u),p=QA(n,s,r,c,h);return[d,p[0],p[1]]}const JA={kernelName:rc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{paramsNestedSplits:r,paramsDenseValues:i,indices:a}=t,{outputRaggedRank:o}=s,l=r.map((e=>n.data.get(e.dataId).values)),u=r.map((e=>e.shape)),c=n.data.get(i.dataId).values,h=n.data.get(a.dataId).values,[d,p,f]=ZA(l,u,c,i.shape,i.dtype,h,a.shape),g=d.map((e=>n.makeTensorInfo([e.length],"int32",e))),m=n.makeTensorInfo(f,i.dtype,p);return g.concat([m])}},eD=2147483647;function tD(e,t,n,s,r,i,a){if(t.length>1)throw new Error("starts must be a scalar or vector");if(r.length>1)throw new Error("limits must be a scalar or vector");if(a.length>1)throw new Error("deltas must be a scalar or vector");const o=0===t.length,l=0===r.length,u=0===a.length,c=[];o||c.push(t[0]),l||c.push(r[0]),u||c.push(a[0]);for(let g=1;g<c.length;++g)if(c[g]!==c[g-1])throw new Error("starts, limits, and deltas must have the same shape");const h=0===c.length?1:c[0],d=_o("int32",h+1);d[0]=0;for(let g=0;g<h;++g){const t=o?e[0]:e[g],n=l?s[0]:s[g],r=u?i[0]:i[g];if(0===r)throw new Error("Requires delta != 0");let a;if(r>0&&n<t||r<0&&n>t)a=0;else if(a=Math.ceil(Math.abs((n-t)/r)),a>eD)throw new Error(`Requires ((limit - start) / delta) <= ${eD}`);d[g+1]=d[g]+a}const p=_o(n,d[h]);let f=0;for(let g=0;g<h;++g){const t=d[g+1]-d[g];let n=o?e[0]:e[g];const s=u?i[0]:i[g];for(let e=0;e<t;++e)p[f++]=n,n+=s}return[d,p]}const nD={kernelName:ic,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{starts:s,limits:r,deltas:i}=t,a=n.data.get(s.dataId).values,o=n.data.get(r.dataId).values,l=n.data.get(i.dataId).values,[u,c]=tD(a,s.shape,s.dtype,o,r.shape,l,i.shape);return[n.makeTensorInfo([u.length],"int32",u),n.makeTensorInfo([c.length],s.dtype,c)]}};var sD=Kb;class rD{constructor(e,t,n,s,r,i,a,o,l,u){this.shape=e,this.shapeShape=t,this.values=n,this.valuesShape=s,this.valuesDType=r,this.defaultValue=i,this.defaultValueShape=a,this.rowPartitionValues=o,this.rowPartitionValuesShapes=l,this.rowPartitionTypes=qb(u),this.raggedRank=Yb(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===sD.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===sD.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case sD.VALUE_ROWIDS:return rD.getMaxWidthValueRowID(t);case sD.ROW_SPLITS:return rD.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${sD[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const t=e.length;if(0===t||1===t)return 0;let n=0;for(let s=0;s<t-1;++s){const t=e[s+1]-e[s];t>n&&(n=t)}return n}static getMaxWidthValueRowID(e){const t=e.length;if(0===t)return 0;let n=0,s=e[0],r=0;for(let i=1;i<t;++i){const t=e[i];t!==s&&(s=t,r=Math.max(i-n,r),n=i)}return Math.max(t-n,r)}tensorShapeFromTensor(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(0===t.length){if(-1===e[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return aD(e,n)}calculateOutputSize(e){const t=this.valuesShape;Qb(this.defaultValueShape,t);const n=this.tensorShapeFromTensor(this.shape,this.shapeShape),s=Xb(this.raggedRank,n,t);s[0]<0&&(s[0]=e);for(let r=1;r<=this.raggedRank;++r)s[r]<0&&(s[r]=this.getMaxWidth(r));return s}calculateFirstParentOutputIndex(e,t,n){const s=Math.min(e,n),r=[];let i=0;for(let a=0;a<s;++a,i+=t)r.push(i);for(let a=s;a<e;++a)r.push(-1);return go(r.length===e,(()=>"Final length of result must be equal to firstDimension.")),r}calculateOutputIndexRowSplit(e,t,n,s){const r=e.length,i=[];for(let a=0;a<r-1;++a){const r=e[a+1]-e[a];let o=Math.min(s,r),l=t[a];-1===l&&(o=0);for(let e=0;e<o;++e)i.push(l),l+=n;for(let e=0;e<r-o;++e)i.push(-1)}if(r>0&&i.length!==e[r-1])throw new Error("Invalid row split size.");return i}calculateOutputIndexValueRowID(e,t,n,s){const r=e.length,i=[];if(0===r)return[];let a=0,o=e[0];if(o>=t.length)throw new Error(`Got currentValueRowId=${o}, which is not less than ${t.length}`);let l=t[o];i.push(l);for(let u=1;u<r;++u){const r=e[u];if(r===o)l>=0&&(++a,a<s?l+=n:l=-1);else{if(a=0,o=r,r>=t.length)throw new Error(`Got nextValueRowId=${r} which is not less than ${t.length}`);l=t[r]}i.push(l)}if(i.length!==e.length)throw new Error("Invalid row ids.");return i}calculateOutputIndex(e,t,n,s){const r=this.getRowPartitionTensor(e),i=this.getRowPartitionTypeByDimension(e);switch(i){case sD.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(r,t,n,s);case sD.ROW_SPLITS:if(r.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${r.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(r,t,n,s);default:throw new Error(`Unsupported partition type: ${sD[i]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case sD.FIRST_DIM_SIZE:return e[0];case sD.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case sD.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${sD[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),t=this.calculateOutputSize(e),n=new Array(this.raggedRank+1);n[n.length-1]=1;for(let i=n.length-2;i>=0;--i)n[i]=n[i+1]*t[i+1];const s=aD(t,!1),r=_o(this.valuesDType,xo(s));if(n[0]*t[0]>0){let i=this.calculateFirstParentOutputIndex(e,n[0],t[0]);for(let e=1;e<=this.raggedRank;++e){i=this.calculateOutputIndex(e-1,i,n[e],t[e])}this.setOutput(this.raggedRank,i,r,s)}return[s,r]}setOutput(e,t,n,s){if(0===n.length)return;const r=this.values,i=n;let a=s.slice();a=a.slice(e+1);const o=xo(a),l=t.length;let u=this.defaultValue;if(u.length!==o&&1!==u.length){const e=this.defaultValueShape;Bd((()=>{const t=Jf(u,e),n=ag(t,a);u=n.dataSync()}))}let c=0,h=0,d=0;for(let p=0;p<=l;++p){let e=p<l?t[p]:-1;if(e!==d){if(h<d){const e=r.subarray(c*o);iD(i.subarray(h*o),e,(d-h)*o)}if(p>=l){const t=n.length;e=Math.floor(t/o)}if(e>d)if(1===this.defaultValue.length)i.subarray(d*o,e*o).fill(this.defaultValue[0]),d=e;else for(;e>d;){iD(i.slice(d*o),u,o),++d}e<0?(c=p+1,h=d):(c=p,h=d,d=h+1)}else++d}}}function iD(e,t,n){for(let s=0;s<n;s++)e[s]=t[s]}function aD(e,t){const n=[];for(let s of e){if(s<0){if(!t)throw new Error(`Dimension ${s} must be >= 0`);if(s<-1)throw new Error(`Dimension ${s} must be >= -1`);s=-1}n.push(s)}return n}function oD(e,t,n,s,r,i,a,o,l,u){return new rD(e,t,n,s,r,i,a,o,l,u).compute()}const lD={kernelName:ac,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{shape:r,values:i,defaultValue:a,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=s,u=n.data.get(r.dataId).values,c=n.data.get(i.dataId).values,h=n.data.get(a.dataId).values,d=o.map((e=>n.data.get(e.dataId).values)),p=o.map((e=>e.shape)),[f,g]=oD(u,r.shape,c,i.shape,i.dtype,h,a.shape,d,p,l);return n.makeTensorInfo(f,i.dtype,g)}};function uD(e,t,n,s){if(e===t||e<t&&n<0||t<e&&n>1)return Bo(0,s);const r=Bo(Math.abs(Math.ceil((t-e)/n)),s);t<e&&1===n&&(n=-1),r[0]=e;for(let i=1;i<r.length;i++)r[i]=r[i-1]+n;return r}const cD={kernelName:oc,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:s,stop:r,dtype:i,step:a}=n,o=uD(s,r,a,i);return t.makeTensorInfo([o.length],i,o)}},hD=d_(uc,(e=>1/e)),dD={kernelName:uc,backendName:"cpu",kernelFunc:hD};const pD={kernelName:fc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{images:r}=t,{alignCorners:i,halfPixelCenters:a,size:o}=s;l_(r,"resizeBilinear");const l=Oo(r.shape),[u,c]=o,[h,d,p,f]=r.shape,g=n.data.get(r.dataId).values,m=new Float32Array(xo([h,u,c,f])),b=[i&&u>1?d-1:d,i&&c>1?p-1:p],x=[i&&u>1?u-1:u,i&&c>1?c-1:c];let y=0;const v=b[0]/x[0],w=b[1]/x[1];for(let k=0;k<h;k++)for(let e=0;e<u;e++){let t;t=a?v*(e+.5)-.5:v*e;const n=Math.max(0,Math.floor(t)),s=t-n,r=Math.min(d-1,Math.ceil(t)),i=k*l[0]+n*l[1],o=k*l[0]+r*l[1];for(let e=0;e<c;e++){let t;t=a?w*(e+.5)-.5:w*e;const n=Math.max(0,Math.floor(t)),r=t-n,u=Math.min(p-1,Math.ceil(t)),c=i+n*l[2],h=o+n*l[2],d=i+u*l[2],b=o+u*l[2];for(let e=0;e<f;e++){const t=g[c+e],n=g[h+e],i=t+(g[d+e]-t)*r,a=i+(n+(g[b+e]-n)*r-i)*s;m[y++]=a}}}return n.makeTensorInfo([h,u,c,f],"float32",m)}};const fD={kernelName:gc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{images:r,dy:i}=t,{alignCorners:a}=s;l_([i,r],"resizeBilinearGrad");const o=Oo(r.shape),[l,u,c,h]=r.shape,[,d,p]=i.shape,f=new Float32Array(l*u*c*h),g=[a&&d>1?u-1:u,a&&p>1?c-1:c],m=[a&&d>1?d-1:d,a&&p>1?p-1:p],b=g[0]/m[0],x=g[1]/m[1],y=n.data.get(i.dataId).values;let v=0;for(let w=0;w<l;w++){const e=w*o[0];for(let t=0;t<d;t++){const n=t*b,s=Math.floor(n),r=Math.min(Math.ceil(n),u-1),i=e+s*o[1],a=e+r*o[1],l=n-s,d=1-l;for(let e=0;e<p;e++){const t=e*x,n=Math.floor(t),s=Math.min(Math.ceil(t),c-1),r=t-n,u=1-r,p=i+n*o[2],g=i+s*o[2],m=a+n*o[2],b=a+s*o[2],w=d*u,k=d*r,S=l*u,I=l*r;for(let e=0;e<h;e++){const t=y[v++];f[p+e]+=t*w,f[g+e]+=t*k,f[m+e]+=t*S,f[b+e]+=t*I}}}}return n.makeTensorInfo([l,c,u,h],"float32",f)}};const gD={kernelName:dc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{images:r}=t,{alignCorners:i,halfPixelCenters:a,size:o}=s;l_(r,"resizeNearestNeighbor");const l=Oo(r.shape),[u,c]=o,[h,d,p,f]=r.shape,g=n.data.get(r.dataId).values,m=new Float32Array(h*u*c*f),b=[i&&u>1?d-1:d,i&&c>1?p-1:p],x=[i&&u>1?u-1:u,i&&c>1?c-1:c],y=b[0]/x[0],v=b[1]/x[1];let w=0;for(let k=0;k<h;k++){const e=k*l[0];for(let t=0;t<u;t++){const n=a?y*(t+.5):y*t;let s=Math.min(d-1,i?Math.round(n):Math.floor(n));a&&(s=Math.max(0,s));const r=e+s*l[1];for(let e=0;e<c;e++){const t=a?v*(e+.5):v*e;let n=Math.min(p-1,i?Math.round(t):Math.floor(t));a&&(n=Math.max(0,n));const s=r+n*l[2];for(let e=0;e<f;e++){const t=g[s+e];m[w++]=t}}}}return n.makeTensorInfo([h,u,c,f],r.dtype,m)}};const mD={kernelName:pc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{images:r,dy:i}=t,{alignCorners:a}=s;l_([i,r],"resizeNearestNeighborGrad");const o=Oo(r.shape),l=Oo(i.shape),[u,c,h,d]=r.shape,[,p,f]=i.shape,g=new Float32Array(u*c*h*d),m=n.data.get(i.dataId).values,b=[a&&p>1?c-1:c,a&&f>1?h-1:h],x=[a&&p>1?p-1:p,a&&f>1?f-1:f],y=b[0]/x[0],v=b[1]/x[1],w=1/y,k=1/v,S=2*Math.ceil(w)+2,I=2*Math.ceil(k)+2;for(let C=0;C<u;C++){const e=C*o[0];for(let t=0;t<c;t++){const n=e+t*o[1],s=Math.floor(t*w),r=Math.floor(s-S/2);for(let i=0;i<h;i++){const s=n+i*o[2],u=Math.floor(i*k),b=Math.floor(u-I/2);for(let n=0;n<d;n++){let o=0;for(let s=0;s<S;s++){const u=s+r;if(u<0||u>=p)continue;const d=e+u*l[1],g=u*y;if(t===Math.min(c-1,a?Math.round(g):Math.floor(g)))for(let e=0;e<I;e++){const t=e+b;if(t<0||t>=f)continue;const s=d+t*l[2],r=t*v;i===Math.min(h-1,a?Math.round(r):Math.floor(r))&&(o+=m[s+n])}}g[s+n]=o}}}}return n.makeTensorInfo(r.shape,r.dtype,g)}};const bD={kernelName:bc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{dims:i}=s;l_(r,"reverse");const a=r.shape.length,o=Co(i,r.shape);if(0===a)return m_({inputs:{x:r},backend:n});const l=new Qh(r.shape,r.dtype),u=n.bufferSync(r);for(let c=0;c<l.size;c++){const e=l.indexToLoc(c),t=e.slice();o.forEach((e=>t[e]=r.shape[e]-1-t[e])),l.set(u.get(...t),...e)}return n.makeTensorInfo(l.shape,l.dtype,l.values)}},xD={kernelName:oh,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:s}=e;const{image:r}=t,{radians:i,fillValue:a,center:o}=n,l=s,u=To(r.dtype,xo(r.shape)),[c,h,d,p]=r.shape,[f,g]=ex(o,h,d),m=Math.sin(i),b=Math.cos(i),x=l.data.get(r.dataId).values;for(let y=0;y<c;y++){const e=y*d*h*p;for(let t=0;t<h;t++){const n=t*(d*p);for(let s=0;s<d;s++){const r=s*p;for(let i=0;i<p;i++){const o=[c,t,s,i],l=o[2],y=o[1];let v=(l-f)*b-(y-g)*m,w=(l-f)*m+(y-g)*b;v=Math.round(v+f),w=Math.round(w+g);let k=a;if("number"!==typeof a&&(k=3===i?255:a[i]),v>=0&&v<d&&w>=0&&w<h){k=x[e+w*(d*p)+v*p+i]}u[e+n+r+i]=k}}}}return{dataId:l.write(u,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},yD=d_(xc,(e=>{const t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2===0?t:t+1})),vD={kernelName:xc,backendName:"cpu",kernelFunc:yD},wD=h_((e=>1/Math.sqrt(e))),kD=p_(yc,wD),SD={kernelName:yc,backendName:"cpu",kernelFunc:kD};function ID(e,t,n,s,r,i,a,o,l,u){const c=[s/r,r],h=e.values,d=t.values;if(0===s)return Tp(n,t.dtype);const p=l instanceof Qh?l:Tp(c,t.dtype);"string"===typeof l||"number"===typeof l?p.values.fill(l):"boolean"===typeof l&&p.values.fill(+l);for(let f=0;f<i;f++){const e=[];let i=0;for(let t=0;t<a;t++){const n=h[f*a+t];e.push(n),i+=n*o[t]}if(i<0||i>=s/r)throw new Error(`Invalid indices: ${e} does not index into ${n}`);for(let n=0;n<r;n++)u?p.values[i*r+n]+=d[f*r+n]:p.values[i*r+n]=0===t.rank?d[0]:d[f*r+n]}return p}const CD={kernelName:vc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{indices:r,updates:i}=t,{shape:a}=s,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=ux(0,r,a),d=ID(n.bufferSync(r),n.bufferSync(i),a,h,u,l,o,c,0,!0);return n.makeTensorInfo(a,d.dtype,d.values)}};function ND(e,t){let n=0,s=e.length,r=0;for(;n<s;)r=Math.floor((n+s)/2),e[r]<t?n=r+1:s=r;return s}function TD(e,t){let n=0,s=e.length,r=0;for(;n<s;)r=Math.floor((n+s)/2),e[r]<=t?n=r+1:s=r;return s}const _D={kernelName:kc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{sortedSequence:r,values:i}=t,{side:a}=s,o=function(e,t,n,s,r,i){const a=_o("int32",n*r);for(let o=0;o<n;++o){const n=e.slice(o*s,(o+1)*s),l=o*r;for(let e=0;e<r;++e)a[l+e]="left"===i?ND(n,t[e+l]):TD(n,t[e+l])}return a}(n.data.get(r.dataId).values,n.data.get(i.dataId).values,r.shape[0],r.shape[1],i.shape[1],a);return n.makeTensorInfo(i.shape,"int32",o)}};const ED={kernelName:Sc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:s,t:r,e:i}=t;l_([s,r,i],"select");const a=s.shape.length,o=n.data.get(s.dataId).values,l=n.data.get(r.dataId).values,u=n.data.get(i.dataId).values,c=cd(r.dtype,i.dtype),h=Bo(xo(r.shape),c);let d=0;const p=0===a||a>1||1===r.shape.length?1:xo(r.shape.slice(1));for(let f=0;f<o.length;f++)for(let e=0;e<p;e++)1===o[f]?h[d++]=l[f]:h[d++]=u[f];return n.makeTensorInfo(r.shape,c,h)}},$D=cx,RD=hx,AD=d_(Ic,(e=>e>=0?RD*e:$D*(Math.exp(e)-1))),DD={kernelName:Ic,backendName:"cpu",kernelFunc:AD},FD=d_(_c,(e=>e<0?-1:e>0?1:0)),MD={kernelName:_c,backendName:"cpu",kernelFunc:FD},OD=d_(Nc,(e=>Math.sin(e))),LD={kernelName:Nc,backendName:"cpu",kernelFunc:OD},PD=d_(Tc,(e=>Math.sinh(e))),zD={kernelName:Tc,backendName:"cpu",kernelFunc:PD},BD=Math.log(1.1920928955078125e-7)+2,WD=d_($c,(e=>{const t=e>-BD,n=e<BD,s=Math.exp(e);let r;return r=n?s:t?e:Math.log(1+s),r})),VD={kernelName:$c,backendName:"cpu",kernelFunc:WD};const UD={kernelName:Dc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{blockShape:i,paddings:a}=s;l_([r],"spaceToBatchND");const o=xo(i),l=[[0,0]];l.push(...a);for(let m=1+i.length;m<r.shape.length;++m)l.push([0,0]);const u=UA.kernelFunc({inputs:{x:r},backend:n,attrs:{paddings:l,constantValue:0}}),c=tx(u.shape,i,o,!1),h=nx(c.length,i.length,!1),d=sx(u.shape,i,o,!1),p=j_({inputs:{x:u},backend:n,attrs:{shape:c}}),f=iE({inputs:{x:p},backend:n,attrs:{perm:h}}),g=j_({inputs:{x:f},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),g}};function GD(e,t,n,s,r,i,a){const o=t[0],l=i[0],u=new Array(l),c=new Array(o),h=t[1];if(0===l){if(0!==o)throw new Error(Lx(o));return[_o(n,0),[0,h],_o(r,0),u,c]}let d=!0,p=0;const f=new Array(l).fill(0);for(let m=0;m<o;++m){const t=e[m*h];if(t<0)throw new Error(Px(m,t));if(t>=l)throw new Error(zx(m,t,l));++f[t],d=d&&t>=p,p=t}let g=!0;for(let m=0;m<l;++m){const e=0===f[m];u[m]=e,g=g&&!e,f[m]=Math.max(f[m],1),m>0&&(f[m]+=f[m-1])}if(g&&d){const t=e,n=s;for(let e=0;e<o;++e)c[e]=e;return[t,[o,h],n,u,c]}{const t=f[l-1],i=_o(n,t*h),d=_o(r,t),p=new Array(l).fill(0);for(let n=0;n<o;++n){const t=e[n*h],r=p[t],a=(0===t?0:f[t-1])+r;p[t]++;for(let s=0;s<h;++s)i[a*h+s]=e[n*h+s];d[a]=s[n],c[n]=a}for(let e=0;e<l;++e){if(0===p[e]){const t=0===e?0:f[e-1];i[t*h+0]=e;for(let e=1;e<h;++e)i[t*h+e]=0;d[t]=a}}return[i,[t,h],d,u,c]}}const HD={kernelName:Oc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:s,values:r,denseShape:i,defaultValue:a}=t;if(1!==i.shape.length)throw new Error(`Dense shape must be a vector, saw:\n        ${i.shape}`);if(2!==s.shape.length)throw new Error(`Indices must be a matrix, saw:\n        ${s.shape}`);if(1!==r.shape.length)throw new Error(`Values must be a vector, saw:\n        ${r.shape}`);if(0!==a.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${a.shape}`);const o=n.data.get(s.dataId).values,l=n.data.get(r.dataId).values,u=n.data.get(i.dataId).values,c=n.data.get(a.dataId).values[0],[h,d,p,f,g]=GD(o,s.shape,s.dtype,l,r.dtype,u,c);return[n.makeTensorInfo(d,s.dtype,h),n.makeTensorInfo([d[0]],r.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([g.length],s.dtype,new Int32Array(g))]}};function jD(e,t,n,s,r){const i=xo(s),a=t[0],o=r.length,l=[];let u=1,c=-1;for(let g=0;g<o;++g){const e=r[g];if(-1===e){if(-1!==c)throw new Error(Bx(c,g));c=g,l.push(1)}else{if(e<0)throw new Error(Wx(g,e));u*=e,l.push(e)}}if(-1!==c){if(u<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const e=Math.trunc(i/u);if(u*e!==i)throw new Error(Ux(s,l));l[c]=e}if(xo(l)!==i)throw new Error(Gx(s,l));const h=s.length,d=[];if(h>0){d[h-1]=1;for(let e=h-2;e>=0;--e)d[e]=d[e+1]*s[e+1]}const p=[];if(o>0){p[o-1]=1;for(let e=o-2;e>=0;--e)p[e]=p[e+1]*l[e+1]}const f=_o(n,a*o);for(let g=0;g<a;++g){let t=0;for(let n=0;n<h;++n)t+=e[g*h+n]*d[n];for(let e=0;e<o;++e)f[g*o+e]=Math.trunc(t/p[e]),t%=p[e]}return[f,[a,o],l]}const KD={kernelName:Lc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:s,inputShape:r,newShape:i}=t;if(2!==s.shape.length)throw new Error(`Input indices should be a matrix but received shape\n        ${s.shape}`);if(1!==r.shape.length)throw new Error(`Input shape should be a vector but received shape\n        ${r.shape}`);if(1!==i.shape.length)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const a=Array.from(n.data.get(r.dataId).values),o=n.data.get(s.dataId).values,l=Array.from(n.data.get(i.dataId).values),[u,c,h]=jD(o,s.shape,s.dtype,a,l);return[n.makeTensorInfo(c,s.dtype,u),n.makeTensorInfo([h.length],i.dtype,new Int32Array(h))]}};function XD(e,t,n,s,r){let i=arguments.length>5&&void 0!==arguments[5]&&arguments[5],a=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;const o=s.length,l=[t[0],e.length/t[0]],u=l[1],c=o>0?r[o-1]+1:0;if(c<0)throw new Error("segment ids must be >= 0");const h=t.slice();h[0]=c;const d=_o(n,h.reduce(((e,t)=>e*t),1));if(0===o)return c>0&&d.fill(a),[d,h];if(c<=0)throw new Error("segment ids must be >= 0");let p=0,f=1,g=0,m=r[p];for(;;){let t=0;if(f<o){if(t=r[f],m===t){++f;continue}if(m>=t)throw new Error("segment ids are not increasing")}if(m<0||m>=c)throw new Error(Kx(m,c));m>g&&d.fill(a,g*u,m*u);for(let n=p;n<f;++n){const t=s[n];if(t<0||t>=l[0])throw new Error(Xx(n,s[n],l[0]));for(let n=0;n<u;n++)d[m*u+n]+=e[t*u+n]}if(i)for(let e=0;e<u;e++)d[m*u+e]/=f-p;if(p=f,++f,g=m+1,m=t,f>o)break}return g<c&&d.fill(a,g*u,c*u),[d,h]}const qD={kernelName:Pc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:s,indices:r,segmentIds:i}=t;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error(`Indices should be a vector but received shape\n          ${r.shape}`);if(1!==i.shape.length)throw new Error(`Segment ids should be a vector but received shape\n          ${i.shape}`);if(r.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");const a=n.data.get(s.dataId).values,o=n.data.get(r.dataId).values,l=n.data.get(i.dataId).values,[u,c]=XD(a,s.shape,s.dtype,o,l,!0);return n.makeTensorInfo(c,s.dtype,u)}};const YD={kernelName:zc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:s,indices:r,segmentIds:i}=t;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error(`Indices should be a vector but received shape\n         ${r.shape}`);if(1!==i.shape.length)throw new Error(`Segment ids should be a vector but received shape\n         ${i.shape}`);if(r.shape[0]!==i.shape[0])throw new Error("segmentIds and indices should have same size.");const a=n.data.get(s.dataId).values,o=n.data.get(r.dataId).values,l=n.data.get(i.dataId).values,[u,c]=XD(a,s.shape,s.dtype,o,l);return n.makeTensorInfo(c,s.dtype,u)}};const QD={kernelName:Bc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{sparseIndices:r,sparseValues:i,defaultValue:a}=t,{outputShape:o}=s,{sliceRank:l,numUpdates:u,sliceSize:c,strides:h,outputSize:d}=ux(0,r,o),p=!1,f=n.bufferSync(r);let g;switch(i.dtype){case"bool":g=ID(f,n.bufferSync(i),o,d,c,u,l,h,Boolean(n.data.get(a.dataId).values[0]),p);break;case"float32":g=ID(f,n.bufferSync(i),o,d,c,u,l,h,n.data.get(a.dataId).values[0],p);break;case"int32":g=ID(f,n.bufferSync(i),o,d,c,u,l,h,n.data.get(a.dataId).values[0],p);break;case"string":g=ID(f,n.bufferSync(i),o,d,c,u,l,h,Bh(n.data.get(a.dataId).values[0]),p);break;default:throw new Error(`Unsupported type ${i.dtype}`)}return n.makeTensorInfo(o,g.dtype,g.values)}};const ZD={kernelName:Fc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{numOrSizeSplits:i,axis:a}=s,o=Co(a,r.shape)[0],l=Ox(r,i,o),u=new Array(r.shape.length).fill(0),c=r.shape.slice();return l.map((e=>{const t=[...c];t[o]=e;const s=RE({inputs:{x:r},backend:n,attrs:{begin:u,size:t}});return u[o]+=e,s}))}},JD=h_((e=>Math.sqrt(e))),eF=d_(Rc,(e=>Math.sqrt(e))),tF={kernelName:Rc,backendName:"cpu",kernelFunc:eF},nF={kernelName:Vc,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n}=e;const{x:s}=t,r=n;l_(s,"square");const i=r.data.get(s.dataId).values,a=new Float32Array(i.length);for(let o=0;o<i.length;++o){const e=i[o];a[o]=e*e}return{dataId:r.write(a,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},sF=v_(((e,t)=>{const n=e-t;return n*n})),rF=B_(Wc,sF),iF={kernelName:Wc,backendName:"cpu",kernelFunc:rF},aF=h_(((e,t)=>{const{pattern:n,replaceGlobal:s,rewrite:r}=t;return e.replace(new RegExp(n,s?"g":""),r)})),oF=p_(Uc,aF),lF={kernelName:Uc,backendName:"cpu",kernelFunc:oF},uF=d_(ih,((e,t)=>{const n=t;return isNaN(e)?NaN:e>0?1:n.alpha})),cF={kernelName:ih,backendName:"cpu",kernelFunc:uF};function hF(e,t,n,s){const r=Tp(e,t.dtype);for(let i=0;i<r.size;i++){const e=r.indexToLoc(i),a=new Array(e.length);for(let t=0;t<a.length;t++)a[t]=e[t]*n[t]+s[t];r.set(t.get(...a),...e)}return r}const dF={kernelName:Gc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{begin:i,end:a,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:d}=s;l_(r,"stridedSlice");const{finalShapeSparse:p,finalShape:f,isIdentity:g,sliceDim0:m,isSimpleSlice:b,begin:x,end:y,strides:v}=Df(r.shape,i,a,o,l,u,c,h,d);let w;if(g)w=j_({inputs:{x:r},backend:n,attrs:{shape:f}});else if(m||b){go(r.shape.length>=1,(()=>`Input must have rank at least 1, got: ${r.shape.length}`));const e=vf(x,y,v),t=RE({inputs:{x:r},backend:n,attrs:{begin:x,size:e}});w=j_({inputs:{x:t},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(t)}else{const e=hF(p,n.bufferSync(r),v,x);w=n.makeTensorInfo(f,e.dtype,e.values)}return w}};class pF{constructor(e,t,n,s,r,i){this.separator=zh(e),this.nGramWidths=t,this.leftPad=zh(n),this.rightPad=zh(s),this.padWidth=r,this.preserveShort=i}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,s,r,i){for(let a=0;a<r;++a){const o=this.getPadWidth(i),l=Math.max(0,o-a),u=Math.max(0,o-(r-(a+1))),c=i-(l+u),h=t+(l>0?0:a-o);let d=0;d+=l*this.leftPad.length;for(let t=0;t<c;++t)d+=e[h+t].length;d+=u*this.rightPad.length;d+=(l+u+c-1)*this.separator.length,n[s+a]=new Uint8Array(d);const p=n[s+a];let f=0;const g=e=>e.forEach((e=>p[f++]=e));for(let e=0;e<l;++e)g(this.leftPad),g(this.separator);for(let t=0;t<c-1;++t)g(e[h+t]),g(this.separator);if(c>0){g(e[h+c-1]);for(let e=0;e<u;++e)g(this.separator),g(this.rightPad)}else{for(let e=0;e<u-1;++e)g(this.rightPad),g(this.separator);g(this.rightPad)}}}compute(e,t){const n=e.length,s=t.length;if(s>0){let e=t[0];if(0!==e)throw new Error(`First split value must be 0, got ${e}`);for(let r=1;r<s;++r){let s=t[r]>=e;if(s=s&&t[r]<=n,!s)throw new Error(`Invalid split value ${t[r]}, must be in [${e}, ${n}]`);e=t[r]}if(e!==n)throw new Error(`Last split value must be data size. Expected ${n}, got ${e}`)}const r=s-1,i=_o("int32",s);if(0===n||0===s){const e=new Array(n);for(let t=0;t<=r;++t)i[t]=0;return[e,i]}i[0]=0;for(let o=1;o<=r;++o){const e=t[o]-t[o-1];let n=0;this.nGramWidths.forEach((t=>{n+=this.getNumNGrams(e,t)})),this.preserveShort&&e>0&&0===n&&(n=1),i[o]=i[o-1]+n}const a=new Array(i[r]);for(let o=0;o<r;++o){const n=t[o];let s=i[o];if(this.nGramWidths.forEach((r=>{const i=t[o+1]-t[o],l=this.getNumNGrams(i,r);this.createNGrams(e,n,a,s,l,r),s+=l})),this.preserveShort&&s===i[o]){const r=t[o+1]-t[o];if(0===r)continue;const i=r+2*this.padWidth,l=1;this.createNGrams(e,n,a,s,l,i)}}return[a,i]}}function fF(e,t,n,s,r,i,a,o){return new pF(n,s,r,i,a,o).compute(e,t)}const gF={kernelName:Hc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{separator:r,nGramWidths:i,leftPad:a,rightPad:o,padWidth:l,preserveShortSequences:u}=s,{data:c,dataSplits:h}=t,d=n.data.get(c.dataId).values,p=n.data.get(h.dataId).values,[f,g]=fF(d,p,r,i,a,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",g)]}};function mF(e,t,n,s){if(!e.length)return;if(0===t.length){for(let t=0;t<e.length;++t)s.push(e.subarray(t,t+1));return}if(1===t.length){const r=t[0];let i=e.indexOf(r);for(;-1!==i;){const t=e.subarray(0,i);n&&0===t.length||s.push(t),i=(e=e.subarray(i+1)).indexOf(r)}return void(n&&0===e.length||s.push(e))}let r=0;for(let i=0;i<e.length+1;i++)if(i===e.length||-1!==t.indexOf(e[i])){const t=e.subarray(r,i);n&&0===t.length||s.push(t),r=i+1}}function bF(e,t,n){const s=e.length,r=[];let i=0,a=0;const o=new Array(s);for(let d=0;d<s;++d){const s=r.length;mF(e[d],t,n,r);const l=r.length-s;o[d]=l,i+=l,a=Math.max(a,l)}const l=_o("int32",2*i),u=new Array(i),c=[s,a];let h=0;for(let d=0;d<s;++d)for(let e=0;e<o[d];++e)l[2*h]=d,l[2*h+1]=e,u[h]=r[h],++h;return[l,u,c]}const xF={kernelName:jc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{skipEmpty:r}=s,{input:i,delimiter:a}=t;if("string"!==i.dtype)throw new Error("Input must be of datatype string");if(1!==i.shape.length)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(0!==a.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${a.shape}`);const o=n.data.get(i.dataId).values,l=n.data.get(a.dataId).values[0],[u,c,h]=bF(o,l,r),d=c.length;return[n.makeTensorInfo([d,2],"int32",u),n.makeTensorInfo([d],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(h))]}};function yF(e,t){const n=_o("int32",e.length);for(let s=0;s<e.length;++s)n[s]=Mh(e[s]).modulo(t).getLowBitsUnsigned();return n}const vF={kernelName:Kc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{numBuckets:r}=s,{input:i}=t;if("string"!==i.dtype)throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const a=yF(n.data.get(i.dataId).values,r);return n.makeTensorInfo(i.shape,"int32",a)}},wF=d_(qc,(e=>Math.tan(e))),kF={kernelName:qc,backendName:"cpu",kernelFunc:wF},SF=d_(Yc,(e=>Math.tanh(e)));const IF={kernelName:wc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{tensor:s,indices:r,updates:i}=t,{sliceRank:a,numUpdates:o,sliceSize:l,strides:u,outputSize:c}=ux(0,r,s.shape),h=n.bufferSync(r),d=n.bufferSync(i),p=n.bufferSync(s),f=ID(h,d,s.shape,c,l,o,a,u,p,!1);return n.makeTensorInfo(s.shape,f.dtype,f.values)}};function CF(e,t){const n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=e.shape[r]*t[r];const s=Tp(n,e.dtype);for(let r=0;r<s.values.length;++r){const t=s.indexToLoc(r),n=new Array(e.rank);for(let s=0;s<n.length;s++)n[s]=t[s]%e.shape[s];const i=e.locToIndex(n);s.values[r]=e.values[i]}return s}const NF={kernelName:Qc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{reps:i}=s;l_(r,"tile");const a=CF(n.bufferSync(r),i);return n.makeTensorInfo(a.shape,a.dtype,a.values)}},TF=(e,t)=>{const n=t.value-e.value;return 0===n?e.index-t.index:n};function _F(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:e.length-1;for(;s>n;){if(s-n>600){const r=s-n+1,i=t-n+1,a=Math.log(r),o=.5*Math.exp(2*a/3),l=.5*Math.sqrt(a*o*(r-o)/r)*Math.sign(i-r/2);_F(e,t,Math.max(n,Math.floor(t-i*o/r+l)),Math.min(s,Math.floor(t+(r-i)*o/r+l)))}const r=e[t];let i=n,a=s;for(fo(e,n,t),TF(e[s],r)>0&&fo(e,n,s);i<a;){for(fo(e,i,a),i++,a--;TF(e[i],r)<0;)i+=1;for(;TF(e[a],r)>0;)a-=1}0===TF(e[n],r)?fo(e,n,a):(a+=1,fo(e,a,s)),a<=t&&(n=a+1),t<=a&&(s=a-1)}}function EF(e,t,n,s,r){const i=t[t.length-1],[a,o]=[e.length/i,i],l=To(n,a*s),u=To("int32",a*s);for(let h=0;h<a;h++){const t=h*o,n=e.subarray(t,t+o);let i=new Array(n.length);n.forEach(((e,t)=>i[t]={value:e,index:t})),s<i.length&&(_F(i,s),i=i.slice(0,s)),r&&i.sort(TF);const a=h*s,c=l.subarray(a,a+s),d=u.subarray(a,a+s);for(let e=0;e<s;e++)c[e]=i[e].value,d[e]=i[e].index}const c=t.slice();return c[c.length-1]=s,[Tp(c,n,l),Tp(c,"int32",u)]}const $F={kernelName:Zc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{k:i,sorted:a}=s;l_(r,"topk");const o=n.data.get(r.dataId).values,[l,u]=EF(o,r.shape,r.dtype,i,a);return[n.makeTensorInfo(l.shape,l.dtype,l.values),n.makeTensorInfo(u.shape,u.dtype,u.values)]}};const RF={kernelName:Jc,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:s}=e,{image:r,transforms:i}=t,{interpolation:a,fillMode:o,fillValue:l,outputShape:u}=n,[c,h,d,p]=r.shape,[f,g]=null!=u?u:[h,d],m=[c,f,g,p],b=Oo(r.shape),x=b[0],y=b[1],v=b[2],w=Oo(m),k=w[0],S=w[1],I=w[2],C=To(r.dtype,xo(m));C.fill(l);const N=s.data.get(r.dataId).values,T=s.data.get(i.dataId).values;for(let _=0;_<c;++_){const e=1===i.shape[0]?T:T.subarray(8*_,8*_+8);for(let t=0;t<f;++t)for(let n=0;n<g;++n)for(let s=0;s<p;++s){let r;const i=e[6]*n+e[7]*t+1;if(0===i)continue;const u=(e[0]*n+e[1]*t+e[2])/i,c=(e[3]*n+e[4]*t+e[5])/i,p=AF(u,d,o),f=AF(c,h,o);switch(a){case"nearest":r=FF(N,h,d,x,y,v,_,f,p,s,l);break;case"bilinear":r=MF(N,h,d,x,y,v,_,f,p,s,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${a}`)}C[_*k+t*S+n*I+s]=r}return s.makeTensorInfo(m,r.dtype,C)}return{dataId:s.write(C,m,r.dtype),shape:r.shape,dtype:r.dtype}}};function AF(e,t,n){switch(n){case"reflect":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=2*t;n<e&&(n=e*Math.trunc(-n/e)+n),n=n<-t?n+e:-n-1}else if(n>t-1)if(t<=1)n=0;else{const e=2*t;n-=e*Math.trunc(n/e),n>=t&&(n=e-n-1)}return ho(0,n,t-1)}(e,t);case"wrap":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=t-1;n+=t*(Math.trunc(-n/e)+1)}else if(n>t-1)if(t<=1)n=0;else{const e=t-1;n-=t*Math.trunc(n/e)}return ho(0,n,t-1)}(e,t);case"nearest":return function(e,t){return ho(0,e,t-1)}(e,t);default:return function(e){return e}(e)}}function DF(e,t,n,s,r,i,a,o,l,u,c){return 0<=o&&o<t&&0<=l&&l<n?e[a*s+o*r+l*i+u]:c}function FF(e,t,n,s,r,i,a,o,l,u,c){return DF(e,t,n,s,r,i,a,Math.round(o),Math.round(l),u,c)}function MF(e,t,n,s,r,i,a,o,l,u,c){const h=Math.floor(o),d=Math.floor(l),p=h+1,f=d+1;return(p-o)*((f-l)*DF(e,t,n,s,r,i,a,h,d,u,c)+(l-d)*DF(e,t,n,s,r,i,a,h,f,u,c))+(o-h)*((f-l)*DF(e,t,n,s,r,i,a,p,d,u,c)+(l-d)*DF(e,t,n,s,r,i,a,p,f,u,c))}function OF(e,t,n,s){const r=Co(t,n)[0],i=[1,n[0],1];for(let f=0;f<r;f++)i[0]*=n[f];i[1]=n[r];for(let f=r+1;f<n.length;f++)i[2]*=n[f];const a=new Map,o=new Int32Array(n[r]),l=new Qh(i,s,e),u=[],c=1===i[0]&&1===i[2];for(let f=0;f<n[r];f++){let t;if(c)t=e[f].toString();else{const e=[];for(let t=0;t<i[0];t++)for(let n=0;n<i[2];n++)e.push(l.get(t,f,n));t=e.join(",")}const n=a.get(t);if(null!=n)o[f]=n;else{const e=a.size;a.set(t,e),o[f]=e,u.push(f)}}const h=i.slice();h[1]=a.size;const d=new Qh(h,s);u.forEach(((e,t)=>{for(let n=0;n<i[0];n++)for(let s=0;s<i[2];s++)d.set(l.get(n,e,s),n,t,s)}));const p=n.slice();return p[r]=h[1],{outputValues:d.values,outputShape:p,indices:o}}const LF={kernelName:th,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:s}=e,{axis:r}=n,{x:i}=t;l_(i,"unique");const a=s.data.get(i.dataId).values,{outputValues:o,outputShape:l,indices:u}=OF(a,r,i.shape,i.dtype);return[s.makeTensorInfo(l,i.dtype,o),s.makeTensorInfo([u.length],"int32",u)]}};const PF={kernelName:nh,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{value:r}=t;let{axis:i}=s;i<0&&(i+=r.shape.length);const a=r.shape.length,o=r.shape[i],l=new Array(a-1);let u=0;for(let p=0;p<a;p++)p!==i&&(l[u++]=r.shape[p]);const c=new Array(a).fill(0),h=r.shape.slice();h[i]=1;const d=new Array(o);for(let p=0;p<d.length;p++){c[i]=p;const e=RE({inputs:{x:r},backend:n,attrs:{begin:c,size:h}});d[p]=j_({inputs:{x:e},backend:n,attrs:{shape:l}}),n.disposeIntermediateTensorInfo(e)}return d}};const zF={kernelName:sh,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,segmentIds:i}=t,{numSegments:a}=s;l_(r,"unsortedSegmentSum");const o=[],l=[],u=r.shape.length-i.shape.length;let c=i;for(let d=0;d<u;++d){const e=G$({inputs:{input:c},backend:n,attrs:{dim:d+1}});c=e,l.push(e)}for(let d=0;d<a;++d){const e=Oh(d,"int32"),t=n.makeTensorInfo([],"int32",e),s=R$({inputs:{a:t,b:c},backend:n}),i=P_({inputs:{x:s},backend:n,attrs:{dtype:"float32"}}),a=I$({inputs:{a:i,b:r},backend:n}),u=N$({inputs:{x:a},backend:n,attrs:{axis:0,keepDims:!1}});o.push(u),l.push(t),l.push(s),l.push(i),l.push(a),l.push(u)}const h=WA({inputs:o,backend:n,attrs:{axis:0}});return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),h}},BF=[Y_,Z_,eE,nE,H_,sE,oE,lE,uE,cE,dE,fE,mE,yE,wE,CE,NE,TE,_E,q_,EE,DE,OE,PE,zE,z_,VE,GE,D_,HE,YE,ZE,JE,e$,t$,n$,s$,i$,o$,l$,u$,c$,h$,d$,f$,g$,m$,b$,x$,y$,v$,w$,_$,g_,E$,A$,B$,U$,H$,X$,iR,oR,lR,hR,fR,gR,mR,xR,vR,SR,NR,b_,TR,XE,ER,RR,DR,y_,OR,zR,WR,GR,jR,qR,QR,eA,tA,nA,iA,lA,uA,cA,hA,dA,pA,fA,gA,xA,yA,kA,CA,C$,TA,EA,RA,DA,OA,LA,BA,VA,UA,jA,S_,XA,JA,nD,lD,cD,O_,Q$,dD,C_,T_,K_,pD,fD,gD,mD,bD,xD,vD,SD,CD,_D,ED,DD,$_,MD,LD,zD,AE,IA,VD,UD,HD,KD,qD,YD,QD,ZD,tF,nF,iF,lF,cF,dF,gF,xF,vF,tR,T$,kF,{kernelName:Yc,backendName:"cpu",kernelFunc:SF},IF,NF,$F,RF,aE,LF,PF,zF,zA];for(const n of BF)xh(n);const WF={},VF={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function UF(e,t){if(!(e in WF)||null!=t){const n=function(e,t){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=null==t?function(e){if(qo().getBool("IS_SAFARI")||"undefined"===typeof OffscreenCanvas||2!==e){if("undefined"!==typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}return new OffscreenCanvas(300,150)}(e):t;n.addEventListener("webglcontextlost",(t=>{t.preventDefault(),delete WF[e]}),!1),qo().getBool("SOFTWARE_WEBGL_ENABLED")&&(VF.failIfMajorPerformanceCaveat=!1);if(1===e)return n.getContext("webgl",VF)||n.getContext("experimental-webgl",VF);return n.getContext("webgl2",VF)}(e,t);if(null===n)return console.log("Could not get context for WebGL version",e),null;WF[e]=n}const n=WF[e];return null==n||n.isContextLost()?(delete WF[e],UF(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),WF[e])}var GF,HF,jF;function KF(e,t){return[t,e]}function XF(e){const t=xo(e);return wo(Math.ceil(t/4))}function qF(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function YF(e,t){const n=e;let s,r,i,a,o,l,u,c,h,d;return 2===qo().getNumber("WEBGL_VERSION")?(s=n.R32F,r=n.R16F,i=n.RGBA16F,a=n.RGBA32F,o=n.RED,u=4,c=1,h=n.HALF_FLOAT,d=n.FLOAT,l=n.RGBA8):(s=e.RGBA,r=e.RGBA,i=e.RGBA,a=n.RGBA,o=e.RGBA,u=4,c=4,h=null!=t?t.HALF_FLOAT_OES:null,d=e.FLOAT,l=e.RGBA),{internalFormatFloat:s,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:i,internalFormatPackedFloat:a,textureFormatFloat:o,downloadTextureFormat:l,downloadUnpackNumChannels:u,defaultNumChannels:c,textureTypeHalfFloat:h,textureTypeFloat:d}}function QF(e,t){const n=t();return qo().getBool("DEBUG")&&function(e){const t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+function(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}(e,t))}(e),n}!function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"}(GF||(GF={})),function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(HF||(HF={})),function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(jF||(jF={}));function ZF(e){return!!(qo().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||5.96e-8<Math.abs(e)&&Math.abs(e)<65504)}function JF(e,t){return lM(e,(()=>e.getExtension(t)),'Extension "'+t+'" not supported on this browser.')}const eM=/ERROR: [0-9]+:([0-9]+):/g;function tM(e,t){const n=eM.exec(t);if(null==n)return console.log(`Couldn't parse line number in error: ${t}`),void console.log(e);const s=+n[1],r=e.split("\n"),i=r.length.toString().length+2,a=r.map(((e,t)=>ko((t+1).toString(),i)+e));let o=0;for(let h=0;h<a.length;h++)o=Math.max(a[h].length,o);const l=a.slice(0,s-1),u=a.slice(s-1,s),c=a.slice(s);console.log(l.join("\n")),console.log(t.split("\n")[0]),console.log(`%c ${ko(u[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(c.join("\n"))}function nM(e,t){if(QF(e,(()=>e.validateProgram(t))),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function sM(e,t,n,s,r,i,a){const o=e.getAttribLocation(t,n);return-1!==o&&(QF(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,s))),QF(e,(()=>e.vertexAttribPointer(o,r,e.FLOAT,!1,i,a))),QF(e,(()=>e.enableVertexAttribArray(o))),!0)}function rM(e,t,n,s){QF(e,(()=>function(e,t,n){uM(e,n),QF(e,(()=>e.activeTexture(e.TEXTURE0+n))),QF(e,(()=>e.bindTexture(e.TEXTURE_2D,t)))}(e,t,s))),QF(e,(()=>e.uniform1i(n,s)))}function iM(e,t,n){QF(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,n))),QF(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0)))}function aM(e,t){QF(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,t))),QF(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0)))}function oM(e){const t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}(e,t))}function lM(e,t,n){const s=QF(e,(()=>t()));if(null==s)throw new Error(n);return s}function uM(e,t){const n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,s=t+e.TEXTURE0;if(s<e.TEXTURE0||s>n){throw new Error(`textureUnit must be in ${`[gl.TEXTURE0, gl.TEXTURE${n}]`}.`)}}function cM(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2;return xo(e.slice(0,e.length-t))}function hM(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function dM(e){let t=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(t=[cM(e),...hM(e)]),t}function pM(e){return e%2===0}function fM(e,t){if(yo(e=e.slice(-2),t=t.slice(-2)))return!0;if(!e.length||!t.length)return!0;if(0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){const n=e[e.length-1],s=t[t.length-1];if(n===s)return!0;if(pM(n)&&pM(s)&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&pM(e[0])&&pM(t[0])}let gM,mM;function bM(e,t){return null!=e.getExtension(t)}function xM(e){try{if(null!=UF(e))return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function yM(e){if(0===e)return!1;const t=UF(e);if(1!==e){if(bM(t,"EXT_color_buffer_float"))return vM(t);const e="EXT_color_buffer_half_float";if(bM(t,e)){const n=t.getExtension(e);return function(e,t){const n=YF(e,t),s=e.createTexture();e.bindTexture(e.TEXTURE_2D,s);const r=1,i=1;e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,r,i,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const a=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,a),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,s,0);const o=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(s),e.deleteFramebuffer(a),o}(t,n)}return!1}if(!bM(t,"OES_texture_float"))return!1;if(!bM(t,"WEBGL_color_buffer_float"))return!1;return vM(t)}function vM(e){const t=YF(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n);e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const s=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,s),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);const r=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(s),r}function wM(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&go("complex64"!==e.dtype,(()=>`${t} does not support complex64 tensors in the WebGL backend.`))}))}const kM=qo();function SM(){let e,t,n,s,r,i,a,o,l,u;return 2===qo().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",s="in",r="texture",i="outputColor",a="out vec4 outputColor;",o=qo().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",l="",u="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",t="attribute",n="varying",s="varying",r="texture2D",i="gl_FragColor",a="",o="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",l="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",u="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:t,varyingVs:n,varyingFs:s,texture2D:r,output:i,defineOutput:a,defineSpecialNaN:o,defineSpecialInf:l,defineRound:u}}function IM(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const s=Oo(t);return s.map(((t,r)=>`${`int ${e[r]} = ${n} / ${t}`}; ${r===s.length-1?`int ${e[r+1]} = ${n} - ${e[r]} * ${t}`:`index -= ${e[r]} * ${t}`};`)).join("")}function CM(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const s=Oo(t);return s.map(((t,r)=>`${`int ${e[r]} = ${n} / outShapeStrides[${r}]`}; ${r===s.length-1?`int ${e[r+1]} = ${n} - ${e[r]} * outShapeStrides[${r}]`:`index -= ${e[r]} * outShapeStrides[${r}]`};`)).join("")}function NM(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const s=function(e,t){const n=e.length,s=e.map((e=>`${t}[${e}]`)),r=new Array(n-1);r[n-2]=s[n-1];for(let i=n-3;i>=0;--i)r[i]=`(${r[i+1]} * ${s[i+1]})`;return r}(e.map(((e,t)=>t)),t);return s.map(((t,r)=>`${`int ${e[r]} = ${n} / ${s[r]}`}; ${r===s.length-1?`int ${e[r+1]} = ${n} - ${e[r]} * ${s[r]}`:`index -= ${e[r]} * ${s[r]}`};`)).join("")}function TM(e){const t=Oo(e).map((e=>e.toString()));return`\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;\n  }\n`}kM.registerFlag("HAS_WEBGL",(()=>kM.getNumber("WEBGL_VERSION")>0)),kM.registerFlag("WEBGL_VERSION",(()=>xM(2)?2:xM(1)?1:0)),kM.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(()=>!1)),kM.registerFlag("WEBGL_BUFFER_SUPPORTED",(()=>2===kM.get("WEBGL_VERSION"))),kM.registerFlag("WEBGL_CPU_FORWARD",(()=>!0)),kM.registerFlag("WEBGL_FORCE_F16_TEXTURES",(()=>!1)),kM.registerFlag("WEBGL_PACK",(()=>kM.getBool("HAS_WEBGL"))),kM.registerFlag("WEBGL_PACK_NORMALIZATION",(()=>kM.getBool("WEBGL_PACK"))),kM.registerFlag("WEBGL_PACK_CLIP",(()=>kM.getBool("WEBGL_PACK"))),kM.registerFlag("WEBGL_PACK_DEPTHWISECONV",(()=>kM.getBool("WEBGL_PACK"))),kM.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(()=>kM.getBool("WEBGL_PACK"))),kM.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(()=>kM.getBool("WEBGL_PACK"))),kM.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(()=>kM.getBool("WEBGL_PACK"))),kM.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(()=>kM.getBool("WEBGL_PACK"))),kM.registerFlag("WEBGL_PACK_REDUCE",(()=>kM.getBool("WEBGL_PACK"))),kM.registerFlag("WEBGL_LAZILY_UNPACK",(()=>kM.getBool("WEBGL_PACK"))),kM.registerFlag("WEBGL_CONV_IM2COL",(()=>kM.getBool("WEBGL_PACK"))),kM.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",(()=>kM.getBool("WEBGL_PACK"))),kM.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(()=>function(e){if(null==gM){const t=UF(e);gM=t.getParameter(t.MAX_TEXTURE_SIZE)}return gM}(kM.getNumber("WEBGL_VERSION")))),kM.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(()=>function(e){if(null==mM){const t=UF(e);mM=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,mM)}(kM.getNumber("WEBGL_VERSION")))),kM.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(()=>{const e=kM.getNumber("WEBGL_VERSION");return 0===e?0:function(e){if(0===e)return 0;let t;const n=UF(e);return t=bM(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:bM(n,"EXT_disjoint_timer_query")?1:0,t}(e)})),kM.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(()=>kM.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!Cd())),kM.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(()=>function(e){if(0===e)return!1;const t=UF(e);if(1===e){if(!bM(t,"OES_texture_float"))return!1}else if(!bM(t,"EXT_color_buffer_float"))return!1;return vM(t)}(kM.getNumber("WEBGL_VERSION")))),kM.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(()=>!kM.getBool("WEBGL_FORCE_F16_TEXTURES")&&kM.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))),kM.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(()=>yM(kM.getNumber("WEBGL_VERSION")))),kM.registerFlag("WEBGL_FENCE_API_ENABLED",(()=>{return 2===(e=kM.getNumber("WEBGL_VERSION"))&&null!=UF(e).fenceSync;var e})),kM.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(()=>kM.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0)),kM.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(()=>-1),(e=>{if("number"!==typeof e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${e}.`);if(e<0&&-1!==e)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${e}.`)})),kM.registerFlag("WEBGL_FLUSH_THRESHOLD",(()=>Cd()?1:-1),(e=>{if("number"!==typeof e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${e}.`);if(e<0&&-1!==e)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${e}.`)})),kM.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",(()=>128)),kM.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",(()=>!1)),kM.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e5)),kM.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",(()=>128)),kM.registerFlag("WEBGL_EXP_CONV",(()=>!1)),kM.registerFlag("SOFTWARE_WEBGL_ENABLED",(()=>kM.getBool("IS_TEST"))),kM.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",(()=>1/0)),kM.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",(()=>!1)),kM.registerFlag("WEBGL2_ISNAN_CUSTOM",(()=>!1)),kM.registerFlag("ENGINE_COMPILE_ONLY",(()=>!1));const _M="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:EM}=s;function $M(e,t,n){const s=[];if(e.forEach((e=>{const t=xo(e.shapeInfo.logicalShape);if(e.shapeInfo.isUniform?s.push(`uniform float ${e.name}${t>1?`[${t}]`:""};`):(s.push(`uniform sampler2D ${e.name};`),s.push(`uniform int offset${e.name};`)),n.enableShapeUniforms){const{uniformShape:t}=WM(n.packedInputs,e.shapeInfo.logicalShape,e.shapeInfo.texShape);switch(t.length){case 1:s.push(`uniform int ${e.name}Shape;`);break;case 2:s.push(`uniform ivec2 ${e.name}Shape;`);break;case 3:s.push(`uniform ivec3 ${e.name}Shape;`);break;case 4:s.push(`uniform ivec4 ${e.name}Shape;`)}s.push(`uniform ivec2 ${e.name}TexShape;`)}})),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:s.push("uniform int outShape;");break;case 2:s.push("uniform ivec2 outShape;"),s.push("uniform int outShapeStrides;");break;case 3:s.push("uniform ivec3 outShape;"),s.push("uniform ivec2 outShapeStrides;");break;case 4:s.push("uniform ivec4 outShape;"),s.push("uniform ivec3 outShapeStrides;")}s.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach((e=>{s.push(`uniform ${e.type} ${e.name}${e.arrayIndex?`[${e.arrayIndex}]`:""};`)}));const r=s.join("\n"),i=e.map((e=>function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],s=arguments.length>3?arguments[3]:void 0,r="";r+=n?AM(e,s):RM(e,s);const i=e.shapeInfo.logicalShape,a=t.logicalShape;i.length<=a.length&&(r+=n?function(e,t){const n=e.name,s=n.charAt(0).toUpperCase()+n.slice(1),r="get"+s+"AtOutCoords",i=e.shapeInfo.logicalShape.length,a=t.logicalShape.length,o=EM(e.shapeInfo.logicalShape,t.logicalShape),l=BM(a),u=a-i;let c;const h=["x","y","z","w","u","v"];c=0===i?"":a<2&&o.length>=1?"coords = 0;":o.map((e=>`coords.${h[e+u]} = 0;`)).join("\n");let d="";d=a<2&&i>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${h[t+u]}`)).join(", ");let p="return outputValue;";const f=1===xo(e.shapeInfo.logicalShape),g=xo(t.logicalShape),m=1===g;if(1!==i||f||m){if(f&&!m)p=1===a?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(o.length){const e=i-2,t=i-1;o.indexOf(e)>-1&&o.indexOf(t)>-1?p="return vec4(outputValue.x);":o.indexOf(e)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":o.indexOf(t)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}}else p="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return`\n    vec4 ${r}() {\n      ${l} coords = getOutputCoords();\n      ${c}\n      vec4 outputValue = get${s}(${d});\n      ${p}\n    }\n  `}(e,t):function(e,t){const n=e.name,s=n.charAt(0).toUpperCase()+n.slice(1),r="get"+s+"AtOutCoords",i=t.texShape,a=e.shapeInfo.texShape,o=e.shapeInfo.logicalShape.length,l=t.logicalShape.length;if(!e.shapeInfo.isUniform&&o===l&&null==e.shapeInfo.flatOffset&&yo(a,i))return`\n      float ${r}() {\n        return sampleTexture(${n}, resultUV);\n      }\n    `;const u=BM(l),c=EM(e.shapeInfo.logicalShape,t.logicalShape),h=l-o;let d;const p=["x","y","z","w","u","v"];d=0===o?"":l<2&&c.length>=1?"coords = 0;":c.map((e=>`coords.${p[e+h]} = 0;`)).join("\n");let f="";f=l<2&&o>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>`coords.${p[t+h]}`)).join(", ");return`\n    float ${r}() {\n      ${u} coords = getOutputCoords();\n      ${d}\n      return get${s}(${f});\n    }\n  `}(e,t));return r}(e,t,n.packedInputs,n.enableShapeUniforms))).join("\n"),a=t.texShape,o=SM(),l=function(e){return`\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ${e.texture2D}(textureSampler, uv).r;\n    }\n  `}(o);let u,c,h=function(e){const t=`${e.version}\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ${e.varyingFs} vec2 resultUV;\n    ${e.defineOutput}\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ${e.defineSpecialNaN}\n    ${e.defineSpecialInf}\n    ${e.defineRound}\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ${DM}\n    ${FM}\n    ${MM}\n  `;return t}(o);t.isPacked?(u=function(e,t,n){switch(e.length){case 0:return LM();case 1:return function(e,t,n){const s=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(1===s[0])return n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ${s[1]}.0);\n      }\n    `;if(1===s[1])return n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":`\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ${s[0]}.0);\n      }\n    `;if(n)return"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ";return`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${s[0]}, ${s[1]}));\n      return 2 * (resTexRC.x * ${s[1]} + resTexRC.y);\n    }\n  `}(0,t,n);case 2:return function(e,t,n){const s=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(yo(e,t))return n?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(${s[0]}, ${s[1]}));\n      }\n    `;const r=Math.ceil(e[1]/2);if(n)return"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ";return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${s[0]}, ${s[1]}));\n\n      int index = resTexRC.x * ${s[1]} + resTexRC.y;\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec2(r, c);\n    }\n  `}(e,t,n);case 3:return function(e,t,n){if(n)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const s=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[2]/2),i=r*Math.ceil(e[1]/2);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${s[0]}, ${s[1]}));\n      int index = resTexRC.x * ${s[1]} + resTexRC.y;\n\n      int b = index / ${i};\n      index -= b * ${i};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec3(b, r, c);\n    }\n  `}(e,t,n);default:return function(e,t,n){if(n)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const s=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[e.length-1]/2),i=r*Math.ceil(e[e.length-2]/2);let a=i,o="",l="b, r, c";for(let u=2;u<e.length-1;u++)a*=e[e.length-u-1],o=`\n      int b${u} = index / ${a};\n      index -= b${u} * ${a};\n    `+o,l=`b${u}, `+l;return`\n    ivec${e.length} getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${s[0]}, ${s[1]}));\n      int index = resTexRC.x * ${s[1]} + resTexRC.y;\n\n      ${o}\n\n      int b = index / ${i};\n      index -= b * ${i};\n\n      int r = 2 * (index / ${r});\n      int c = imod(index, ${r}) * 2;\n\n      return ivec${e.length}(${l});\n    }\n  `}(e,t,n)}}(t.logicalShape,a,n.enableShapeUniforms),c=function(e){return`\n    void setOutput(vec4 val) {\n      ${e.output} = val;\n    }\n  `}(o)):(u=function(e,t,n){switch(e.length){case 0:return LM();case 1:return function(e,t,n){if(1===t[0])return n?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.x * ${t[1]}.0);\n      }\n    `;if(1===t[1])return n?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":`\n      int getOutputCoords() {\n        return int(resultUV.y * ${t[0]}.0);\n      }\n    `;if(n)return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ";return`\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      return resTexRC.x * ${t[1]} + resTexRC.y;\n    }\n  `}(0,t,n);case 2:return function(e,t,n){if(yo(e,t))return n?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\n      }\n    `;if(1===e[1])return n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    `;if(1===e[0])return n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":`\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(${t[0]}, ${t[1]}));\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\n        return ivec2(0, index);\n      }\n    `;if(n)return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ";return`\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      int r = index / ${e[1]};\n      int c = index - r * ${e[1]};\n      return ivec2(r, c);\n    }\n  `}(e,t,n);case 3:return function(e,t,n){if(n){return`\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ${CM(["r","c","d"],e)}\n    return ivec3(r, c, d);\n  }\n`}const s=IM(["r","c","d"],e);return`\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${s}\n      return ivec3(r, c, d);\n    }\n  `}(e,t,n);case 4:return function(e,t,n){if(n){return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ${CM(["r","c","d","d2"],e)}\n      return ivec4(r, c, d, d2);\n    }\n  `}const s=IM(["r","c","d","d2"],e);return`\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n      ${s}\n      return ivec4(r, c, d, d2);\n    }\n  `}(e,t,n);case 5:return function(e,t){const n=IM(["r","c","d","d2","d3"],e);return`\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},\n                             ${t[1]}));\n\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  `}(e,t);case 6:return function(e,t){const n=IM(["r","c","d","d2","d3","d4"],e);return`\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(${t[0]}, ${t[1]}));\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\n\n      ${n}\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  `}(e,t);default:throw new Error(`${e.length}-D output sampling is not yet supported`)}}(t.logicalShape,a,n.enableShapeUniforms),c=function(e){return`\n    void setOutput(float val) {\n      ${e.output} = vec4(val, 0, 0, 0);\n    }\n  `}(o)),n.packedInputs&&(h+=OM);return[h,l,c,r,u,i,n.userCode].join("\n")}function RM(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const n=e.shapeInfo.logicalShape;switch(n.length){case 0:return function(e,t){const n=e.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`float ${s}() {return ${n};}`;const[r,i]=e.shapeInfo.texShape;if(1===r&&1===i)return`\n      float ${s}() {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;const a=PM(n);if(t)return`\n    float ${s}() {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${a});\n      return sampleTexture(${n}, uv);\n    }\n  `;const[o,l]=e.shapeInfo.texShape;return`\n    float ${s}() {\n      vec2 uv = uvFromFlat(${o}, ${l}, ${a});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e,t);case 1:return function(e,t){const n=e.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return`\n      float ${s}(int index) {\n        ${zM(e)}\n      }\n    `;const r=e.shapeInfo.texShape,i=r[0],a=r[1];if(1===a&&1===i)return`\n      float ${s}(int index) {\n        return sampleTexture(${n}, halfCR);\n      }\n    `;const o=PM(n);if(1===a)return t?`\n      float ${s}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${n}TexShape[0]));\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${s}(int index) {\n        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${i}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(1===i)return t?`\n      float ${s}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${n}TexShape[1]), 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `:`\n      float ${s}(int index) {\n        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${a}.0, 0.5);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(t)return`\n    float ${s}(int index) {\n      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `;return`\n    float ${s}(int index) {\n      vec2 uv = uvFromFlat(${i}, ${a}, index + ${o});\n      return sampleTexture(${n}, uv);\n    }\n  `}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,s=e.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=e.shapeInfo.texShape;if(null!=i&&yo(n,i)){if(t)return`\n      float ${r}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);\n        return sampleTexture(${s}, uv);\n      }\n    `;const e=i[0];return`\n    float ${r}(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${i[1]}.0, ${e}.0);\n      return sampleTexture(${s}, uv);\n    }\n  `}const{newShape:a,keptDims:o}=No(n),l=a;if(l.length<n.length){const n=["row","col"];return`\n      ${RM(VM(e,l),t)}\n      float ${r}(int row, int col) {\n        return ${r}(${UM(n,o)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));\n        ${zM(e)}\n      }\n    `;const u=i[0],c=i[1],h=PM(s);if(1===c)return t?`\n      float ${r}(int row, int col) {\n        float index = dot(vec3(row, col, ${h}), vec3(${s}Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(${s}TexShape[0]));\n        return sampleTexture(${s}, uv);\n      }\n    `:`\n    float ${r}(int row, int col) {\n      float index = dot(vec3(row, col, ${h}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);\n      return sampleTexture(${s}, uv);\n    }\n  `;if(1===u)return t?`\n      float ${r}(int row, int col) {\n        float index = dot(vec3(row, col, ${h}), vec3(${s}Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(${s}TexShape[1]), 0.5);\n        return sampleTexture(${s}, uv);\n      }\n    `:`\n    float ${r}(int row, int col) {\n      float index = dot(vec3(row, col, ${h}), vec3(${n[1]}, 1, 1));\n      vec2 uv = vec2((index + 0.5) / ${c}.0, 0.5);\n      return sampleTexture(${s}, uv);\n    }\n  `;if(t)return`\n      float ${r}(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${s}Shape[1] + col + ${h};\n        vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);\n        return sampleTexture(${s}, uv);\n      }\n    `;return`\n  float ${r}(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ${n[1]} + col + ${h};\n    vec2 uv = uvFromFlat(${u}, ${c}, index);\n    return sampleTexture(${s}, uv);\n  }\n`}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,s=e.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=n[1]*n[2],a=n[2],{newShape:o,keptDims:l}=No(n),u=o;if(u.length<n.length){const n=["row","col","depth"];return`\n        ${RM(VM(e,u),t)}\n        float ${r}(int row, int col, int depth) {\n          return ${r}(${UM(n,l)});\n        }\n      `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(${i}, ${a}, 1)));\n        ${zM(e)}\n      }\n    `;const c=e.shapeInfo.texShape,h=c[0],d=c[1],p=e.shapeInfo.flatOffset;if(d===i&&null==p)return t?`\n      float ${r}(int row, int col, int depth) {\n        int stride1 = ${s}Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${s}TexShape[1], ${s}TexShape[0]);\n        return sampleTexture(${s}, uv);\n      }\n    `:`\n        float ${r}(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(${a}, 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(${d}.0, ${h}.0);\n          return sampleTexture(${s}, uv);\n        }\n      `;if(d===a&&null==p)return t?`\n      float ${r}(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(${s}Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);\n        return sampleTexture(${s}, uv);\n      }\n    `:`\n    float ${r}(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${h}.0);\n      return sampleTexture(${s}, uv);\n    }\n  `;const f=PM(s);if(t)return`\n    float ${r}(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ${s}Shape[1] * ${s}Shape[2];\n      int stride1 = ${s}Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ${f};\n      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);\n      return sampleTexture(${s}, uv);\n    }\n    `;return`\n      float ${r}(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ${i} + col * ${a} + depth + ${f};\n        vec2 uv = uvFromFlat(${h}, ${d}, index);\n        return sampleTexture(${s}, uv);\n      }\n  `}(e,t);case 4:return function(e,t){const n=e.shapeInfo.logicalShape,s=e.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=n[3],a=n[2]*i,o=n[1]*a,{newShape:l,keptDims:u}=No(n);if(l.length<n.length){const n=["row","col","depth","depth2"];return`\n      ${RM(VM(e,l),t)}\n      float ${r}(int row, int col, int depth, int depth2) {\n        return ${r}(${UM(n,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${r}(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(${o}, ${a}, ${i}, 1)));\n        ${zM(e)}\n      }\n    `;const c=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,d=h[0],p=h[1],f=`int stride2 = ${s}Shape[3];`,g=`int stride1 = ${s}Shape[2] * stride2;`,m=`int stride0 = ${s}Shape[1] * stride1;`;if(p===o&&null==c)return t?`\n      float ${r}(int row, int col, int depth, int depth2) {\n        ${f}\n        ${g}\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${s}TexShape[1], ${s}TexShape[0]);\n        return sampleTexture(${s}, uv);\n      }\n    `:`\n      float ${r}(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(${a}, ${i}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${d}.0);\n        return sampleTexture(${s}, uv);\n      }\n    `;if(p===i&&null==c)return t?`\n      float ${r}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${s}Shape[1] * ${s}Shape[2], ${s}Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${s}TexShape[1], ${s}TexShape[0]);\n        return sampleTexture(${s}, uv);\n      }\n    `:`\n      float ${r}(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(${n[1]*n[2]}, ${n[2]}, 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${d}.0);\n        return sampleTexture(${s}, uv);\n      }\n    `;const b=PM(s);if(t)return`\n    float ${r}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ${f}\n      ${g}\n      ${m}\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index + ${b});\n      return sampleTexture(${s}, uv);\n    }\n  `;return`\n    float ${r}(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${a} +\n          depth * ${i} + depth2;\n      vec2 uv = uvFromFlat(${d}, ${p}, index + ${b});\n      return sampleTexture(${s}, uv);\n    }\n  `}(e,t);case 5:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),r=t[4],i=t[3]*r,a=t[2]*i,o=t[1]*a,{newShape:l,keptDims:u}=No(t);if(l.length<t.length){const t=["row","col","depth","depth2","depth3"];return`\n      ${RM(VM(e,l))}\n      float ${s}(int row, int col, int depth, int depth2, int depth3) {\n        return ${s}(${UM(t,u)});\n      }\n    `}if(e.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${o}, ${a}, ${i}, ${r})) +\n          depth3;\n        ${zM(e)}\n      }\n    `;const c=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,d=h[0],p=h[1];if(p===o&&null==c)return`\n      float ${s}(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(${a}, ${i}, ${r}, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${p}.0, ${d}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(p===r&&null==c)return`\n      float ${s}(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]},\n               ${t[2]*t[3]}, ${t[3]}, 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${p}.0, ${d}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;const f=PM(n);return`\n    float ${s}(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${o} + col * ${a} + depth * ${i} +\n          depth2 * ${r} + depth3 + ${f};\n      vec2 uv = uvFromFlat(${d}, ${p}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);case 6:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:r,keptDims:i}=No(t);if(r.length<t.length){const t=["row","col","depth","depth2","depth3","depth4"];return`\n      ${RM(VM(e,r))}\n      float ${s}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ${s}(${UM(t,i)});\n      }\n    `}const a=t[5],o=t[4]*a,l=t[3]*o,u=t[2]*l,c=t[1]*u;if(e.shapeInfo.isUniform)return`\n      float ${s}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(${c}, ${u}, ${l}, ${o})) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(${a}, 1)));\n        ${zM(e)}\n      }\n    `;const h=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,p=d[0],f=d[1];if(f===c&&null==h)return`\n      float ${s}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(${u}, ${l}, ${o}, ${a})) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;if(f===a&&null==h)return`\n      float ${s}(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(${t[1]*t[2]*t[3]*t[4]},\n               ${t[2]*t[3]*t[4]},\n               ${t[3]*t[4]},\n               ${t[4]})) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(${f}.0, ${p}.0);\n        return sampleTexture(${n}, uv);\n      }\n    `;const g=PM(n);return`\n    float ${s}(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ${c} + col * ${u} + depth * ${l} +\n          depth2 * ${o} + depth3 * ${a} + depth4 + ${g};\n      vec2 uv = uvFromFlat(${p}, ${f}, index);\n      return sampleTexture(${n}, uv);\n    }\n  `}(e);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function AM(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),s=SM();return`\n    vec4 ${n}() {\n      return ${s.texture2D}(${t}, halfCR);\n    }\n  `}(e);case 1:return function(e,t){const n=e.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),r=e.shapeInfo.texShape,i=SM();if(t)return`\n    vec4 ${s}(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ${i.texture2D}(${n}, uv);\n    }\n  `;const a=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return`\n    vec4 ${s}(int index) {\n      vec2 uv = packedUVfrom1D(\n        ${a[0]}, ${a[1]}, index);\n      return ${i.texture2D}(${n}, uv);\n    }\n  `}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,s=e.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=e.shapeInfo.texShape,a=i[0],o=i[1],l=SM();if(null!=i&&yo(n,i))return t?`\n      vec4 ${r}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);\n\n        return ${l.texture2D}(${s}, uv);\n      }\n    `:`\n      vec4 ${r}(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${a}.0);\n\n        return ${l.texture2D}(${s}, uv);\n      }\n    `;if(t)return`\n    vec4 ${r}(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${s}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ${l.texture2D}(${s}, uv);\n    }\n  `;const u=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],c=Math.ceil(n[1]/2);return`\n    vec4 ${r}(int row, int col) {\n      vec2 uv = packedUVfrom2D(${c}, ${u[0]}, ${u[1]}, row, col);\n      return ${l.texture2D}(${s}, uv);\n    }\n  `}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,s=e.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=e.shapeInfo.texShape,a=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];if(1===n[0]){const s=[1,2],i=["b","row","col"];return`\n        ${AM(VM(e,n.slice(1)),t)}\n        vec4 ${r}(int b, int row, int col) {\n          return ${r}(${UM(i,s)});\n        }\n      `}const o=SM();if(t)return`\n    vec4 ${r}(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(${s}Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${s}Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ${o.texture2D}(${s}, uv);\n    }\n  `;const l=a[0],u=a[1],c=Math.ceil(n[2]/2),h=c*Math.ceil(n[1]/2);return`\n    vec4 ${r}(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ${l}, ${u}, ${h}, ${c}, b, row, col);\n      return ${o.texture2D}(${s}, uv);\n    }\n  `}(e,t);default:return function(e,t){const n=e.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),r=SM();if(t)return`\n    vec4 ${s}(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ${n}Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${r.texture2D}(${n}, uv);\n    }\n  `;const i=e.shapeInfo.logicalShape,a=i.length,o=e.shapeInfo.texShape,l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],u=l[0],c=l[1],h=Math.ceil(i[a-1]/2);let d=h*Math.ceil(i[a-2]/2),p="int b, int row, int col",f=`b * ${d} + (row / 2) * ${h} + (col / 2)`;for(let g=2;g<a-1;g++)p=`int b${g}, `+p,d*=i[a-g-1],f=`b${g} * ${d} + `+f;return`\n    vec4 ${s}(${p}) {\n      int index = ${f};\n      int texR = index / ${c};\n      int texC = index - texR * ${c};\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${c}, ${u});\n      return ${r.texture2D}(${n}, uv);\n    }\n  `}(e,t)}}const DM="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",FM="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",MM="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",OM="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function LM(){return"\n    int getOutputCoords() {\n      return 0;\n    }\n  "}function PM(e){return`offset${e}`}function zM(e){const t=e.name,n=xo(e.shapeInfo.logicalShape);return n<2?`return ${t};`:`\n    for (int i = 0; i < ${n}; i++) {\n      if (i == index) {\n        return ${t}[i];\n      }\n    }\n  `}function BM(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function WM(e,t,n){const{newShape:s,keptDims:r}=No(t),i=t.length,a=e&&3===i&&1===t[0],o=a?t.slice(1):s,l=!e&&i>1&&!yo(t,n)&&s.length<i||a;return{useSqueezeShape:l,uniformShape:l?o:t,keptDims:r}}function VM(e,t){const n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function UM(e,t){return t.map((t=>e[t])).join(", ")}function GM(e,t,n,s){const r=n.map(((e,n)=>{const s={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(s.flatOffset=e.texData.slice.flatOffset),{name:t.variableNames[n],shapeInfo:s}})),i=r.map((e=>e.shapeInfo)),a={logicalShape:s.shape,texShape:s.texData.texShape,isUniform:!1,isPacked:s.texData.isPacked,flatOffset:null},o=$M(r,a,t),l=function(e,t){const n=lM(e,(()=>e.createShader(e.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");if(QF(e,(()=>e.shaderSource(n,t))),QF(e,(()=>e.compileShader(n))),qo().get("ENGINE_COMPILE_ONLY"))return n;if(!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw tM(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}(e.gl,o),u=e.createProgram(l);return qo().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:i,outShapeInfo:a,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(e.buildVao(u),Object.assign({program:t,fragmentShader:l,source:o,webGLProgram:u,inShapeInfos:i,outShapeInfo:a},HM(e,t,u)))}function HM(e,t,n){const s=[],r=[];let i,a,o,l=null,u=null;u=e.getUniformLocation(n,"NAN",!1),1===qo().getNumber("WEBGL_VERSION")&&(l=e.getUniformLocation(n,"INFINITY",!1));const c=!1;for(const h of t.variableNames){const r={name:h,uniform:e.getUniformLocation(n,h,c),offset:e.getUniformLocation(n,`offset${h}`,c)};t.enableShapeUniforms&&(r.shape=e.getUniformLocation(n,`${h}Shape`,c),r.texShape=e.getUniformLocation(n,`${h}TexShape`,c)),s.push(r)}if(t.enableShapeUniforms&&(i=e.getUniformLocation(n,"outShape",c),o=e.getUniformLocation(n,"outShapeStrides",c),a=e.getUniformLocation(n,"outTexShape",c)),t.customUniforms)for(const h of t.customUniforms)r.push(e.getUniformLocation(n,h.name,c));return{variablesLocations:s,customUniformLocations:r,infLoc:l,nanLoc:u,outShapeLocation:i,outShapeStridesLocation:o,outTexShapeLocation:a}}function jM(e,t){if(e.length!==t.length)throw Error(`Binary was compiled with ${e.length} inputs, but was executed with ${t.length} inputs`);e.forEach(((e,n)=>{const s=e.logicalShape,r=t[n],i=r.shape;if(!yo(s,i))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${s} and ${i} must match`);if(e.isUniform&&r.isUniform)return;const a=e.texShape,o=r.isUniform?null:r.texData.texShape;if(!yo(a,o))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${o} must match`)}))}function KM(e){return qo().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}class XM{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=GF.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=SM();this.outputShape=e,this.enableShapeUniforms=KM(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?CM(["r","c","d"],e):IM(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ${t.output} = result;\n      }\n    `}}class qM{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=GF.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=SM();this.outputShape=e,this.enableShapeUniforms=KM(this.outputShape.length),this.userCode=`\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ${this.enableShapeUniforms?CM(["r","c","d"],e):IM(["r","c","d"],e)}\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ${t.output} = result;\n      }\n    `}}class YM{constructor(e){this.variableNames=["A"],this.outTexUsage=HF.DOWNLOAD;const t=SM();this.outputShape=e,this.userCode=`\n      ${_M}\n\n      void main() {\n        float x = getAAtOutCoords();\n        ${t.output} = encode_float(x);\n      }\n    `}}class QM{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=HF.DOWNLOAD;const t=SM();this.outputShape=e,this.userCode=`\n      ${_M}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ${t.output} = encode_float(x);\n      }\n    `}}const ZM={R:0,G:1,B:2,A:3};class JM{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"RGBA";this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=SM();this.outputShape=e,this.enableShapeUniforms=KM(this.outputShape.length);let r="result";t&&(r="floor(result * 255. + 0.5)");let i="";for(let a=0;a<n.length;a++){const e=n[a];i+=`\n          if(offset == ${a}) {\n            result = values[${ZM[e]}];\n          }`}this.userCode=`\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":TM(e)}\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ${n.length});\n\n        flatIndex = idiv(flatIndex, ${n.length}, 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ${s.texture2D}(A, uv);\n          ${i}\n        }\n        ${s.output} = vec4(${r}, 0., 0., 0.);\n      }\n    `}}class eO{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=SM();this.outputShape=e,this.enableShapeUniforms=KM(this.outputShape.length);let s="",r="result";t&&(r="floor(result * 255. + 0.5)");for(let i=0;i<=1;i++)for(let t=0;t<=1;t++){const r=2*i+t;s+=`\n          localCoords = coords;\n          if(localCoords[2] + ${t} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {\n          localCoords[2] += ${t};\n          if (localCoords[1] + ${i} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {\n            localCoords[1] += ${i};\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ${n.texture2D}(A, uv);\n\n            if (offset == 0) {\n              result[${r}] = values[0];\n            } else if (offset == 1) {\n              result[${r}] = values[1];\n            } else if (offset == 2) {\n              result[${r}] = values[2];\n            } else {\n              result[${r}] = values[3];\n            }\n          }\n        }\n        `}this.userCode=`\n        ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":TM(e)}\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ${s}\n\n          ${n.output} = ${r};\n        }\n    `}}function tO(e){const t=SM();return function(e,t){const n=lM(e,(()=>e.createShader(e.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");if(QF(e,(()=>e.shaderSource(n,t))),QF(e,(()=>e.compileShader(n))),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}(e,`${t.version}\n    precision highp float;\n    ${t.attribute} vec3 clipSpacePos;\n    ${t.attribute} vec2 uv;\n    ${t.varyingVs} vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }`)}function nO(e){return function(e,t){const n=lM(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return QF(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),QF(e,(()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW))),n}(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function sO(e){return function(e,t){const n=lM(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return QF(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n))),QF(e,(()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW))),n}(e,new Uint16Array([0,1,2,2,1,3]))}function rO(e,t,n,s,r,i){!function(e,t){const n=qo().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0)throw new Error(`Requested texture size [${e}x${t}] is invalid.`);if(e>n||t>n)throw new Error(`Requested texture size [${e}x${t}] greater than WebGL maximum on this browser / GPU [${n}x${n}].`)}(t,n);const a=function(e){return lM(e,(()=>e.createTexture()),"Unable to create WebGLTexture.")}(e),o=e.TEXTURE_2D;return QF(e,(()=>e.bindTexture(o,a))),QF(e,(()=>e.texParameteri(o,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE))),QF(e,(()=>e.texParameteri(o,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE))),QF(e,(()=>e.texParameteri(o,e.TEXTURE_MIN_FILTER,e.NEAREST))),QF(e,(()=>e.texParameteri(o,e.TEXTURE_MAG_FILTER,e.NEAREST))),1===qo().getNumber("WEBGL_VERSION")?QF(e,(()=>e.texImage2D(o,0,s,t,n,0,r,i,null))):QF(e,(()=>e.texStorage2D(o,1,s,t,n))),QF(e,(()=>e.bindTexture(e.TEXTURE_2D,null))),{texture:a,texShape:[n,t]}}function iO(e){return e.internalFormatFloat}function aO(e){return e.internalFormatHalfFloat}function oO(e){return e.downloadTextureFormat}function lO(e){return e.internalFormatPackedFloat}function uO(e){return e.internalFormatPackedHalfFloat}function cO(e,t,n,s,r,i,a,o){const l=e,u=new Float32Array(function(e,t){const[n,s]=qF(e,t);return n*s*4}(i,a));return l.bindBuffer(l.PIXEL_PACK_BUFFER,t),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,u),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),u}class hO{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=qo().getNumber("WEBGL_VERSION");if(null!=e?(this.gl=e,function(e,t){WF[e]=t}(t,e)):this.gl=UF(t),e=this.gl,2===qo().getNumber("WEBGL_VERSION")){const t=e;this.createVertexArray=()=>QF(t,(()=>t.createVertexArray())),this.bindVertexArray=e=>QF(t,(()=>t.bindVertexArray(e))),this.deleteVertexArray=e=>QF(t,(()=>t.deleteVertexArray(e))),this.getVertexArray=()=>QF(t,(()=>t.getParameter(t.VERTEX_ARRAY_BINDING)))}else if(null!=e){const t=e.getExtension("OES_vertex_array_object");if(null==t)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>QF(e,(()=>t.createVertexArrayOES())),this.bindVertexArray=n=>QF(e,(()=>t.bindVertexArrayOES(n))),this.deleteVertexArray=n=>QF(e,(()=>t.deleteVertexArrayOES(n))),this.getVertexArray=()=>QF(e,(()=>e.getParameter(t.VERTEX_ARRAY_BINDING_OES)))}let n="WEBGL_color_buffer_float";const s="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===qo().getNumber("WEBGL_VERSION")){const e="OES_texture_float",t="OES_texture_half_float";if(this.textureFloatExtension=JF(this.gl,e),bM(this.gl,t))this.textureHalfFloatExtension=JF(this.gl,t);else if(qo().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),bM(this.gl,s))this.colorBufferHalfFloatExtension=JF(this.gl,s);else if(qo().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",bM(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!bM(this.gl,s))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(s)}this.vertexBuffer=nO(this.gl),this.indexBuffer=sO(this.gl),this.framebuffer=function(e){return lM(e,(()=>e.createFramebuffer()),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=YF(this.gl,this.textureHalfFloatExtension)}get debug(){return qo().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;QF(e,(()=>e.finish())),QF(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),QF(e,(()=>e.deleteFramebuffer(this.framebuffer))),QF(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,null))),QF(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null))),QF(e,(()=>e.deleteBuffer(this.indexBuffer))),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,s){const[r,i]=KF(t,n);return rO(e,r,i,iO(s),s.textureFormatFloat,e.FLOAT)}(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,s){const[r,i]=KF(t,n);return rO(e,r,i,aO(s),s.textureFormatFloat,s.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,s){const[r,i]=KF(t,n);return rO(e,r,i,oO(s),e.RGBA,e.UNSIGNED_BYTE)}(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),function(e,t,n){QF(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),n.data instanceof Uint8Array?2===qo().getNumber("WEBGL_VERSION")?QF(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data))):QF(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data))):2===qo().getNumber("WEBGL_VERSION")?QF(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n))):QF(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n))),QF(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,s){this.throwIfDisposed(),function(e,t,n,s,r,i){let a,o,l;QF(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),r instanceof Uint8Array?(a=new Uint8Array(n*s*4),o=e.UNSIGNED_BYTE,l=e.RGBA):(a=new Float32Array(n*s*4),o=e.FLOAT,l=i.internalFormatPackedFloat),a.set(r),2===qo().getNumber("WEBGL_VERSION")?QF(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,s,e.RGBA,o,a))):QF(e,(()=>e.texImage2D(e.TEXTURE_2D,0,l,n,s,0,e.RGBA,o,a))),QF(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}(this.gl,e,t,n,s,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,s){const[r,i]=qF(t,n);return rO(e,r,i,uO(s),e.RGBA,s.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,s){const[r,i]=qF(t,n);return rO(e,r,i,lO(s),e.RGBA,e.FLOAT)}(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(aM(this.gl,this.framebuffer),this.outputTexture=null),QF(this.gl,(()=>this.gl.deleteTexture(e)))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>function(e,t,n,s){const[r,i]=KF(t,n),a=new Uint8Array(t*n*4);return QF(e,(()=>e.readPixels(0,0,r,i,s.downloadTextureFormat,e.UNSIGNED_BYTE,a))),new Float32Array(a.buffer)}(this.gl,t,n,this.textureConfig)))}downloadPackedMatrixFromBuffer(e,t,n,s,r,i){return cO(this.gl,e,0,0,0,r,i,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return function(e,t,n){const s=e,r=new Float32Array(n);return s.bindBuffer(s.PIXEL_PACK_BUFFER,t),s.getBufferSubData(s.PIXEL_PACK_BUFFER,0,r),s.bindBuffer(s.PIXEL_PACK_BUFFER,null),r}(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);const s=function(e,t,n){const s=e.createBuffer();QF(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,s)));const r=16*t*n;return QF(e,(()=>e.bufferData(e.PIXEL_PACK_BUFFER,r,e.STREAM_READ))),QF(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0))),QF(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null))),s}(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),s}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(qo().getBool("WEBGL_FENCE_API_ENABLED")){const s=e,r=s.fenceSync(s.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{const e=s.clientWaitSync(r,0,0);return e===s.ALREADY_SIGNALED||e===s.CONDITION_SATISFIED},t=r}else qo().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,qo().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>function(e,t,n){const s=new Float32Array(t*n*4);return QF(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,s))),s}(this.gl,t,n)))}createProgram(e){this.throwIfDisposed();const t=this.gl;null==this.vertexShader&&(this.vertexShader=tO(t));const n=function(e){return lM(e,(()=>e.createProgram()),"Unable to create WebGLProgram.")}(t);QF(t,(()=>t.attachShader(n,this.vertexShader))),QF(t,(()=>t.attachShader(n,e))),function(e,t){if(QF(e,(()=>e.linkProgram(t))),!qo().get("ENGINE_COMPILE_ONLY")&&!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}(t,n);const s=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&nM(t,s),s}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const t=this.gl;QF(t,(()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer))),function(e,t,n){QF(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),sM(e,t,"clipSpacePos",n,3,20,0)&&sM(e,t,"uv",n,2,20,12)}(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&(QF(this.gl,(()=>this.gl.deleteProgram(e))),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&nM(this.gl,this.program),QF(this.gl,(()=>this.gl.useProgram(e)))}getUniformLocation(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];return this.throwIfDisposed(),n?function(e,t,n){return lM(e,(()=>e.getUniformLocation(t,n)),'uniform "'+n+'" not present in program.')}(this.gl,e,t):function(e,t,n){return e.getUniformLocation(t,n)}(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),QF(this.gl,(()=>this.gl.getAttribLocation(e,t)))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),rM(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();const[s,r]=qF(t,n);this.setOutputMatrixTextureDriver(e,s,r)}setOutputMatrixWriteRegion(e,t,n,s){this.setOutputMatrixWriteRegionDriver(n,e,s,t)}setOutputPackedMatrixWriteRegion(e,t,n,s){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&nM(this.gl,this.program),oM(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}QF(e,(()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0)))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),QF(this.gl,(()=>this.gl.finish()))}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=JF(this.gl,2===qo().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===qo().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===qo().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await So((()=>this.disposed||this.isQueryAvailable(e,qo().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")))),this.getQueryTime(e,qo().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(0===t)return null;if(2===t){const t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{const t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){const t=this.gl,n=this.getQueryTimerExtensionWebGL2(),s=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),s&&!this.disjoint}{const t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise((t=>{this.addItemToPoll((()=>e.isFencePassed()),(()=>t()))}))}pollItems(){const e=function(e){let t=0;for(;t<e.length;++t){if(!e[t]())break}return t-1}(this.itemsToPoll.map((e=>e.isDoneFn)));for(let t=0;t<=e;++t){const{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in qo().platform&&(n=qo().platform.setTimeoutCustom.bind(qo().platform)),So((()=>(this.pollItems(),0===this.itemsToPoll.length)),(()=>0),null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),iM(this.gl,e,this.framebuffer),this.debug&&oM(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(iM(this.gl,this.outputTexture,this.framebuffer),this.debug&&oM(this.gl)):aM(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();const s=this.gl;iM(s,e,this.framebuffer),this.debug&&oM(s),this.outputTexture=e,QF(s,(()=>s.viewport(0,0,t,n))),QF(s,(()=>s.scissor(0,0,t,n)))}setOutputMatrixWriteRegionDriver(e,t,n,s){this.throwIfDisposed(),QF(this.gl,(()=>this.gl.scissor(e,t,n,s)))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{mx:dO,XI:pO,Nk:fO,f6:gO,ct:mO,YG:bO,hH:xO,z3:yO,sG:vO,uM:wO,vS:kO,qB:SO,GG:IO,rq:CO,lg:NO,WR:TO,cu:_O,GE:EO,px:$O,jC:RO,He:AO,hE:DO,BF:FO,Dk:MO,cl:OO,_B:LO,ub:PO,_f:zO,Ku:BO,qy:WO,Zy:VO,bu:UO,zv:GO,dH:HO,HS:jO,yH:KO,l3:XO,z9:qO,x6:YO,_m:QO,eW:ZO,GK:JO,SP:eL,yr:tL,dl:nL,Dw:sL,xT:rL,_X:iL,wz:aL}=r;function oL(e,t){return["x","y","z","w","u","v"].slice(0,t).map((t=>`${e}.${t}`))}function lL(e,t){return 1===t?[e]:oL(e,t)}class uL{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=KM(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const e=lL("rc",this.rank),t=BM(this.rank),n=this.getOutOfBoundsCondition(e),s=this.getSetup(e),r=this.getOutput(e);this.userCode=`\n        void main() {\n          ${t} rc = getOutputCoords();\n\n          if(${n}) {\n            setOutput(vec4(0));\n          } else {\n            ${s}\n\n            setOutput(vec4(${r}));\n          }\n        }\n      `}}getSourceCoordsArr(e){const t=[];for(let n=0;n<=1;n++)for(let s=0;s<=1;s++){let r=`${0===n?"r":"rp1"}, ${0===s?"c":"cp1"}`;for(let t=2;t<this.rank;t++)r=`${e[e.length-1-t]},`+r;t.push(r)}return t}getOutOfBoundsCondition(e){if(1===this.rank)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let n=this.rank-2;n<this.rank;n++)t+=`${e[n]} >= ${this.enableShapeUniforms?`outShape[${n}]`:this.outputShape[n]}`,n<this.rank-1&&(t+="||");return t}getSetup(e){if(1===this.rank)return"";const t=e.slice(-2),n=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],s=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`\n      int r = ${t[0]};\n      int c = ${t[1]};\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ${n};\n      bool rEdge = rp1 >= ${s};\n    `}getOutput(e){const t=this.getSourceCoordsArr(e);if(1===this.rank){return`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`}return`getA(${t[0]}),\n            cEdge ? 0. : getA(${t[1]}),\n            rEdge ? 0. : getA(${t[2]}),\n            rEdge || cEdge ? 0. : getA(${t[3]})`}}class cL{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=KM(this.outputShape.length);let n="";for(let i=0;i<4;i++){let e="thisRC = rc;";i%2===1&&(e+="thisRC.z += 1;"),i>1&&(e+="thisRC.y += 1;"),n+=`\n        ${e}\n        ${i>0?"if(thisRC.y < rows && thisRC.z < cols){":""}\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[${i}] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ${i>0?"}":""}\n      `}var s,r;this.userCode=`\n      ${s=t,r=this.enableShapeUniforms,`\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ${r?NM(["r","c","d"],"inputShape"):IM(["r","c","d"],s)}\n      return ivec3(r, c, d);\n    }\n  `}\n      ${this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":TM(e)}\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};\n        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};\n\n        ${n}\n\n        setOutput(result);\n      }\n    `}}class hL{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,n){const s=pL(t,n),r=fL(e,s,n);r in this.freeTextures||(this.freeTextures[r]=[]),r in this.usedTextures||(this.usedTextures[r]=[]);const i=dL(e,s,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[r].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=i,this.log();const e=this.freeTextures[r].pop();return this.usedTextures[r].push(e),e}let a;return s===jF.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):s===jF.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):s===jF.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):s===jF.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):s===jF.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[r].push(a),this.numUsedTextures++,this._numBytesAllocated+=i,this.log(),a}releaseTexture(e,t,n,s){if(null==this.freeTextures)return;const r=pL(n,s),i=fL(t,r,s);i in this.freeTextures||(this.freeTextures[i]=[]);const a=dL(t,r,this.gpgpu.gl,this.gpgpu.textureConfig,s),o=qo().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==o&&this._numBytesAllocated>o?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=a):(this.freeTextures[i].push(e),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;const l=this.usedTextures[i],u=l&&l.indexOf(e);if(null==u||u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l[u]=l[l.length-1],l.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const e in this.freeTextures)this.freeTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));for(const e in this.usedTextures)this.usedTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function dL(e,t,n,s,r){const i=function(e,t){switch(e){case jF.PACKED_2X2_FLOAT32:return lO(t);case jF.PACKED_2X2_FLOAT16:return uO(t);case jF.UNPACKED_FLOAT32:return iO(t);case jF.UNPACKED_FLOAT16:return aO(t);case jF.PACKED_4X1_UNSIGNED_BYTE:return oO(t);default:throw new Error(`Unknown physical texture type ${e}`)}}(t,s);let a;if(r){const[t,n]=qF(e[0],e[1]);a=t*n}else{const[t,n]=KF(e[0],e[1]);a=t*n}const o=function(e,t){const n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error(`Unknown internal format ${t}`)}(n,i);return a*o}function pL(e,t){if(e===HF.UPLOAD)return jF.PACKED_2X2_FLOAT32;if(e===HF.RENDER||null==e)return function(e){return qo().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?jF.PACKED_2X2_FLOAT32:jF.UNPACKED_FLOAT32:e?jF.PACKED_2X2_FLOAT16:jF.UNPACKED_FLOAT16}(t);if(e===HF.DOWNLOAD||e===HF.PIXELS)return jF.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${e}`)}function fL(e,t,n){return`${e[0]}_${e[1]}_${t}_${n}`}class gL{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=KM(this.outputShape.length),this.userCode=`\n      float unaryOperation(float x) {\n        ${t}\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}const mL="if (isnan(x)) return x;",bL="return abs(x);";const xL=mL+"\n  return (x < 0.0) ? 0.0 : x;\n",yL=mL+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",vL="return x;";class wL{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=KM(this.outputShape.length),this.userCode=`\n      vec4 unaryOperation(vec4 x) {\n        ${t}\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    `}}class kL{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=KM(this.outputShape.length);const t=e.length,n=lL("rc",t),s=BM(t),r=function(e,t){if(1===e)return"rc";let n="";for(let s=0;s<e;s++)n+=t[s],s<e-1&&(n+=",");return n}(t,n),i=n.slice(-2),a=t<=1?"rc":`vec2(${i.join(",")})`;this.userCode=`\n      void main() {\n        ${s} rc = getOutputCoords();\n        vec4 packedInput = getA(${r});\n\n        setOutput(getChannel(packedInput, ${a}));\n      }\n    `}}const SL=ey,IL={};const CL=qo().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");class NL extends lo{nextDataId(){return NL.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!qo().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(null!=e){if(e instanceof hO)t=e;else{const n=UF(qo().getNumber("WEBGL_VERSION"),e);t=new hO(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const e=UF(qo().getNumber("WEBGL_VERSION"));t=new hO(e),this.binaryCache=((n=qo().getNumber("WEBGL_VERSION"))in IL||(IL[n]={}),IL[n]),this.gpgpuCreatedLocally=!0}var n;this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new hL(this.gpgpu),this.numMBBeforeWarning=null==qo().global.screen?1024:qo().global.screen.height*qo().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new oo(this,Pd())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,n,s,r,i){const a=this.makeTensorInfo(t,n),o=this.texData.get(a.dataId);o.isPacked=!1,o.texture={texture:e,texShape:[s,r]},o.texShape=[s,r];const l=dM(t),u=new JM(l,!1,i),c=this.runWebGLProgram(u,[a],n,[[s,r]]);return c.shape=t,o.texture=null,this.disposeIntermediateTensorInfo(a),c.dataId}write(e,t,n){if((qo().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||qo().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const s={id:this.nextDataId()};return this.texData.set(s,{shape:t,dtype:n,values:e,usage:HF.UPLOAD,refCount:1}),s}refCount(e){if(this.texData.has(e)){return this.texData.get(e).refCount}return 0}incRef(e){this.texData.get(e).refCount++}decRef(e){if(this.texData.has(e)){this.texData.get(e).refCount--}}move(e,t,n,s,r){if(qo().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===s)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:s,values:t,usage:HF.UPLOAD,refCount:r})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:n,dtype:s,complexTensorInfos:r,slice:i,shape:a,isPacked:o}=t;if(null!=i){let t;t=o?new wL(a,vL):new gL(a,vL);const n=this.runWebGLProgram(t,[{dataId:e,shape:a,dtype:s}],s),r=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),r}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===s)return n;const l=null!=this.activeTimers;let u,c;if(l&&(u=Ph()),"complex64"===s){c=xx(this.readSync(r.real.dataId),this.readSync(r.imag.dataId))}else c=this.getValuesFromTexture(e);return l&&(this.downloadWaitMs+=Ph()-u),this.convertAndCacheOnCPU(e,c)}async read(e){if(this.pendingRead.has(e)){const t=this.pendingRead.get(e);return new Promise((e=>t.push(e)))}const t=this.texData.get(e),{values:n,shape:s,slice:r,dtype:i,complexTensorInfos:a,isPacked:o}=t;if(null!=r){let t;t=o?new wL(s,vL):new gL(s,vL);const n=this.runWebGLProgram(t,[{dataId:e,shape:s,dtype:i}],i),r=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),r}if(null!=n)return this.convertAndCacheOnCPU(e);if(qo().getBool("DEBUG")&&!qo().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===qo().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l,u,c=null;if("complex64"!==i&&qo().get("WEBGL_BUFFER_SUPPORTED")){l=this.decode(e);const t=this.texData.get(l.dataId);c=this.gpgpu.createBufferFromTexture(t.texture.texture,...XF(s))}if(this.pendingRead.set(e,[]),"complex64"!==i&&await this.gpgpu.createAndWaitForFence(),"complex64"===i){const e=await Promise.all([this.read(a.real.dataId),this.read(a.imag.dataId)]);u=xx(e[0],e[1])}else if(null==c)u=this.getValuesFromTexture(e);else{const e=xo(s);u=this.gpgpu.downloadFloat32MatrixFromBuffer(c,e)}if(null!=l&&this.disposeIntermediateTensorInfo(l),null!=c){const e=this.gpgpu.gl;QF(e,(()=>e.deleteBuffer(c)))}const h=this.convertAndCacheOnCPU(e,u),d=this.pendingRead.get(e);return this.pendingRead.delete(e),d.forEach((e=>e(h))),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&Pd().removeDataId(e,this),this.pendingDeletes--),h}readToGPU(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=this.texData.get(e),{values:s,shape:r,slice:i,dtype:a,isPacked:o,texture:l}=n;if("complex64"===a)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=i){let n;n=o?new wL(r,vL):new gL(r,vL);const s=this.runWebGLProgram(n,[{dataId:e,shape:r,dtype:a}],a),i=this.readToGPU(s,t);return this.disposeIntermediateTensorInfo(s),i}if(null==l)throw null!=s?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const u=this.decode(e,t.customTexShape),c=Pd().makeTensorFromTensorInfo(u),h=this.texData.get(u.dataId);return Object.assign({tensorRef:c},h.texture)}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map((e=>Bh(e)));return Tp(e.shape,e.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return Tp(e.shape,e.dtype,t)}checkNumericalProblems(e){if(null!=e)for(let t=0;t<e.length;t++){const n=e[t];if(!ZF(n)){if(qo().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`);throw Error(`The value ${n} cannot be represented on this device.`)}}}getValuesFromTexture(e){const{shape:t,dtype:n,isPacked:s}=this.texData.get(e),r=xo(t);if(qo().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(e),s=this.texData.get(n.dataId),i=this.gpgpu.downloadMatrixFromPackedTexture(s.texture.texture,...XF(t)).subarray(0,r);return this.disposeIntermediateTensorInfo(n),i}const i=qo().getBool("WEBGL_PACK")&&!0===s,a=i?dM(t):t,o=i?new QM(a):new YM(a),l=this.runWebGLProgram(o,[{shape:a,dtype:n,dataId:e}],"float32"),u=this.texData.get(l.dataId),c=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture.texture,u.texShape[0],u.texShape[1]).subarray(0,r);return this.disposeIntermediateTensorInfo(l),c}timerAvailable(){return qo().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,n=[];let s=!1;null==this.programTimersStack?(this.programTimersStack=n,s=!0):this.activeTimers.push(n),this.activeTimers=n,e();const r=Vh(this.activeTimers.map((e=>e.query))).filter((e=>null!=e)),i=Vh(this.activeTimers.map((e=>e.name))).filter((e=>null!=e));this.activeTimers=t,s&&(this.programTimersStack=null);const a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(qo().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const e=await Promise.all(r);a.kernelMs=function(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}(e),a.getExtraProfileInfo=()=>e.map(((e,t)=>({name:i[t],ms:e}))).map((e=>`${e.name}: ${e.ms}`)).join(", ")}else a.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,a})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return qo().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Ph(),endMs:null}}endTimer(e){return qo().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=Ph(),e)}async getQueryTime(e){if(qo().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:n}=this.texData.get(e);return null!=n&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:n,texShape:s,usage:r,isPacked:i,slice:a}=this.texData.get(e),o=a&&a.origDataId||e,l=this.dataRefCount.get(o);l>1?this.dataRefCount.set(o,l-1):(this.dataRefCount.delete(o),null!=t&&(this.numBytesInGPU-=this.computeBytes(s,n),this.textureManager.releaseTexture(t,s,r,i)));const u=this.texData.get(e);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:CL;return qo().getBool("WEBGL_CPU_FORWARD")&&e.every((e=>null==this.texData.get(e.dataId).texture&&xo(e.shape)<t))}getGPGPUContext(){return this.gpgpu}where(e){hh("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return SL(e.shape,t)}packedUnaryOp(e,t,n){const s=new wL(e.shape,t),r=this.compileAndRun(s,[e],n);return Pd().makeTensorFromTensorInfo(r)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const t=HO(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if(qo().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,bL,e.dtype);const t=new gL(e.shape,bL),n=this.compileAndRun(t,[e]);return Pd().makeTensorFromTensorInfo(n)}makeTensorInfo(e,t,n){let s;if("string"===t&&null!=n&&n.length>0&&Ro(n[0])){const r=n.map((e=>zh(e)));s=this.write(r,e,t)}else s=this.write(n,e,t);return this.texData.get(s).usage=null,{dataId:s,shape:e,dtype:t}}makeOutput(e,t,n){return Pd().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,n),this)}unpackTensor(e){const t=new kL(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new uL(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const n=[cM(e.shape),...hM(e.shape)],s={dtype:e.dtype,shape:n,dataId:e.dataId},r=[cM(t),...hM(t)],i=new cL(r,n),a=[n],o=this.runWebGLProgram(i,[s],e.dtype,a,!0);return{dataId:o.dataId,shape:t,dtype:o.dtype}}decode(e,t){const n=this.texData.get(e),{isPacked:s,shape:r,dtype:i}=n;if(null!=t){go(xo(r)<=t[0]*t[1]*4,(()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data."))}const a=dM(r);let o;o=s?new qM(a):new XM(a);const l=[null!=t?t:XF(a)];return{dtype:i,shape:r,dataId:this.runWebGLProgram(o,[{shape:a,dtype:i,dataId:e}],i,l,!0,t).dataId}}runWebGLProgram(e,t,n,s){let r=arguments.length>4&&void 0!==arguments[4]&&arguments[4],i=arguments.length>5?arguments[5]:void 0;const a=this.makeTensorInfo(e.outputShape,n),o=this.texData.get(a.dataId);if(e.packedOutput&&(o.isPacked=!0),e.outPackingScheme===GF.DENSE){const t=null!=i?i:XF(e.outputShape);o.texShape=t.map((e=>2*e))}if(null!=e.outTexUsage&&(o.usage=e.outTexUsage),0===xo(a.shape))return o.values=To(a.dtype,0),a;const l=[],u=t.map((t=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(t.dataId);if(null==n.texture){if(!e.packedInputs&&xo(t.shape)<=qo().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:n.values};e.packedInputs&&(n.isPacked=!0,n.shape=t.shape)}if(this.uploadToGPU(t.dataId),!!n.isPacked!==!!e.packedInputs)t=n.isPacked?this.unpackTensor(t):this.packTensor(t),l.push(t),n=this.texData.get(t.dataId);else if(n.isPacked&&!fM(n.shape,t.shape)){const e=t,s=t.shape;t.shape=n.shape,t=this.packedReshape(t,s),l.push(t),n=this.texData.get(t.dataId),e.shape=s}return{shape:t.shape,texData:n,isUniform:!1}}));this.uploadToGPU(a.dataId);const c={shape:a.shape,texData:o,isUniform:!1},h=function(e,t,n){let s="";t.concat(n).forEach((t=>{const r=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!t.isUniform){const i=t.texData.texShape,{useSqueezeShape:a,uniformShape:o,keptDims:l}=WM(e.packedInputs,t.shape,i);let u="",c="",h="";if(1===o.length&&e.packedInputs){const e=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];u=`${e[0]>1}_${e[1]>1}`}else if(2!==o.length||e.packedInputs){if(o.length>2&&!e.packedInputs){const e=Oo(o);h=`${e[0]===i[1]}_${e[e.length-1]===i[1]}`}}else c=`${o[0]>1}_${o[1]>1}`;const d=t.shape.length,p=2===o.length&&yo(t.shape,i),f=1===xo(t.shape),g=Zp(t.shape,n.shape),m=!e.packedInputs&&d===n.shape.length&&yo(i,n.texData.texShape),b=e.packedInputs||o.length>2?"":`${i[0]>1}_${i[1]>1}`;s+=`${d}_${m}_${a?l:""}_${o.length}_${f}_${g}_${p}_${u}_${c}_${h}_${b}_${r}`}else{const e=t.isUniform?"uniform":t.texData.texShape;s+=`${t.shape}_${e}_${r}`}}));const r=e.userCode;let i=e.constructor.name;return i+="_"+s+"_"+r+`${qo().getNumber("WEBGL_VERSION")}`,i}(e,u,c),d=this.getAndSaveBinary(h,(()=>GM(this.gpgpu,e,u,c))),p=null!=this.activeTimers;let f;p&&(f=this.startTimer()),qo().get("ENGINE_COMPILE_ONLY")||function(e,t,n,s,r){t.program.enableShapeUniforms||(jM(t.inShapeInfos,n),jM([t.outShapeInfo],[s]));const i=s.texData.texture,a=s.texData.texShape;s.texData.isPacked?e.setOutputPackedMatrixTexture(i.texture,a[0],a[1]):e.setOutputMatrixTexture(i.texture,a[0],a[1]),e.setProgram(t.webGLProgram),e.bindVertexArray(t.webGLProgram.vao),1===qo().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN);for(let l=0;l<n.length;++l){const s=n[l],{uniform:r,offset:i,shape:a,texShape:o}=t.variablesLocations[l];if(a){const{uniformShape:n}=WM(t.program.packedInputs,s.shape,s.texData.texShape);switch(n.length){case 1:e.gl.uniform1iv(a,new Int32Array(n));break;case 2:e.gl.uniform2iv(a,new Int32Array(n));break;case 3:e.gl.uniform3iv(a,new Int32Array(n));break;case 4:e.gl.uniform4iv(a,new Int32Array(n))}}if(o&&e.gl.uniform2i(o,s.texData.texShape[0],s.texData.texShape[1]),null!=r)if(s.isUniform)if(xo(s.shape)<2)e.gl.uniform1f(r,s.uniformValues[0]);else{let t=s.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(r,t)}else null!=s.texData.slice&&null!=i&&e.gl.uniform1i(i,s.texData.slice.flatOffset),e.setInputMatrixTexture(s.texData.texture.texture,r,l)}const o=t.outShapeLocation;if(o)switch(s.shape.length){case 1:e.gl.uniform1iv(o,new Int32Array(s.shape));break;case 2:e.gl.uniform2iv(o,new Int32Array(s.shape));break;case 3:e.gl.uniform3iv(o,new Int32Array(s.shape));break;case 4:e.gl.uniform4iv(o,new Int32Array(s.shape))}if(t.outShapeStridesLocation){const n=Oo(s.shape);switch(s.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(n));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(n));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(n))}}if(t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,s.texData.texShape[0],s.texData.texShape[1]),t.program.customUniforms&&r)for(let l=0;l<t.program.customUniforms.length;++l){const n=t.program.customUniforms[l],s=t.customUniformLocations[l],i=r[l];if("float"===n.type)e.gl.uniform1fv(s,i);else if("vec2"===n.type)e.gl.uniform2fv(s,i);else if("vec3"===n.type)e.gl.uniform3fv(s,i);else if("vec4"===n.type)e.gl.uniform4fv(s,i);else if("int"===n.type)e.gl.uniform1iv(s,i);else if("ivec2"===n.type)e.gl.uniform2iv(s,i);else if("ivec3"===n.type)e.gl.uniform3iv(s,i);else{if("ivec4"!==n.type)throw Error(`uniform type ${n.type} is not supported yet.`);e.gl.uniform4iv(s,i)}}e.executeProgram()}(this.gpgpu,d,u,c,s),l.forEach((e=>this.disposeIntermediateTensorInfo(e))),p&&(f=this.endTimer(f),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(f)}));const g=qo().getNumber("WEBGL_FLUSH_THRESHOLD");if(g>0){const e=Ph();e-this.lastGlFlushTime>g&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=e)}if(!qo().getBool("WEBGL_LAZILY_UNPACK")&&o.isPacked&&!1===r){const e=this.unpackTensor(a);return this.disposeIntermediateTensorInfo(a),e}return a}compileAndRun(e,t,n,s){let r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];n=n||t[0].dtype;return this.runWebGLProgram(e,t,n,s,r)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){if(!this.disposed){if(!qo().getBool("IS_TEST")){Object.keys(this.binaryCache).forEach((e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}))}this.textureManager.dispose(),null!=this.canvas&&"undefined"!==typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0}}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=Bd((()=>{if(!qo().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=qo().getBool("DEBUG");qo().set("DEBUG",!1);const t=this.abs(Pp(1e-8)).dataSync()[0];if(qo().set("DEBUG",e),t>0)return 32}return 16}))),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const t=this.texData.get(e),{shape:n,dtype:s,values:r,texture:i,usage:a,isPacked:o}=t;if(null!=i)return;const l=null!=this.activeTimers;let u;l&&(u=Ph());let c=t.texShape;if(null==c&&(c=function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=qo().getNumber("WEBGL_MAX_TEXTURE_SIZE"),s=qo().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");if(s===1/0&&qo().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(s=n/2),t&&(n*=2,s*=2,1===(e=e.map(((t,n)=>n>=e.length-2?po(e[n]):e[n]))).length&&(e=[2,e[0]])),2!==e.length){const t=No(e);e=t.newShape}let r=xo(e),i=null;e.length<=1&&r<=n?i=[1,r]:2===e.length&&e[0]<=n&&e[1]<=n?i=e:3===e.length&&e[0]*e[1]<=n&&e[2]<=n?i=[e[0]*e[1],e[2]]:3===e.length&&e[0]<=n&&e[1]*e[2]<=n?i=[e[0],e[1]*e[2]]:4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n?i=[e[0]*e[1]*e[2],e[3]]:4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(i=[e[0],e[1]*e[2]*e[3]]);const a=null!=i&&Math.max(...i)>s&&Math.min(...i)<=(t?2:1)&&Math.min(...i)>0;if(null==i||a)if(t){const t=cM(e);let n=2,s=2;e.length&&([n,s]=hM(e)),r=t*(n/2)*(s/2),i=wo(r).map((e=>2*e))}else i=wo(r);return i}(n,o),t.texShape=c),null!=r){const e=dM(n);let i,a=c[1],h=c[0];const d=r instanceof Uint8Array||r instanceof Uint8ClampedArray;!o&&d||([a,h]=qF(c[0],c[1])),i=o?new eO(e,d):new JM(e,d);const p=d?[h,a]:c,f=this.makeTensorInfo(p,s),g=this.texData.get(f.dataId);g.usage=d?HF.PIXELS:HF.UPLOAD,g.texShape=p,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(f.dataId),a,h,r);const m=[[h,a]],b=!0,x=this.runWebGLProgram(i,[f],s,m,b),y=this.texData.get(x.dataId);t.texShape=y.texShape,t.isPacked=y.isPacked,t.usage=y.usage,qo().get("ENGINE_COMPILE_ONLY")?this.disposeData(x.dataId):(t.texture=y.texture,t.values=null,this.texData.delete(x.dataId)),this.disposeIntermediateTensorInfo(f),l&&(this.uploadWaitMs+=Ph()-u)}else{const e=this.acquireTexture(c,a,s,o);t.texture=e}}convertAndCacheOnCPU(e,t){const n=this.texData.get(e),{dtype:s}=n;return null!=t&&(n.values=function(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){const n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}throw new Error(`Unknown dtype ${t}`)}(t,s)),n.values}acquireTexture(e,t,n,s){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${e} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,s)}computeBytes(e,t){return e[0]*e[1]*$o(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}for(const[,t]of Object.entries(this.binaryCache)){const n=new Promise((e=>{try{this.checkCompletion_(t),e(!0)}catch(n){throw n}}));e.push(n)}return Promise.all(e)}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await Gb(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)){if(console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS))throw tM(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.");throw new Error("Failed to link vertex and fragment shaders.")}return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:t,customUniformLocations:n,infLoc:s,nanLoc:r,outShapeLocation:i,outShapeStridesLocation:a,outTexShapeLocation:o}=HM(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=n,e.infLoc=s,e.nanLoc=r,e.outShapeLocation=i,e.outShapeStridesLocation=a,e.outTexShapeLocation=o}}createTensorFromGPUData(e,t,n){e.channels=e.channels||"RGBA";const{texture:s,height:r,width:i,channels:a}=e,o=Pd().backend;if(!o.gpgpu.gl.isTexture(s))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const l=o.writeTexture(s,t,n,r,i,a);return Pd().makeTensorFromDataId(l,t,n,o)}}NL.nextDataId=0;Nd()&&Ud("webgl",(()=>new NL),2);const TL="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n";class _L{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=ef(t,n),this.enableShapeUniforms=KM(this.outputShape.length),this.userCode=`\n      float binaryOperation(float a, float b) {\n        ${e}\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    `}}const EL="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n";class $L{constructor(e,t,n){let s=arguments.length>3&&void 0!==arguments[3]&&arguments[3];this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=ef(t,n);const r=this.outputShape.length;this.enableShapeUniforms=KM(r);let i="";if(s)if(0===r||1===xo(this.outputShape))i="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else{if(i=`\n          ${BM(r)} coords = getOutputCoords();\n        `,1===r)this.enableShapeUniforms?i+="\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":i+=`\n            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          `;else{const e=lL("coords",r);this.enableShapeUniforms?i+=`\n            bool nextRowOutOfBounds =\n              (${e[r-2]} + 1) >= outShape[${r} - 2];\n            bool nextColOutOfBounds =\n              (${e[r-1]} + 1) >= outShape[${r} - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `:i+=`\n            bool nextRowOutOfBounds =\n              (${e[r-2]} + 1) >= ${this.outputShape[r-2]};\n            bool nextColOutOfBounds =\n              (${e[r-1]} + 1) >= ${this.outputShape[r-1]};\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          `}}this.userCode=`\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ${e}\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ${i}\n\n        setOutput(result);\n      }\n    `}}function RL(e){const{inputs:t,backend:n}=e,{x:s}=t;return n.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const AL={kernelName:gu,backendName:"webgl",kernelFunc:RL};function DL(e){const{inputs:t,backend:n}=e,{real:s,imag:r}=t,i=n.makeTensorInfo(s.shape,"complex64"),a=n.texData.get(i.dataId),o=RL({inputs:{x:s},backend:n}),l=RL({inputs:{x:r},backend:n});return a.complexTensorInfos={real:o,imag:l},i}const FL={kernelName:Nl,backendName:"webgl",kernelFunc:DL},ML="return (a < 0.) ? b * a : a;",OL="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const LL={kernelName:wu,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{alpha:i}=s,a=n.makeTensorInfo([],"float32",Oh(i,"float32")),o=qo().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new $L(OL,r.shape,a.shape):new _L(ML,r.shape,a.shape),l=n.runWebGLProgram(o,[r,a],"float32");return n.disposeIntermediateTensorInfo(a),l}},PL="return (a < 0.) ? b * a : a;",zL="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const BL={kernelName:nc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:s,alpha:r}=t,i=qo().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new $L(zL,s.shape,r.shape):new _L(PL,s.shape,r.shape);return n.runWebGLProgram(i,[s,r],"float32")}},WL="if (isnan(x)) return x;";function VL(e){let{opSnippet:t,packedOpSnippet:n,cpuKernelImpl:s,dtype:r}=e;return e=>{let{inputs:i,backend:a}=e;const{x:o}=i,l=a,u=r||o.dtype;if(l.shouldExecuteOnCPU([o])&&null!=s){const e=l.texData.get(o.dataId),t=s(e.values,u);return l.makeTensorInfo(o.shape,u,t)}let c;return c=qo().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=n?new wL(o.shape,n):new gL(o.shape,t),l.runWebGLProgram(c,[o],u)}}function UL(e){let{opSnippet:t,packedOpSnippet:n,checkOutOfBounds:s=!1,supportsComplex:r=!1,cpuKernelImpl:i,dtype:a}=e;return e=>{let{inputs:o,backend:l}=e;const{a:u,b:c}=o,h=l;if(r&&"complex64"===u.dtype){const e=h.texData.get(u.dataId),n=h.texData.get(c.dataId),[s,r]=[[e.complexTensorInfos.real,n.complexTensorInfos.real],[e.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((e=>{const[n,s]=e,r={dataId:n.dataId,dtype:n.dtype,shape:u.shape},i={dataId:s.dataId,dtype:s.dtype,shape:c.shape},a=new _L(t,u.shape,c.shape);return h.runWebGLProgram(a,[r,i],cd(n.dtype,s.dtype))})),i=DL({inputs:{real:s,imag:r},backend:h});return h.disposeIntermediateTensorInfo(s),h.disposeIntermediateTensorInfo(r),i}const d=a||cd(u.dtype,c.dtype);if(("string"===u.dtype||"string"===c.dtype||h.shouldExecuteOnCPU([u,c]))&&null!=i){const e=h.texData.get(u.dataId).values,t=h.texData.get(c.dataId).values,n="string"===u.dtype?Zx(e):e,s="string"===u.dtype?Zx(t):t,[r,a]=i(u.shape,c.shape,n,s,d),o=h.makeTensorInfo(a,d);return h.texData.get(o.dataId).values=r,o}let p;return p=qo().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=n?new $L(n,u.shape,c.shape,s):new _L(t,u.shape,c.shape),h.runWebGLProgram(p,[u,c],d)}}function GL(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if("linear"===e)return"return x;";if("relu"===e)return t?"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":xL;if("elu"===e)return t?"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n":"return (x >= 0.0) ? x : (exp(x) - 1.0);";if("relu6"===e)return t?"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n":yL;if("prelu"===e)return t?zL:PL;if("leakyrelu"===e)return t?OL:ML;if("sigmoid"===e)return"return 1.0 / (1.0 + exp(-1.0 * x));";throw new Error(`Activation ${e} has not been implemented for the WebGL backend.`)}class HL{constructor(e,t,n){let s=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4],i=arguments.length>5&&void 0!==arguments[5]&&arguments[5],a=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,o=arguments.length>7&&void 0!==arguments[7]&&arguments[7],l=arguments.length>8&&void 0!==arguments[8]&&arguments[8];this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=KM(this.outputShape.length);const u=s?e[1]:e[2],c=Math.ceil(u/2),h=s?"i * 2, rc.y":"rc.y, i * 2",d=r?"rc.z, i * 2":"i * 2, rc.z",p=s?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=r?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let g="",m="";a&&(g=o?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${a}\n        }`:l?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${a}\n        }`:`vec4 activation(vec4 x) {\n          ${a}\n        }`,m="result = activation(result);");const b=i?"result += getBiasAtOutCoords();":"";i&&this.variableNames.push("bias"),o&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let x="rc.x",y="rc.x";e[0]<t[0]?x=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(y=`imod(rc.x, ${t[0]})`),this.userCode=`\n      ${g}\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ${c}.0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ${x};\n        int batchB = ${y};\n        for (int i = 0; i < ${c}; i++) {\n          vec4 a = getMatrixA(batchA, ${h});\n          vec4 b = getMatrixB(batchB, ${d});\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (${p[0]} * ${f[0]});\n          result += (${p[1]} * ${f[1]});\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ${b}\n\n        ${m}\n\n        setOutput(result);\n      }\n    `}}const jL="return areal * breal - aimag * bimag;",KL="return areal * bimag + aimag * breal;";class XL{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=ef(t,n),this.userCode=`\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ${e}\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    `}}const qL="return a * b;";function YL(e){const{inputs:t,backend:n}=e,{a:s,b:r}=t,i=cd(s.dtype,r.dtype);if("complex64"===s.dtype){const e=n.texData.get(s.dataId),t=n.texData.get(r.dataId),i=new XL(jL,s.shape,r.shape),a=new XL(KL,s.shape,r.shape),o=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:s.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:s.shape},{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:r.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:r.shape}],l=n.runWebGLProgram(i,o,"float32"),u=n.runWebGLProgram(a,o,"float32"),c=DL({inputs:{real:l,imag:u},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),c}if(n.shouldExecuteOnCPU([s,r])){const e=n.texData.get(s.dataId),t=n.texData.get(r.dataId),[a,o]=FO(s.shape,r.shape,e.values,t.values,i),l=n.makeTensorInfo(o,i);return n.texData.get(l.dataId).values=a,l}let a;return a=qo().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new $L(qL,s.shape,r.shape):new _L(qL,s.shape,r.shape),n.runWebGLProgram(a,[s,r],i)}const QL={kernelName:Hu,backendName:"webgl",kernelFunc:YL};function ZL(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{shape:i}=s,a=n,o=xo(r.shape),l=Io(i,o),u=xo(l);go(o===u,(()=>`The new shape (${l}) has ${u} elements and the old shape (${r.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`));const c=a.texData.get(r.dataId);return!c.isPacked||fM(r.shape,l)||null!==c.texture&&fM(c.shape,l)?(a.incRef(r.dataId),{dataId:r.dataId,shape:l,dtype:r.dtype}):function(e,t,n){const s=[cM(e.shape),...hM(e.shape)],r={dtype:e.dtype,shape:s,dataId:e.dataId},i=[cM(t),...hM(t)],a=new cL(i,s),o=[s],l=n.runWebGLProgram(a,[r],e.dtype,o,!0);return{dataId:l.dataId,shape:t,dtype:l.dtype}}(r,l,a)}const JL={kernelName:hc,backendName:"webgl",kernelFunc:ZL};class eP{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:s,inSize:r,outSize:i}=e;this.outputShape=[s,i];const a=4*Math.floor(n/4),o=n%4;let l="sumValue += dot(values, ones);";if(null!=t){const e=1/t;l=`sumValue += dot(values * ${vo(e)?e.toPrecision(2):e}, ones);`}let u="";r%n>0&&(u=`\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return 0.0;\n        }\n      `),this.userCode=`\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${u}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${a}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${l}\n        }\n\n        int inIdx = inOffset + ${a};\n        if (${1===o}) {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ${l}\n        } else if (${2===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ${l}\n        } else if (${3===o}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ${l}\n        }\n        setOutput(sumValue);\n      }\n    `}}class tP{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:s,inSize:r,outSize:i}=e;this.outputShape=[s,i];let a="0.0",o="";"prod"===t?a="1.0":"min"===t?(a="1.0 / 1e-20",o="min"):"max"===t&&(a="-1.0 / 1e-20",o="max");let l=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"sum"===t?l="sumValue":"prod"===t?l="prodValue":"all"===t?l="allValue":"any"===t&&(l="anyValue");const u=4*Math.floor(n/4),c=n%4;let h=`\n      if (${"sum"===t}) {\n        sumValue += dot(values, ones);\n      } else if (${"prod"===t}) {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ${o}(values, minMaxValue);\n        if (${"min"===t} || ${"max"===t}) {\n          minMaxValue = ${o}(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    `,d="vec4";"all"===t?(a="1.0",h="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",d="bvec4"):"any"===t&&(a="0.0",h="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",d="bvec4");let p="";r%n>0&&(p=`\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return initializationValue;\n        }\n      `),this.userCode=`\n      const float initializationValue = ${a};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ${p}\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${n};\n\n        vec4 minMaxValue = vec4(${a});\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ${u}; i += 4) {\n          int inIdx = inOffset + i;\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ${h}\n        }\n\n        int inIdx = inOffset + ${u};\n        if (${1===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${2===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ${h}\n        } else if (${3===c}) {\n          ${d} values = ${d}(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ${h}\n        }\n        setOutput(${l});\n      }\n    `}}function nP(e,t,n,s){const r=function(e){const t=[];for(;0===t.length||1!==t[t.length-1].outSize;){const n=t.length?t[t.length-1].outSize:e[1],s=Jb(n);t.push({inSize:n,windowSize:s,outSize:Math.ceil(n/s)})}return t}(e.shape);let i=e;for(let a=0;a<r.length;a++){const{inSize:o,windowSize:l,outSize:u}=r[a];let c,h;c="mean"===n?0===a?new eP({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u},o):new eP({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u}):new tP({windowSize:l,inSize:o,batchSize:e.shape[0],outSize:u},n),h=i,i=s.runWebGLProgram(c,[i],t),h.dataId!==e.dataId&&s.disposeIntermediateTensorInfo(h)}return i}class sP{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let i=0;i<n.length;i++)n[i]=e[t[i]];this.outputShape=n,this.rank=n.length;const s=BM(this.rank),r=function(e){const t=e.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],s=new Array(t);for(let r=0;r<e.length;r++)s[e[r]]=n[r];return s.join()}(t);this.userCode=`\n    void main() {\n      ${s} resRC = getOutputCoords();\n      setOutput(getA(${r}));\n    }\n    `}}class rP{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(e.length);for(let u=0;u<n.length;u++)n[u]=e[t[u]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const s=BM(this.rank),r=oL("rc",this.rank),i=new Array(this.rank);for(let u=0;u<t.length;u++)i[t[u]]=r[u];const a=`vec2(${i.slice(-2).join()})`,o=`++${r[this.rank-1]} < ${n[this.rank-1]}`,l=`getChannel(getA(${i.join()}), ${a})`;this.userCode=`\n    void main() {\n      ${s} rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ${l};\n      if(${o}) {\n        result[1] = ${l};\n      }\n      --${r[this.rank-1]};\n      if(++${r[this.rank-2]} < ${n[this.rank-2]}) {\n        result[2] = ${l};\n        if(${o}) {\n          result[3] = ${l};\n        }\n      }\n      setOutput(result);\n    }\n    `}}function iP(e,t,n){const s=qo().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new rP(e.shape,t):new sP(e.shape,t);return n.runWebGLProgram(s,[e],e.dtype)}function aP(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:i,keepDims:a}=s;return function(e,t,n,s){const r=t,i=e.shape.length,a=Co(r,e.shape);let o=a;const l=Gg(o,i),u=null!=l;let c=e;u&&(c=iP(e,l,s),o=jg(o.length,i)),Ug("sum",o,i);const[h,d]=Wg(c.shape,o);let p=h;n&&(p=Vg(h,a));const f=xo(d),g=ZL({inputs:{x:c},attrs:{shape:[xo(e.shape)/f,f]},backend:s}),m=nP(g,hd(e.dtype),"sum",s),b=ZL({inputs:{x:m},attrs:{shape:p},backend:s});return s.disposeIntermediateTensorInfo(g),s.disposeIntermediateTensorInfo(m),u&&s.disposeIntermediateTensorInfo(c),b}(r,i,a,n)}const oP={kernelName:Ac,backendName:"webgl",kernelFunc:aP};function lP(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{perm:i}=s,a=n,o=r.shape.length,l=new Array(o);for(let c=0;c<l.length;c++)l[c]=r.shape[i[c]];let u;if(a.shouldExecuteOnCPU([r])){const e=a.texData.get(r.dataId).values,t=iL(e,r.shape,r.dtype,i,l);u=a.makeTensorInfo(l,r.dtype);a.texData.get(u.dataId).values=t}else u=iP(r,i,a);return u}const uP={kernelName:eh,backendName:"webgl",kernelFunc:lP};function cP(e){let{a:t,b:n,transposeA:s,transposeB:r,backend:i,bias:a=null,preluActivationWeights:o=null,leakyreluAlpha:l=0,activation:u=null}=e;const c=t.shape.length,h=n.shape.length,d=s?t.shape[c-2]:t.shape[c-1],p=r?n.shape[h-1]:n.shape[h-2],f=s?t.shape[c-1]:t.shape[c-2],g=r?n.shape[h-2]:n.shape[h-1],m=t.shape.slice(0,-2),b=n.shape.slice(0,-2),x=xo(m),y=xo(b),v=ef(t.shape.slice(0,-2),n.shape.slice(0,-2)).concat([f,g]);go(d===p,(()=>`Error in matMul: inner shapes (${d}) and (${p}) of Tensors with shapes ${t.shape} and ${n.shape} and transposeA=${s} and transposeB=${r} must match.`));const w=s?[x,d,f]:[x,f,d],k=r?[y,g,p]:[y,p,g],S=ZL({inputs:{x:t},backend:i,attrs:{shape:w}}),I=ZL({inputs:{x:n},backend:i,attrs:{shape:k}}),C=[S,I],N=Math.max(x,y),T=s?S.shape[1]:S.shape[2],_=null!=a,E=null!=o,$="leakyrelu"===u,R=null!=u?GL(u,!0):null;let A;if((1===f||1===g)&&T>1e3&&!1===(_||E||$||null!=R)){let e=S,t=I;s&&(e=lP({inputs:{x:S},backend:i,attrs:{perm:[0,2,1]}}),C.push(e)),r&&(t=lP({inputs:{x:I},backend:i,attrs:{perm:[0,2,1]}}),C.push(t));const n=1===g;let a=e;1!==g&&(a=ZL({inputs:{x:e},backend:i,attrs:{shape:[N,T,1]}}),C.push(a));const o=1===g?2:1;let l=t;n&&(l=ZL({inputs:{x:t},backend:i,attrs:{shape:[N,1,T]}}),C.push(l));const u=YL({inputs:{a:a,b:l},backend:i});A=aP({inputs:{x:u},backend:i,attrs:{axis:o,keepDims:!0}}),C.push(u)}else{const e=cd(t.dtype,n.dtype),u=new HL(w,k,[N,f,g],s,r,_,R,E,$),c=[S,I];if(null!=a&&c.push(a),E&&c.push(o),$){const e=i.makeTensorInfo([],"float32",Oh(l,"float32"));c.push(e),C.push(e)}A=i.runWebGLProgram(u,c,e)}const D=ZL({inputs:{x:A},backend:i,attrs:{shape:v}});C.push(A);for(const F of C)i.disposeIntermediateTensorInfo(F);return D}const hP={kernelName:lh,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{a:r,b:i,bias:a,preluActivationWeights:o}=t,{transposeA:l,transposeB:u,activation:c,leakyreluAlpha:h}=s;return cP({a:r,b:i,transposeA:l,transposeB:u,backend:n,bias:a,preluActivationWeights:o,leakyreluAlpha:h,activation:c})}},dP="return abs(x);";const pP={kernelName:el,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:s}=t;if(n.shouldExecuteOnCPU([s])&&"complex64"!==s.dtype){const e=n.texData.get(s.dataId),t=HO(e.values);return n.makeTensorInfo(s.shape,s.dtype,t)}let r;return r=qo().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new wL(s.shape,dP):new gL(s.shape,dP),n.runWebGLProgram(r,[s],s.dtype)}},fP=VL({opSnippet:mL+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),gP={kernelName:tl,backendName:"webgl",kernelFunc:fP},mP=VL({opSnippet:mL+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),bP={kernelName:nl,backendName:"webgl",kernelFunc:mP},xP="return a + b;",yP=UL({opSnippet:xP,packedOpSnippet:xP,supportsComplex:!0,cpuKernelImpl:dO}),vP={kernelName:sl,backendName:"webgl",kernelFunc:yP};class wP{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));const n=[];this.variableNames.forEach((e=>{n.push(`float v${e} = get${e}AtOutCoords();`)}));const s=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        float result = ${s};\n        setOutput(result);\n      }\n    `}}class kP{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map(((e,t)=>`T${t}`));const n=[];this.variableNames.forEach((e=>{n.push(`vec4 v${e} = get${e}AtOutCoords();`)}));const s=this.variableNames.map((e=>`v${e}`)).join(" + ");this.userCode=`\n      void main() {\n        ${n.join("\n        ")}\n\n        vec4 result = ${s};\n        setOutput(result);\n      }\n    `}}const SP={kernelName:rl,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:s}=t,r=n;if(1===r.length)return RL({inputs:{x:r[0]},backend:s});if(r.length>qo().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const t=Math.floor(r.length/2),n=e({inputs:r.slice(0,t),backend:s}),i=e({inputs:r.slice(t),backend:s});return e({inputs:[n,i],backend:s})}const i=r.map((e=>e.dtype)).reduce(((e,t)=>cd(e,t))),a=r.map((e=>e.shape)),o=qo().getBool("WEBGL_PACK")?new kP(r[0].shape,a):new wP(r[0].shape,a);return s.runWebGLProgram(o,r,i)}};const IP={kernelName:il,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:i,keepDims:a}=s,o=r.shape.length,l=Co(i,r.shape);let u=l;const c=Gg(u,o);let h=r;null!=c&&(h=lP({inputs:{x:r},backend:n,attrs:{perm:c}}),u=jg(u.length,o)),Ug("all",u,o);const[d,p]=Wg(h.shape,u),f=ZL({inputs:{x:h},backend:n,attrs:{shape:[-1,xo(p)]}}),g=nP(f,f.dtype,"all",n);let m;if(a){m=ZL({inputs:{x:g},backend:n,attrs:{shape:Vg(d,l)}})}else m=ZL({inputs:{x:g},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),null!=c&&n.disposeIntermediateTensorInfo(h),m}};const CP={kernelName:al,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:i,keepDims:a}=s,o=r.shape.length,l=Co(i,r.shape);let u=l;const c=Gg(u,o);let h=r;null!=c&&(h=lP({inputs:{x:r},backend:n,attrs:{perm:c}}),u=jg(u.length,o)),Ug("any",u,o);const[d,p]=Wg(h.shape,u),f=ZL({inputs:{x:h},backend:n,attrs:{shape:[-1,xo(p)]}}),g=nP(f,f.dtype,"any",n);let m;if(a){m=ZL({inputs:{x:g},backend:n,attrs:{shape:Vg(d,l)}})}else m=ZL({inputs:{x:g},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),null!=c&&n.disposeIntermediateTensorInfo(h),m}};class NP{constructor(e,t,n){this.variableNames=["A"];const{windowSize:s,batchSize:r,outSize:i}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[r,i];const a="max"===t?">":"<",o=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ${s};\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ${s}; i++) {\n          int inIdx = ${o};\n          float candidate = getA(batch, inIdx);\n          if (candidate ${a} bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    `}}class TP{constructor(e,t,n,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,go(e.length>2,(()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`));const r=e[e.length-1],i=Math.ceil(r/t);this.outputShape=e.slice(0,-1),i>1&&this.outputShape.push(i),s||this.variableNames.push("bestIndicesA");const a=this.outputShape,o=a.length,l=BM(o),u=lL("coords",o);let c,h;if(1===i){h=o+1;const e=BM(h);c=`\n        ${e} sourceLocR = ${e}(${u.join()}, 0);\n        ++${u[o-1]};\n        ${e} sourceLocG = ${e}(${u.join()}, 0);\n        ++${u[o-2]};\n        ${e} sourceLocA = ${e}(${u.join()}, 0);\n        --${u[o-1]};\n        ${e} sourceLocB = ${e}(${u.join()}, 0);\n        --${u[o-2]};`}else h=o,c=`\n        ${l} sourceLocR = coords;\n        ++${u[o-1]};\n        ${l} sourceLocG = coords;\n        ++${u[o-2]};\n        ${l} sourceLocA = coords;\n        --${u[o-1]};\n        ${l} sourceLocB = coords;\n        --${u[o-2]};`;const d=["x","y","z","w","u","v"].slice(0,h),p="."+d[h-1],f=d.map((e=>"int "+e)),g=lL("sourceLocR",h-1).concat("inIdx.r"),m=lL("sourceLocG",h-1).concat("inIdx.g"),b=lL("sourceLocB",h-1).concat("inIdx.b"),x=lL("sourceLocA",h-1).concat("inIdx.a"),y="max"===n?"greaterThan":"lessThan",v=s?"":`\n          inIdx = round(vec4(getBestIndicesAChannel(${g.join()}),\n                             getBestIndicesAChannel(${m.join()}),\n                             getBestIndicesAChannel(${b.join()}),\n                             getBestIndicesAChannel(${x.join()})));`,w=`vec4(\n            getAChannel(${g.join()}),\n            hasNextCol ? getAChannel(${m.join()}) : 0.,\n            hasNextRow ? getAChannel(${b.join()}) : 0.,\n            hasNextRow && hasNextCol ? getAChannel(${x.join()}) : 0.)`,k=s?"":`\n      float getBestIndicesAChannel(${f.join()}) {\n        return getChannel(getBestIndicesA(${d.join()}),\n                                          vec2(${d.slice(-2).join()}));\n      }`;this.userCode=`\n      float getAChannel(${f.join()}) {\n        return getChannel(getA(${d.join()}),\n                               vec2(${d.slice(-2).join()}));\n      }\n      ${k}\n      void main() {\n        ${l} coords = getOutputCoords();\n        bool hasNextCol = ${u[o-1]} < ${a[o-1]-1};\n        bool hasNextRow = ${u[o-2]} < ${a[o-2]-1};\n        ${c}\n        ivec4 srcIdx = ivec4(sourceLocR${p}, sourceLocG${p},\n          sourceLocB${p}, sourceLocA${p}) * ${t};\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ${w};\n\n        for (int i = 0; i < ${t}; i++) {\n          inIdx = srcIdx;\n          ${v}\n          vec4 candidate = ${w};\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(${y}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    `}}function _P(e,t,n){let s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,r=t.shape[0],i=t.shape[1];null!=s&&(r=s.shape[0],i=s.shape[1]);const a=Jb(i),o={windowSize:a,inSize:i,batchSize:r,outSize:Math.ceil(i/a)},l=new NP(o,n,null==s),u=[t];null!=s&&u.push(s);const c=e.runWebGLProgram(l,u,"int32");if(1===c.shape[1])return c;const h=_P(e,t,n,c);return e.disposeIntermediateTensorInfo(c),h}function EP(e,t,n){let s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const r=null!=s?s.shape:t.shape,i=Jb(r[r.length-1]),a=new TP(r,i,n,null==s),o=null==s?[t]:[t,s],l=e.runWebGLProgram(a,o,"int32");if(l.shape.length===t.shape.length){const s=EP(e,t,n,l);return e.disposeIntermediateTensorInfo(l),s}return l}function $P(e,t,n,s){const r=[n];if(Ug("arg"+s.charAt(0).toUpperCase()+s.slice(1),r,t.shape.length),!qo().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const n=[],i=e.texData.get(t.dataId);let a=t;null!==i&&i.isPacked&&(a=e.unpackTensor(t),n.push(a));const[o,l]=Wg(a.shape,r),u=xo(l),c=ZL({inputs:{x:a},backend:e,attrs:{shape:[-1,u]}});n.push(c);const h=_P(e,c,s);n.push(h);const d=ZL({inputs:{x:h},backend:e,attrs:{shape:o}});return n.forEach((t=>e.disposeIntermediateTensorInfo(t))),d}return EP(e,t,s)}const RP={kernelName:ol,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:i}=s;let a=Co(i,r.shape);const o=Gg(a,r.shape.length);let l=r;const u=[];null!=o&&(l=lP({inputs:{x:r},backend:n,attrs:{perm:o}}),u.push(l),a=jg(a.length,l.shape.length)),Ug("argMax",[a[0]],l.shape.length);const c=$P(n,l,a[0],"max");return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}};const AP={kernelName:ll,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:i}=s;let a=Co(i,r.shape);const o=Gg(a,r.shape.length);let l=r;const u=[];null!=o&&(l=lP({inputs:{x:r},backend:n,attrs:{perm:o}}),u.push(l),a=jg(a.length,l.shape.length)),Ug("argMin",[a[0]],l.shape.length);const c=$P(n,l,a[0],"min");return u.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}},DP=VL({opSnippet:mL+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),FP={kernelName:ul,backendName:"webgl",kernelFunc:DP},MP=VL({opSnippet:mL+"return log(x + sqrt(x * x + 1.0));"}),OP={kernelName:cl,backendName:"webgl",kernelFunc:MP},LP=VL({opSnippet:mL+"\n  return atan(x);\n"}),PP={kernelName:hl,backendName:"webgl",kernelFunc:LP},zP=UL({opSnippet:TL+"\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+EL+"\n  return result;\n"}),BP={kernelName:pl,backendName:"webgl",kernelFunc:zP},WP=VL({opSnippet:mL+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),VP={kernelName:dl,backendName:"webgl",kernelFunc:WP};class UP{constructor(e,t,n){let s=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const i=e.filterWidth,a=e.strideHeight,o=e.strideWidth,l=e.dilationHeight,u=e.dilationWidth,c=e.effectiveFilterHeight,h=e.effectiveFilterWidth,d=e.padInfo.top,p=e.padInfo.left;this.outputShape=e.outShape;const f="avg"===t,g=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,m=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let b="0.0";if(f||(b="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode=`\n        const ivec2 strides = ivec2(${a}, ${o});\n        const ivec2 pads = ivec2(${d}, ${p});\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ${c};\n              wR += ${l}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${h};\n                wC += ${u}) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ${t} currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ${s?r?g:m:`wR * ${h} + wC`};\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let x=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(x="avgValue / max(count, 1.0)");const y=4*Math.floor(i/4),v=i%4,w=`\n      if (${f}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec2 strides = ivec2(${a}, ${o});\n      const ivec2 pads = ivec2(${d}, ${p});\n      const float initializationValue = ${b};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${b});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ${c};\n            wR += ${l}) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${y}; wC += 4) {\n            int xC = xCCorner + wC * ${u};\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              getValue(batch, xR, xC + 3 * ${u}, d)\n            );\n\n            ${w}\n          }\n\n          int xC = xCCorner + ${y};\n          if (${1===v}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ${w}\n          } else if (${2===v}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              initializationValue,\n              initializationValue\n            );\n\n            ${w}\n          } else if (${3===v}) {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ${u}, d),\n              getValue(batch, xR, xC + 2 * ${u}, d),\n              initializationValue\n            );\n\n            ${w}\n          }\n        }\n        setOutput(${x});\n      }\n    `}}class GP{constructor(e,t,n){let s=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const i=e.filterWidth,a=e.strideDepth,o=e.strideHeight,l=e.strideWidth,u=e.dilationDepth,c=e.dilationHeight,h=e.dilationWidth,d=e.effectiveFilterDepth,p=e.effectiveFilterHeight,f=e.effectiveFilterWidth,g=e.padInfo.front,m=e.padInfo.top,b=e.padInfo.left;this.outputShape=e.outShape;const x="avg"===t;let y="0.0";if(x||(y="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode=`\n        const ivec3 strides =\n            ivec3(${a}, ${o}, ${l});\n        const ivec3 pads = ivec3(${g}, ${m}, ${b});\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ${d};\n              wD += ${u}) {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int wR = 0; wR < ${p};\n                wR += ${c}) {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int wC = 0; wC < ${f};\n                  wC += ${h}) {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ${t} currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ${s?r?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${p} * ${f} +\n                      wR * ${f} + wC`};\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      `)}let v=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;"avg"===t&&(v="avgValue / max(count, 1.0)");const w=4*Math.floor(i/4),k=i%4,S=`\n      if (${x}) {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = max(values, minMaxValue);\n      }\n    `;this.userCode=`\n      const ivec3 strides =\n        ivec3(${a}, ${o}, ${l});\n      const ivec3 pads = ivec3(${g}, ${m}, ${b});\n      const float initializationValue = ${y};\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ${e.inWidth}) {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(${y});\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ${d};\n            wD += ${u}) {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${p};\n            wR += ${c}) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${w}; wC += 4) {\n              int xC = xCCorner + wC * ${h};\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                getValue(batch, xD, xR, xC + 3 * ${h}, ch)\n              );\n\n              ${S}\n            }\n\n            int xC = xCCorner + ${w};\n            if (${1===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ${S}\n            } else if (${2===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ${S}\n            } else if (${3===k}) {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ${h}, ch),\n                getValue(batch, xD, xR, xC + 2 * ${h}, ch),\n                initializationValue\n              );\n\n              ${S}\n            }\n          }\n        }\n        setOutput(${v});\n      }\n    `}}const HP={kernelName:fl,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t;wM(r,"avgPool");const{filterSize:i,strides:a,pad:o,dimRoundingMode:l}=s;go(qf(a,1),(()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '1'`));const u=zf(r.shape,i,a,1,o,l);if(1===u.filterWidth&&1===u.filterHeight&&yo(u.inShape,u.outShape))return RL({inputs:{x:r},backend:n});const c=new UP(u,"avg",!1);return n.runWebGLProgram(c,[r],"float32")}};const jP={kernelName:ml,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{filterSize:i,strides:a,pad:o,dimRoundingMode:l,dataFormat:u}=s,c=Bf(r.shape,i,a,[1,1,1],o,l,u),h=new GP(c,"avg",!1);return n.runWebGLProgram(h,[r],"float32")}};class KP{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,s=e.strideHeight,r=e.strideWidth,i=e.dilationHeight,a=e.dilationWidth,o=e.effectiveFilterHeight,l=e.effectiveFilterWidth,u=o-1-e.padInfo.top,c=l-1-e.padInfo.left,h=1/(t*n);this.userCode=`\n      const ivec2 pads = ivec2(${u}, ${c});\n      const float avgMultiplier = float(${h});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${o};\n            wR += ${i}) {\n          float dyR = float(dyRCorner + wR) / ${s}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${l};\n            wC+= ${a}) {\n            float dyC = float(dyCCorner + wC) / ${r}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class XP{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,s=e.filterWidth,r=e.strideDepth,i=e.strideHeight,a=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,c=e.effectiveFilterDepth,h=e.effectiveFilterHeight,d=e.effectiveFilterWidth,p=c-1-e.padInfo.front,f=h-1-e.padInfo.top,g=d-1-e.padInfo.left,m=1/(t*n*s);this.userCode=`\n      const ivec3 pads = ivec3(${p}, ${f}, ${g});\n      const float avgMultiplier = float(${m});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${c};\n            wD += ${o}) {\n          float dyD = float(dyDCorner + wD) / ${r}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${h};\n              wR += ${l}) {\n            float dyR = float(dyRCorner + wR) / ${i}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${d};\n                wC += ${u}) {\n              float dyC = float(dyCCorner + wC) / ${a}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const qP={kernelName:bl,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,input:i}=t,a=i,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=s,h=Bf(a.shape,o,l,[1,1,1],u,c),d=new XP(h);return n.runWebGLProgram(d,[r],a.dtype)}};const YP={kernelName:gl,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,input:i}=t,a=i;wM([r,i],"avgPoolGrad");const{filterSize:o,strides:l,pad:u}=s,c=zf(a.shape,o,l,1,u),h=new KP(c);return n.runWebGLProgram(h,[r],a.dtype)}};const QP={kernelName:xl,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{a:r,b:i}=t,{transposeA:a,transposeB:o}=s;return cP({a:r,b:i,transposeA:a,transposeB:o,backend:n})}};class ZP{constructor(e,t,n,s,r,i){this.outputShape=[],this.variableNames=["x","mean","variance"],ef(e,t),ef(e,n);let a="0.0";null!=s&&(ef(e,s),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let o="1.0";null!=r&&(ef(e,r),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ${a};\n        float scale = ${o};\n        float inv = scale * inversesqrt(variance + float(${i}));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    `}}class JP{constructor(e,t,n,s,r,i){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],ef(e,t),ef(e,n);let a="vec4(0.0)";null!=s&&(ef(e,s),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let o="vec4(1.0)";null!=r&&(ef(e,r),this.variableNames.push("scale"),o="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`\n      void main() {\n        vec4 offset = ${a};\n        vec4 scale = ${o};\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(${i}));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    `}}const ez={kernelName:cu,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:s}=e;const{x:r,mean:i,variance:a,offset:o,scale:l}=t;go(i.shape.length===a.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),go(null==o||i.shape.length===o.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),go(null==l||i.shape.length===l.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let{varianceEpsilon:u}=s;null==u&&(u=.001);const c=[r,i,a];let h=null;null!=o&&(h=o.shape,c.push(o));let d=null;null!=l&&(d=l.shape,c.push(l));const p=qo().getBool("WEBGL_PACK_NORMALIZATION")?new JP(r.shape,i.shape,a.shape,h,d,u):new ZP(r.shape,i.shape,a.shape,h,d,u);return n.runWebGLProgram(p,c,c[0].dtype)}};class tz{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=BM(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=function(e){if(1===e)return"sourceLoc";if(e<=6)return nz.slice(0,e).map((e=>"sourceLoc."+e)).join(",");throw Error(`Slicing for rank ${e} is not yet supported`)}(this.rank);let s;s=`\n        ${t} sourceLoc;\n        ${t} coords = getOutputCoords();\n        ${e.map(((e,t)=>`sourceLoc.${nz[t]} = start[${t}] + coords.${nz[t]};`)).join("\n")}\n      `,this.userCode=`\n      void main() {\n        ${s}\n        setOutput(getSource(${n}));\n      }\n    `}}const nz=["x","y","z","w","u","v"];class sz{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=BM(this.rank),n=lL("coords",this.rank),s=lL("sourceLoc",this.rank),r=1===this.rank?"sourceLoc":`vec2(${s.slice(-2).join()})`,i=`getChannel(getSource(${s.join()}), ${r})`,a=`\n      result.x = ${i};\n      if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n        ++${s[this.rank-1]};\n        result.y = ${i};\n        --${s[this.rank-1]};\n      }\n    `,o=1===this.rank?"":`\n      --${n[this.rank-1]};\n      if (++${n[this.rank-2]} < ${e[this.rank-2]}) {\n        ++${s[this.rank-2]};\n        result.z = ${i};\n        if (++${n[this.rank-1]} < ${e[this.rank-1]}) {\n          ++${s[this.rank-1]};\n          result.w = ${i};\n        }\n      }\n    `,l=this.rank<=4?`sourceLoc = coords +\n            ${t}(${e.map(((e,t)=>`start[${t}]`)).join()});`:e.map(((e,t)=>`${s[t]} = ${n[t]} + start[${t}];`)).join("\n");this.userCode=`\n      void main() {\n        ${t} coords = getOutputCoords();\n        ${t} sourceLoc;\n        ${l}\n        vec4 result = vec4(0.);\n        ${a}\n        ${o}\n        setOutput(result);\n      }\n    `}}function rz(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{begin:i,size:a}=s,[o,l]=Af(r,i,a);if(xf(r,o,l),0===xo(l))return n.makeTensorInfo(l,r.dtype,[]);if(n.shouldExecuteOnCPU([r])||"string"===r.dtype){const e=n.texData.get(r.dataId),t=jO(e.values,o,l,r.shape,r.dtype);return n.makeTensorInfo(l,r.dtype,t)}const{isPacked:u}=n.texData.get(r.dataId),c=$f(r.shape,o,l);if(u||!c){const e=qo().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new sz(l):new tz(l),t=[o];return n.runWebGLProgram(e,[r],r.dtype,t)}return n.uploadToGPU(r.dataId),function(e,t,n,s){const r=s.texData.get(e.dataId),i=s.makeTensorInfo(n,e.dtype),a=s.texData.get(i.dataId);Object.assign(a,r),a.refCount=1,a.shape=n,a.dtype=e.dtype;let o=Rf(t,Oo(e.shape));r.slice&&(o+=r.slice.flatOffset),a.slice={flatOffset:o,origDataId:r.slice&&r.slice.origDataId||e.dataId};const l=s.dataRefCount.get(a.slice.origDataId)||1;return s.dataRefCount.set(a.slice.origDataId,l+1),i}(r,o,l,n)}const iz={kernelName:Cc,backendName:"webgl",kernelFunc:rz},az={kernelName:yl,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{blockShape:i,crops:a}=s;go(r.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"));const o=i.reduce(((e,t)=>e*t)),l=tx(r.shape,i,o),u=nx(l.length,i.length),c=sx(r.shape,i,o),h=rx(a,i.length),d=ix(c,a,i.length),p=[],f=ZL({inputs:{x:r},backend:n,attrs:{shape:l}}),g=lP({inputs:{x:f},backend:n,attrs:{perm:u}}),m=ZL({inputs:{x:g},backend:n,attrs:{shape:c}}),b=rz({inputs:{x:m},backend:n,attrs:{begin:h,size:d}});return p.push(f),p.push(g),p.push(m),p.forEach((e=>n.disposeIntermediateTensorInfo(e))),b}};const oz={kernelName:vl,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,weights:i}=t,{size:a}=s,o=n.readSync(r.dataId),l=n.readSync(i.dataId),u=pO(o,l,i.dtype,i.shape,a);return n.makeTensorInfo([a],i.dtype,u)}};const lz={kernelName:wl,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{a:s,b:r}=t,i=qo().getBool("WEBGL_PACK_BINARY_OPERATIONS"),a=qo().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([s,r])||1===a){const e=n.texData.get(s.dataId).values,t=n.texData.get(r.dataId).values,[i,a]=gO(s.shape,r.shape,e,t,s.dtype),o=n.makeTensorInfo(a,s.dtype);return n.texData.get(o.dataId).values=i,o}let o;return o=i?new $L("\n  int r = int(a.r) & int(b.r);\n  int g = int(a.g) & int(b.g);\n  int rb = int(a.b) & int(b.b);\n  int ra = int(a.a) & int(b.a);\n  return vec4(r, g, rb, ra);\n",s.shape,r.shape,!1):new _L("\n  return float(int(a.r) & int(b.r));\n",s.shape,r.shape),n.runWebGLProgram(o,[s,r],s.dtype)}};const uz={kernelName:kl,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:s,s1:r}=t,i=n.readSync(s.dataId),a=n.readSync(r.dataId),o=ef(Array.from(i),Array.from(a));return n.makeTensorInfo([o.length],"int32",Int32Array.from(o))}},cz=UL({opSnippet:"return float(a != b);",cpuKernelImpl:OO,dtype:"bool"}),hz={kernelName:Ku,backendName:"webgl",kernelFunc:cz};function dz(e){const{inputs:t,backend:n}=e,{input:s}=t;return RL({inputs:{x:n.texData.get(s.dataId).complexTensorInfos.real},backend:n})}const pz={kernelName:lc,backendName:"webgl",kernelFunc:dz};const fz={kernelName:Sl,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:s,attrs:r}=t,{x:i}=n,{dtype:a}=r;if("complex64"===a){if("complex64"===i.dtype)return RL({inputs:{x:i},backend:s});const t=im(i.shape),n=e({inputs:{x:i},backend:s,attrs:{dtype:"float32"}}),r=DL({inputs:{real:n,imag:t},backend:s});return t.dispose(),s.disposeIntermediateTensorInfo(n),r}if("complex64"===i.dtype){const t=dz({inputs:{input:i},backend:s}),n=e({inputs:{x:t},backend:s,attrs:{dtype:a}});return s.disposeIntermediateTensorInfo(t),n}if(!Eo(i.dtype,a)){const e=RL({inputs:{x:i},backend:s});return{dataId:e.dataId,shape:e.shape,dtype:a}}if(s.shouldExecuteOnCPU([i])){const e=s.texData.get(i.dataId).values,[t,n,r]=mO(e,i.shape,i.dtype,a);return s.makeTensorInfo(t,n,r)}if("int32"===a)return function(e,t){const n=new gL(e.shape,"return float(int(x));"),s=t.runWebGLProgram(n,[e],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}(i,s);if("bool"===a){const e=s.makeTensorInfo([],"bool",To("bool",1)),t=cz({inputs:{a:i,b:e},backend:s});return s.disposeIntermediateTensorInfo(e),t}throw new Error(`Error in Cast: failed to cast ${i.dtype} to ${a}`)}},gz="return ceil(x);",mz=VL({opSnippet:gz,packedOpSnippet:gz,cpuKernelImpl:bO}),bz={kernelName:Il,backendName:"webgl",kernelFunc:mz};class xz{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class yz{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const vz={kernelName:Cl,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{clipValueMin:i,clipValueMax:a}=s;let o;o=qo().getBool("WEBGL_PACK_CLIP")?new yz(r.shape):new xz(r.shape);const l=[[i],[a]];return n.runWebGLProgram(o,[r],r.dtype,l)}};class wz{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function kz(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}const Sz={kernelName:Tl,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:s}=t,r=n.texData.get(s.dataId),i=new wz(s.shape),a=[kz(s,r.complexTensorInfos.real),kz(s,r.complexTensorInfos.imag)];return n.runWebGLProgram(i,a,a[0].dtype)}};class Iz{constructor(e){this.outputShape=[],this.outputShape=jb(e,1),this.variableNames=e.map(((e,t)=>`T${t}`));const t=new Array(e.length-1);t[0]=e[0][1];for(let i=1;i<t.length;i++)t[i]=t[i-1]+e[i][1];const n=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let i=1;i<t.length;i++){const e=t[i-1];n.push(`else if (yC < ${t[i]}) setOutput(getT${i}(yR, yC-${e}));`)}const s=t.length,r=t[t.length-1];n.push(`else setOutput(getT${s}(yR, yC-${r}));`),this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ${n.join("\n        ")}\n      }\n    `}}class Cz{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=jb(e,t);const n=this.outputShape,s=n.length,r=BM(s),i=lL("coords",s),a=["x","y","z","w","u","v"].slice(0,s);this.variableNames=e.map(((e,t)=>`T${t}`));const o=new Array(e.length-1);o[0]=e[0][t];for(let f=1;f<o.length;f++)o[f]=o[f-1]+e[f][t];const l=a[t],u=a.slice(-2),c=a.join();let h=`if (${l} < ${o[0]}) {\n        return getChannel(\n            getT0(${c}), vec2(${u.join()}));\n        }`;for(let f=1;f<o.length;f++){const e=o[f-1];h+=`\n        if (${l} < ${o[f]}  && ${l} >= ${o[f-1]}) {\n          return getChannel(\n            getT${f}(${Nz(a,l,e)}),\n            vec2(${Nz(u,l,e)}));\n        }`}const d=o.length,p=o[o.length-1];h+=`\n        return getChannel(\n          getT${d}(${Nz(a,l,p)}),\n          vec2(${Nz(u,l,p)}));`,this.userCode=`\n      float getValue(${a.map((e=>"int "+e))}) {\n        ${h}\n      }\n\n      void main() {\n        ${r} coords = getOutputCoords();\n        vec4 result = vec4(getValue(${i}), 0., 0., 0.);\n\n        ${i[s-1]} = ${i[s-1]} + 1;\n        if (${i[s-1]} < ${n[s-1]}) {\n          result.g = getValue(${i});\n        }\n\n        ${i[s-2]} = ${i[s-2]} + 1;\n        if (${i[s-2]} < ${n[s-2]}) {\n          result.a = getValue(${i});\n        }\n\n        ${i[s-1]} = ${i[s-1]} - 1;\n        if (${i[s-2]} < ${n[s-2]} &&\n            ${i[s-1]} < ${n[s-1]}) {\n          result.b = getValue(${i});\n        }\n        setOutput(result);\n      }\n    `}}function Nz(e,t,n){const s=e.indexOf(t);return e.map(((e,t)=>t===s?`${e} - ${n}`:e)).join()}function Tz(e){const{inputs:t,backend:n}=e,{input:s}=t;return RL({inputs:{x:n.texData.get(s.dataId).complexTensorInfos.imag},backend:n})}const _z={kernelName:bu,backendName:"webgl",kernelFunc:Tz};function Ez(e,t,n){const s=e[0].dtype;if("complex64"===s){const s=e.map((e=>dz({inputs:{input:e},backend:n}))),r=e.map((e=>Tz({inputs:{input:e},backend:n}))),i=Ez(s,t,n),a=Ez(r,t,n),o=DL({inputs:{real:i,imag:a},backend:n});return s.forEach((e=>n.disposeIntermediateTensorInfo(e))),r.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(a),o}let r=n.shouldExecuteOnCPU(e);if("string"===s&&(r=!0),r){const r=e.map((e=>{const s=xo(e.shape.slice(t));return ZL({inputs:{x:e},backend:n,attrs:{shape:[-1,s]}})})),i=r.map((e=>({vals:n.readSync(e.dataId),shape:e.shape}))),a=jb(r.map((e=>e.shape)),1),o=1===r[0].shape[0],l=xO(i,a,s,o),u=jb(e.map((e=>e.shape)),t),c=n.makeTensorInfo(u,s,l);return r.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}const i=e.filter((e=>xo(e.shape)>0)),a=qo().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&i[0].shape.length>1;if(1===i.length){const t=a?new gL(e[0].shape,vL):new wL(e[0].shape,vL);return n.runWebGLProgram(t,e,s)}const o=qo().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(i.length>o){const e=[];for(let r=0;r<i.length;r+=o){const s=i.slice(r,r+o);e.push(Ez(s,t,n))}const s=Ez(e,t,n);for(const t of e)n.disposeIntermediateTensorInfo(t);return s}if(a){const e=new Cz(i.map((e=>e.shape)),t);return n.runWebGLProgram(e,i,s)}const{tensors2D:l,outShape:u}=function(e,t,n){const s=jb(e.map((e=>e.shape)),t),r=e.map((e=>ZL({inputs:{x:e},attrs:{shape:[-1,xo(e.shape.slice(t))]},backend:n})));return{tensors2D:r,outShape:s}}(i,t,n),c=new Iz(l.map((e=>e.shape))),h=n.runWebGLProgram(c,l,s);l.forEach((e=>n.disposeIntermediateTensorInfo(e)));const d=ZL({inputs:{x:h},attrs:{shape:u},backend:n});return n.disposeIntermediateTensorInfo(h),d}function $z(e){const{inputs:t,backend:n,attrs:s}=e,{axis:r}=s,i=Co(r,t[0].shape)[0];Hb(t.map((e=>e.shape)),i);const a=jb(t.map((e=>e.shape)),i);if(0===xo(a))return n.makeTensorInfo(a,t[0].dtype,[]);const o=t.filter((e=>xo(e.shape)>0));return 1===o.length?RL({inputs:{x:o[0]},backend:n}):Ez(o,i,n)}const Rz={kernelName:_l,backendName:"webgl",kernelFunc:$z};class Az{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,s=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.outputShape=e.outShape;const i=e.padInfo.top,a=e.padInfo.left,o=e.strideHeight,l=e.strideWidth,u=e.dilationHeight,c=e.dilationWidth,h=e.filterHeight,d=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4,g="channelsLast"===e.dataFormat,m=g?1:2,b=g?2:3,x=g?3:1;let y="",v="";n&&(y=s?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:r?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,v="result = activation(result);");const w=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${y}\n\n      const ivec2 strides = ivec2(${o}, ${l});\n      const ivec2 pads = ivec2(${i}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[${x}];\n\n        ivec2 xRCCorner =\n            ivec2(coords[${m}], coords[${b}]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${h}; wR++) {\n          int xR = xRCorner + wR * ${u};\n\n          if (xR < 0 || xR >= ${e.inHeight}) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${d}; wC++) {\n            int xC = xCCorner + wC * ${c};\n\n            if (xC < 0 || xC >= ${e.inWidth}) {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ${p}; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (${g}) {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (${1===f}) {\n\n              if (${g}) {\n                dotProd +=\n                    getX(batch, xR, xC, ${p}) *\n                    getW(wR, wC, ${p}, d2);\n              } else {\n                dotProd +=\n                    getX(batch, ${p}, xR, xC) *\n                    getW(wR, wC, ${p}, d2);\n              }\n\n            } else if (${2===f}) {\n              vec2 wValues = vec2(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2)\n              );\n\n              if (${g}) {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (${3===f}) {\n              vec3 wValues = vec3(\n                getW(wR, wC, ${p}, d2),\n                getW(wR, wC, ${p} + 1, d2),\n                getW(wR, wC, ${p} + 2, d2)\n              );\n\n              if (${g}) {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ${p}),\n                  getX(batch, xR, xC, ${p} + 1),\n                  getX(batch, xR, xC, ${p} + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ${p}, xR, xC),\n                  getX(batch, ${p} + 1, xR, xC),\n                  getX(batch, ${p} + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ${w}\n        ${v}\n        setOutput(result);\n      }\n    `}}class Dz{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,n=e.padInfo.top,s=e.padInfo.left,r=e.strideDepth,i=e.strideHeight,a=e.strideWidth,o=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,c=e.filterDepth,h=e.filterHeight,d=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode=`\n      const ivec3 strides = ivec3(${r}, ${i}, ${a});\n      const ivec3 pads = ivec3(${t}, ${n}, ${s});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${c}; wF++) {\n          int xF = xFCorner + wF * ${o};\n\n          if (xF < 0 || xF >= ${e.inDepth}) {\n            continue;\n          }\n\n          for (int wR = 0; wR < ${h}; wR++) {\n            int xR = xRCorner + wR * ${l};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int wC = 0; wC < ${d}; wC++) {\n              int xC = xCCorner + wC * ${u};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ${p}; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (${1===f}) {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ${p}) *\n                  getW(wF, wR, wC, ${p}, d2);\n              } else if (${2===f}) {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (${3===f}) {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ${p}),\n                  getX(batch, xF, xR, xC, ${p} + 1),\n                  getX(batch, xF, xR, xC, ${p} + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ${p}, d2),\n                  getW(wF, wR, wC, ${p} + 1, d2),\n                  getW(wF, wR, wC, ${p} + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Fz{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,s=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=KM(this.outputShape.length);const i=e.padInfo.left,a=e.strideWidth,o=e.dilationWidth,l=e.filterHeight,u=e.filterWidth,c=u;let h="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let g=0;g<u;g++)h+=`\n           vec4 xTexelC${2*g};\n           int xTexelC${2*g}Ready;\n           vec4 xTexelC${2*g+1};\n           int xTexelC${2*g+1}Ready;\n           vec4 xC${g};`;h+=`\n     for (int r = 0; r < ${l}; r++) {\n      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {\n       `;for(let g=0;g<u;g++)h+=`\n           xTexelC${2*g} = vec4(0.0);\n           xTexelC${2*g}Ready = 0;\n           xTexelC${2*g+1} = vec4(0.0);\n           xTexelC${2*g+1}Ready = 0;\n           xC${g} = vec4(0.0);`;h+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let g=0;g<(c+1)/2;g++){const t=2*g;if(h+=`\n           xC = xCCorner + ${t*o};\n           `,1===a){if(t<u&&(i%2===1?(h+=`\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n               `,h+=1===o&&t>0?`\n                 xC${t} = vec4(xTexelC${t-2}.zw, xTexelC${t}.xy);\n                 `:`\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC${t} = vec4(previous.zw, xTexelC${t}.xy);\n                   } else {\n                     xC${t} = vec4(0.0, 0.0, xTexelC${t}.xy);\n                   }\n                   `):h+=`\n                 if (xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n\n                 xC${t} = xTexelC${t};\n                 `,t+1<u)){const e=i%2===0?po(o):o;o%2===0&&i%2===1||o%2!==0&&i%2!==1?(h+=`\n                   xCOffset = xC + imod(pads[1], 2) + ${e};\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                     xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC${t+1}.zw = vec2(0.0);\n                     }\n                     xTexelC${t+1}Ready = 1;\n                   }\n                   `,h+=o>1?`\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC${t+1} = vec4(previous.zw, xTexelC${t+1}.xy);\n                     } else {\n                      xC${t+1} = vec4(0.0, 0.0, xTexelC${t+1}.xy);\n                     }\n                     `:`\n                     xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.xy);\n                     `):h+=1===e?`\n                     xC${t+1} = xTexelC${t};\n                     `:`\n                     xCOffset = xC + ${e};\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                       xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC${t+1}.zw = vec2(0.0);\n                       }\n                       xTexelC${t+1}Ready = 1;\n                     }\n\n                     xC${t+1} = xTexelC${t+1};\n                     `}}else t<u&&(i%2===1?(h+=`\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${t+1}Ready == 0) {\n                   xTexelC${t+1} = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC${t+1}.zw = vec2(0.0);\n                   }\n                   xTexelC${t+1}Ready = 1;\n                 }\n\n                 xC${t} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n               `,t+1<u&&(h+=`\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC${t+1} = vec4(xTexelC${t+1}.xy, final.xy);\n                 `)):(h+=`\n                 if(xC >= 0 && xC < inDims[1] && xTexelC${t}Ready == 0) {\n                   xTexelC${t} = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC${t}.zw = vec2(0.0);\n                   }\n                   xTexelC${t}Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${t+1}Ready == 0) {\n                   xTexelC${t+1} = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC${t+1}.zw = vec2(0.);\n                   }\n                   xTexelC${t+1}Ready = 1;\n                 }\n\n                 xC${t} = vec4(\n                   xTexelC${t}.xy, xTexelC${t+1}.xy);\n               `,t+1<u&&(h+=`\n                   xC${t+1} = vec4(xTexelC${t}.zw, xTexelC${t+1}.zw);\n                 `)));t<u&&(h+=`\n             wTexel = getW(r, ${t}, d1, d2);\n             dotProd += xC${t}.xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ${e.inChannels}) {\n               dotProd += xC${t}.yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           `,t+1<u&&(h+=`\n               wTexel = getW(r, ${t+1}, d1, d2);\n               dotProd += xC${t+1}.xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ${e.inChannels}) {\n                 dotProd += xC${t+1}.yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             `))}h+="\n     }\n   ",h+="\n     }\n   ",h+="\n     }\n   ";let d="",p="";n&&(d=s?`vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ${n}\n         }`:r?`vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ${n}\n         }`:`vec4 activation(vec4 x) {\n           ${n}\n         }`,p="result = activation(result);");const f=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n       ${d}\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ${h}\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ${f}\n         ${p}\n         setOutput(result);\n       }\n     `}}class Mz{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=KM(this.outputShape.length);const{dataFormat:n}=t,s=SM(),r="channelsLast"===n,i=r?1:2,a=r?2:3,o=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let l="";for(let u=0;u<=1;u++)for(let e=0;e<=1;e++)l+=`\n          blockIndex = rc.z + ${e};\n          pos = rc.y + ${u};\n\n          ${o}\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[${i}] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[${a}] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (${r}) {\n                  innerDims = vec2(d1, ch);\n                  result[${2*u+e}] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[${2*u+e}] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        `;this.userCode=`\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ${l}\n\n        ${s.output} = result;\n      }\n    `}}function Oz(e,t){const n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&1===n&&e[0]>1?[e[0],1]:null}function Lz(e){let{x:t,filter:n,convInfo:s,backend:r,bias:i=null,preluActivationWeights:a=null,leakyreluAlpha:o=0,activation:l=null}=e;const u=t.shape,c=r.texData.get(t.dataId),h=s.inChannels,d=u[0]*u[1]*u[2],p=s.outChannels,f="channelsLast"===s.dataFormat,g=!1;let m;const b=[];if(null!=a){const e=Oz(a.shape,f);null!=e&&(a=ZL({inputs:{x:a},backend:r,attrs:{shape:e}}),b.push(a))}if(null!=i){const e=Oz(i.shape,f);null!=e&&(i=ZL({inputs:{x:i},backend:r,attrs:{shape:e}}),b.push(i))}if(!((1===d||1===p)&&h>1e3)&&c.isPacked&&f&&null!=c.texture&&u[2]%2!==0&&yo(c.shape.slice(-3),u.slice(-3))){const e=u[0]*u[1]*(u[2]+1),h={dataId:t.dataId,shape:[1,e,s.inChannels],dtype:t.dtype},d=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,go(fM(c.shape,h.shape),(()=>`packed reshape ${c.shape} to ${h.shape} isn't free`));const p=ZL({inputs:{x:n},backend:r,attrs:{shape:[1,s.inChannels,s.outChannels]}});b.push(p);const f=cP({a:h,b:p,backend:r,transposeA:false,transposeB:g,bias:i,activation:l,preluActivationWeights:a,leakyreluAlpha:o}),x=r.texData.get(f.dataId);go(x.isPacked,(()=>"batchMatMul result is expected to be packed")),c.shape=d,x.shape=s.outShape,m=RL({inputs:{x:f},backend:r}),m.shape=s.outShape,b.push(f)}else{const e=s.outHeight*s.outWidth,u=ZL({inputs:{x:t},backend:r,attrs:{shape:f?[s.batchSize,e,s.inChannels]:[s.batchSize,s.inChannels,e]}}),c=ZL({inputs:{x:n},backend:r,attrs:{shape:[1,s.inChannels,s.outChannels]}}),h=cP({a:f?u:c,b:f?c:u,transposeA:!f,transposeB:g,backend:r,bias:i,activation:l,preluActivationWeights:a,leakyreluAlpha:o});m=ZL({inputs:{x:h},backend:r,attrs:{shape:s.outShape}}),b.push(u),b.push(c),b.push(h)}for(const x of b)r.disposeIntermediateTensorInfo(x);return m}function Pz(e){let{x:t,filter:n,convInfo:s,backend:r,bias:i=null,preluActivationWeights:a=null,leakyreluAlpha:o=0,activation:l=null}=e;const{filterWidth:u,filterHeight:c,inChannels:h,outWidth:d,outHeight:p,dataFormat:f}=s,g="channelsLast"===f,m=u*c*h,b=p*d,x=[s.batchSize,m,b],y=[];if(null!=a){const e=Oz(a.shape,g);null!=e&&(a=ZL({inputs:{x:a},backend:r,attrs:{shape:e}}),y.push(a))}if(null!=i){const e=Oz(i.shape,g);null!=e&&(i=ZL({inputs:{x:i},backend:r,attrs:{shape:e}}),y.push(i))}const v=ZL({inputs:{x:n},backend:r,attrs:{shape:[1,m,xo(n.shape)/m]}});y.push(v);const w=new Mz(x,s),k=[t.shape,[s.padInfo.top,s.padInfo.left],[s.strideHeight,s.strideWidth],[s.dilationHeight,s.dilationWidth],[s.inChannels],[s.filterWidth*s.inChannels],[s.outWidth]],S=r.runWebGLProgram(w,[t],"float32",k),I=ZL({inputs:{x:S},backend:r,attrs:{shape:x}});y.push(S),y.push(I);const C=null!=i,N=null!=a,T="leakyrelu"===l,_=l?GL(l,!0):null,E=new HL(g?I.shape:v.shape,g?v.shape:I.shape,g?[s.batchSize,b,s.outChannels]:[s.batchSize,s.outChannels,b],!0,!1,C,_,N,T),$=g?[I,v]:[v,I];if(i&&$.push(i),N&&$.push(a),T){const e=r.makeTensorInfo([],"float32",Oh(o,"float32"));$.push(e),y.push(e)}const R=r.runWebGLProgram(E,$,"float32"),A=ZL({inputs:{x:R},backend:r,attrs:{shape:s.outShape}});y.push(R);for(const D of y)r.disposeIntermediateTensorInfo(D);return A}const zz={kernelName:El,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,filter:i}=t,{strides:a,pad:o,dataFormat:l,dilations:u,dimRoundingMode:c}=s,h=Qf(l),d=Wf(r.shape,i.shape,a,u,o,c,!1,h);let p;if(1!==d.filterHeight||1!==d.filterWidth||1!==d.dilationHeight||1!==d.dilationWidth||1!==d.strideHeight||1!==d.strideWidth||"SAME"!==d.padInfo.type&&"VALID"!==d.padInfo.type)if(d.strideWidth<=2&&"channelsLast"===h&&qo().getBool("WEBGL_EXP_CONV")){const e=new Fz(d),t=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];p=n.runWebGLProgram(e,[r,i],"float32",t)}else if(qo().getBool("WEBGL_CONV_IM2COL"))p=Pz({x:r,filter:i,convInfo:d,backend:n});else{const e=new Az(d);p=n.runWebGLProgram(e,[r,i],"float32")}else p=Lz({x:r,filter:i,convInfo:d,backend:n});const f=ZL({inputs:{x:p},backend:n,attrs:{shape:d.outShape}});return n.disposeIntermediateTensorInfo(p),f}};class Bz{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,s=e.padInfo.top,r=e.padInfo.left,i="channelsLast"===e.dataFormat;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${s};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${r};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              ${i?"float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);":"float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);"}\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Wz{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,s=e.strideHeight,r=e.strideWidth,i="channelsLast"===e.dataFormat,a=t-1-e.padInfo.top,o=n-1-e.padInfo.left,l=i?1:2,u=i?2:3,c=i?3:1;this.userCode=`\n      const ivec2 pads = ivec2(${a}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[${c}];\n\n        ivec2 dyCorner = ivec2(coords[${l}], coords[${u}]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${s}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${r}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n\n              if (${i}) {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Vz{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,n=e.strideHeight,s=e.strideWidth,r=e.padInfo.front,i=e.padInfo.top,a=e.padInfo.left;this.userCode=`\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yF = 0; yF < ${e.outDepth}; yF++) {\n            int xF = wF + yF * ${t} - ${r};\n\n            if (xF < 0 || xF >= ${e.inDepth}) {\n              continue;\n            }\n\n            for (int yR = 0; yR < ${e.outHeight}; yR++) {\n              int xR = wR + yR * ${n} - ${i};\n\n              if (xR < 0 || xR >= ${e.inHeight}) {\n                continue;\n              }\n\n              for (int yC = 0; yC < ${e.outWidth}; yC++) {\n                int xC = wC + yC * ${s} - ${a};\n\n                if (xC < 0 || xC >= ${e.inWidth}) {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class Uz{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,s=e.filterWidth,r=e.strideDepth,i=e.strideHeight,a=e.strideWidth,o=t-1-e.padInfo.front,l=n-1-e.padInfo.top,u=s-1-e.padInfo.left;this.userCode=`\n      const ivec3 pads = ivec3(${o}, ${l}, ${u});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ${t}; wF++) {\n          float dyF = float(dyFCorner + wF) / ${r}.0;\n\n          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ${t} - 1 - wF;\n\n          for (int wR = 0; wR < ${n}; wR++) {\n            float dyR = float(dyRCorner + wR) / ${i}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ${n} - 1 - wR;\n\n            for (int wC = 0; wC < ${s}; wC++) {\n              float dyC = float(dyCCorner + wC) / ${a}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ${s} - 1 - wC;\n\n              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const Gz={kernelName:$l,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,dy:i}=t,{strides:a,pad:o,dataFormat:l,dimRoundingMode:u,filterShape:c}=s,h=Qf(l),d=Wf(r.shape,c,a,1,o,u,!1,h),p=new Bz(d);return n.runWebGLProgram(p,[r,i],"float32")}};class Hz{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=KM(this.outputShape.length);const t=e.filterHeight,n=e.filterWidth,s=t-1-e.padInfo.top,r=n-1-e.padInfo.left;this.userCode=`\n      const ivec2 pads = ivec2(${s}, ${r});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            int wCPerm = ${n} - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    `}}const jz={kernelName:Rl,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,filter:i}=t,{inputShape:a,strides:o,pad:l,dataFormat:u,dimRoundingMode:c}=s,h=Qf(u),d=Wf(a,i.shape,o,1,l,c,!1,h);if(qo().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&"channelsLast"===h){const e=[[d.strideHeight,d.strideWidth]],t=new Hz(d);return n.runWebGLProgram(t,[r,i],"float32",e)}{const e=new Wz(d);return n.runWebGLProgram(e,[r,i],"float32")}}};const Kz={kernelName:Al,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,filter:i}=t,{strides:a,pad:o,dilations:l}=s,u=Vf(r.shape,i.shape,a,l,o),c=new Dz(u);return n.runWebGLProgram(c,[r,i],"float32")}};const Xz={kernelName:Dl,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,dy:i}=t,{strides:a,pad:o,filterShape:l}=s,u=Vf(r.shape,l,a,1,o),c=new Vz(u);return n.runWebGLProgram(c,[r,i],"float32")}};const qz={kernelName:Fl,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,filter:i}=t,{pad:a,strides:o,inputShape:l}=s,u=Vf(l,i.shape,o,1,a),c=new Uz(u);return n.runWebGLProgram(c,[r,i],"float32")}},Yz=VL({opSnippet:WL+"\n  return cos(x);\n",packedOpSnippet:`\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ${EL}\n  return result;\n`}),Qz={kernelName:Ml,backendName:"webgl",kernelFunc:Yz},Zz=VL({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),Jz={kernelName:Ol,backendName:"webgl",kernelFunc:Zz};class eB{constructor(e,t,n,s,r){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[i,a,o,l]=e,[u]=t,[c,h]=n;this.outputShape=[u,c,h,l];const d="bilinear"===s?1:0,[p,f]=[a-1+".0",o-1+".0"],[g,m,b]=c>1?[""+(a-1)/(c-1),"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${p}`],[x,y,v]=h>1?[""+(o-1)/(h-1),"(x2-x1) * width_ratio",`x1*${f} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${f}`];this.userCode=`\n      const float height_ratio = float(${g});\n      const float width_ratio = float(${x});\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ${i}) {\n          return;\n        }\n\n        float height_scale = ${m};\n        float width_scale = ${y};\n\n        float in_y = ${b};\n        if( in_y < 0.0 || in_y > ${p} ) {\n          setOutput(float(${r}));\n          return;\n        }\n        float in_x = ${v};\n        if( in_x < 0.0 || in_x > ${f} ) {\n          setOutput(float(${r}));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(${d} == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    `}}const tB={kernelName:zl,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:s}=e,{image:r,boxes:i,boxInd:a}=t,{cropSize:o,method:l,extrapolationValue:u}=s,c=new eB(r.shape,i.shape,o,l,u);return n.runWebGLProgram(c,[r,i,a],"float32")}};var nB;!function(e){e.Prod="*",e.Sum="+"}(nB||(nB={}));class sB{constructor(e,t,n,s){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const r=this.outputShape.length,i=this.op===nB.Prod?"1.0":"0.0",a=n?i:`getX(${rB(r,"coords",this.op)})`,o=this.outputShape[this.outputShape.length-1];let l="",u="";n?(l=s?"end != "+(o-1):"end != 0",u=s?"end + 1":"end - 1"):(l=s?`end + pow2 < ${o}`:"end >= pow2",u=s?"end + pow2":"end - pow2"),this.userCode=`\n      void main() {\n        ${BM(r)} coords = getOutputCoords();\n        int end = ${iB(r,"coords",this.op)};\n        float val = ${a};\n        int pow2 = int(pow(2.0, index));\n        if (${l}) {\n          int idx = ${u};\n          ${iB(r,"coords",this.op)} = idx;\n          val ${this.op}= getX(${rB(r,"coords",this.op)});\n        }\n        setOutput(val);\n      }\n    `}}function rB(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.x, ${t}.y`;if(3===e)return`${t}.x, ${t}.y, ${t}.z`;if(4===e)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function iB(e,t,n){if(1===e)return`${t}`;if(2===e)return`${t}.y`;if(3===e)return`${t}.z`;if(4===e)return`${t}.w`;throw new Error(`Cumulative ${n} for rank ${e} is not yet supported`)}function aB(e,t,n,s,r,i){const a=t.shape.length,o=Gg([s],a);let l=t;null!=o&&(l=lP({inputs:{x:t},backend:n,attrs:{perm:o}}));const u=jg(1,a)[0];if(u!==a-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${t.shape.length-1} but got axis=${s}`);const c=l.shape[u];let h=RL({inputs:{x:l},backend:n});for(let d=0;d<=Math.ceil(Math.log2(c))-1;d++){const t=new sB(e,l.shape,!1,i),s=[[d]],r=h;h=n.runWebGLProgram(t,[h],h.dtype,s),n.disposeIntermediateTensorInfo(r)}if(r){const t=new sB(e,l.shape,r,i),s=h;h=n.runWebGLProgram(t,[h],h.dtype),n.disposeIntermediateTensorInfo(s)}if(null!=o){const e=lP({inputs:{x:h},backend:n,attrs:{perm:Hg(o)}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(l),e}return h}const oB={kernelName:Ll,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:i,exclusive:a,reverse:o}=s;return aB(nB.Prod,r,n,i,a,o)}};const lB={kernelName:Pl,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:i,exclusive:a,reverse:o}=s;return aB(nB.Sum,r,n,i,a,o)}};const uB={kernelName:Bl,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,weights:i}=t,{size:a,binaryOutput:o}=s;if(1===r.shape.length){const e=n.readSync(r.dataId),t=n.readSync(i.dataId),s=pO(e,t,i.dtype,i.shape,a);return n.makeTensorInfo([a],i.dtype,s)}if(2===r.shape.length){const e=n.bufferSync(r),t=n.bufferSync(i),s=fO(e,t,a,o);return n.makeTensorInfo(s.shape,i.dtype,s.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}};class cB{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode=`\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ${this.getHeightCoordString()};\n      int w = ${this.getWidthCoordString()};\n      int d = ${this.getDepthCoordString()};\n\n      int in_h = h / ${t};\n      int offset_h = imod(h, ${t});\n      int in_w = w / ${t};\n      int offset_w = imod(w, ${t});\n      int offset_d = (offset_h * ${t} + offset_w) *\n        ${this.getOutputDepthSize()};\n      int in_d = d + offset_d;\n\n      float result = ${this.getInputSamplingString()};\n      setOutput(result);\n    }\n  `}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const hB={kernelName:Wl,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{blockSize:i,dataFormat:a}=s,o=r.shape[0],l=("NHWC"===a?r.shape[1]:r.shape[2])*i,u=("NHWC"===a?r.shape[2]:r.shape[3])*i,c=("NHWC"===a?r.shape[3]:r.shape[1])/(i*i),h=new cB("NHWC"===a?[o,l,u,c]:[o,c,l,u],i,a);return n.runWebGLProgram(h,[r],r.dtype)}};class dB{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,s=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=KM(this.outputShape.length);const i=e.filterHeight,a=e.filterWidth,o=e.outChannels/e.inChannels;let l="",u="";n&&(l=s?`float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:r?`float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`\n          float activation(float x) {\n            ${n}\n          }\n        `,u="result = activation(result);");const c=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${l}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${o};\n        int q = d2 - d1 * ${o};\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ${i}; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ${a}; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ${c}\n        ${u}\n        setOutput(result);\n      }\n    `}}class pB{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,s=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=KM(this.outputShape.length);const i=e.outChannels/e.inChannels,a=e.padInfo.left,o=e.strideWidth,l=e.dilationWidth,u=e.filterHeight,c=e.filterWidth,h=c;let d="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let m=0;m<c;m++)d+=`\n          vec4 xTexelC${2*m};\n          int xTexelC${2*m}Ready;\n          vec4 xTexelC${2*m+1};\n          int xTexelC${2*m+1}Ready;\n          vec4 xC${m};`;d+=`\n    for (int r = 0; r < ${u}; r++) {\n      `;for(let m=0;m<c;m++)d+=`\n          xTexelC${2*m} = vec4(0.0);\n          xTexelC${2*m}Ready = 0;\n          xTexelC${2*m+1} = vec4(0.0);\n          xTexelC${2*m+1}Ready = 0;\n          xC${m} = vec4(0.0);`;d+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let m=0;m<(h+1)/2;m++){const e=2*m;if(d+=`\n          xC = xCCorner + ${e*l};\n          `,1===o){if(e<c&&(a%2===1?(d+=`\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n              `,d+=1===l&&e>0?`\n                xC${e} = vec4(xTexelC${e-2}.zw, xTexelC${e}.xy);\n                `:`\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC${e} = vec4(previous.zw, xTexelC${e}.xy);\n                  } else {\n                    xC${e} = vec4(0.0, 0.0, xTexelC${e}.xy);\n                  }\n                  `):d+=`\n                if (xC >= 0 && xC < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                xC${e} = xTexelC${e};\n                `,e+1<c)){const t=a%2===0?po(l):l;l%2===0&&a%2===1||l%2!==0&&a%2!==1?(d+=`\n                  xCOffset = xC + imod(pads[1], 2) + ${t};\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                    xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC${e+1}.zw = vec2(0.0);\n                    }\n                    xTexelC${e+1}Ready = 1;\n                  }\n                  `,d+=l>1?`\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC${e+1} = vec4(previous.zw, xTexelC${e+1}.xy);\n                    } else {\n                     xC${e+1} = vec4(0.0, 0.0, xTexelC${e+1}.xy);\n                    }\n                    `:`\n                    xC${e+1} = vec4(xTexelC${e}.zw, xTexelC${e+1}.xy);\n                    `):d+=1===t?`\n                    xC${e+1} = xTexelC${e};\n                    `:`\n                    xCOffset = xC + ${t};\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                      xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC${e+1}.zw = vec2(0.0);\n                      }\n                      xTexelC${e+1}Ready = 1;\n                    }\n\n                    xC${e+1} = xTexelC${e+1};\n                    `}}else e<c&&(a%2===1?(d+=`\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${e+1}Ready == 0) {\n                  xTexelC${e+1} = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC${e+1}.zw = vec2(0.0);\n                  }\n                  xTexelC${e+1}Ready = 1;\n                }\n\n                xC${e} = vec4(xTexelC${e}.zw, xTexelC${e+1}.zw);\n              `,e+1<c&&(d+=`\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC${e+1} = vec4(xTexelC${e+1}.xy, final.xy);\n                `)):(d+=`\n                if(xC >= 0 && xC < inDims[1] && xTexelC${e}Ready == 0) {\n                  xTexelC${e} = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC${e}.zw = vec2(0.0);\n                  }\n                  xTexelC${e}Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${e+1}Ready == 0) {\n                  xTexelC${e+1} = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC${e+1}.zw = vec2(0.);\n                  }\n                  xTexelC${e+1}Ready = 1;\n                }\n\n                xC${e} = vec4(\n                  xTexelC${e}.xy, xTexelC${e+1}.xy);\n              `,e+1<c&&(d+=`\n                  xC${e+1} = vec4(xTexelC${e}.zw, xTexelC${e+1}.zw);\n                `)));e<c&&(d+=`\n            wTexel = getW(r, ${e}, d1, q);\n            dotProd += xC${e} * vec4(wTexel.xz, wTexel.xz);\n          `,e+1<c&&(d+=`\n              wTexel = getW(r, ${e+1}, d1, q);\n              dotProd += xC${e+1} * vec4(wTexel.xz, wTexel.xz);\n            `))}d+="\n    }\n  ",d+="\n      }\n    ";let p="",f="";n&&(p=s?`vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ${n}\n        }`:r?`vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ${n}\n        }`:`vec4 activation(vec4 x) {\n          ${n}\n        }`,f="result = activation(result);");const g=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`\n      ${p}\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ${i};\n        int q = d2 - d1 * ${i};\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ${d}\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ${g}\n        ${f}\n        setOutput(result);\n      }\n    `}}const fB={kernelName:Vl,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,filter:i}=t,{strides:a,pad:o,dilations:l,dimRoundingMode:u}=s;let c=l;null==c&&(c=[1,1]),go(qf(a,c),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${c}'`));const h=Wf(r.shape,i.shape,a,c,o,u,!0);let d;d=qo().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels===1?new pB(h):new dB(h);const p=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];return n.runWebGLProgram(d,[r,i],"float32",p)}};class gB{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,s=e.padInfo.top,r=e.padInfo.left,i=e.outChannels/e.inChannels;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ${i} + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ${e.batchSize}; b++) {\n          for (int yR = 0; yR < ${e.outHeight}; yR++) {\n            int xR = wR + yR * ${t} - ${s};\n\n            if (xR < 0 || xR >= ${e.inHeight}) {\n              continue;\n            }\n\n            for (int yC = 0; yC < ${e.outWidth}; yC++) {\n              int xC = wC + yC * ${n} - ${r};\n\n              if (xC < 0 || xC >= ${e.inWidth}) {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class mB{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,s=e.strideHeight,r=e.strideWidth,i=t-1-e.padInfo.top,a=n-1-e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`\n      const ivec2 pads = ivec2(${i}, ${a});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ${t}; wR++) {\n          float dyR = float(dyRCorner + wR) / ${s}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ${t} - 1 - wR;\n\n          for (int wC = 0; wC < ${n}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${r}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ${n} - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ${o}; dm++) {\n              int d2 = d1 * ${o} + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const bB={kernelName:Ul,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,dy:i}=t,{strides:a,dilations:o,pad:l,dimRoundingMode:u,filterShape:c}=s,h=Wf(r.shape,c,a,o,l,u,!0),d=new gB(h);return n.runWebGLProgram(d,[r,i],"float32")}};const xB={kernelName:Gl,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,filter:i}=t,{strides:a,dilations:o,pad:l,dimRoundingMode:u,inputShape:c}=s,h=Wf(c,i.shape,a,o,l,u,!0),d=new mB(h);return n.runWebGLProgram(d,[r,i],"float32")}};class yB{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const vB={kernelName:Hl,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:s}=t,r=[...s.shape,...s.shape],i=xo(s.shape),a=ZL({inputs:{x:s},backend:n,attrs:{shape:[i]}}),o=new yB(i),l=n.runWebGLProgram(o,[a],a.dtype),u=ZL({inputs:{x:l},backend:n,attrs:{shape:r}});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(l),u}};class wB{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:n,padInfo:s,strideHeight:r,strideWidth:i,filterHeight:a,filterWidth:o,dilationHeight:l,dilationWidth:u}=e,{top:c,left:h}=s;this.userCode=`\n      const ivec2 strides = ivec2(${r}, ${i});\n      const ivec2 pads = ivec2(${c}, ${h});\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ${a}; h++) {\n          int hIn = hBeg + h * ${l};\n\n          if (hIn >= 0 && hIn < ${t}) {\n            for (int w = 0; w < ${o}; w++) {\n              int wIn = wBeg + w * ${u};\n\n              if (wIn >= 0 && wIn < ${n}) {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    `}}const kB={kernelName:jl,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,filter:i}=t,{strides:a,pad:o,dilations:l}=s,u=Pf(r.shape,i.shape,a,o,"NHWC",l);let c;const h=new wB(u);c=n.runWebGLProgram(h,[r,i],"float32");const d=ZL({inputs:{x:c},backend:n,attrs:{shape:u.outShape}});return n.disposeIntermediateTensorInfo(c),d}};const SB={kernelName:Ql,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{equation:r}=s,i=t,{allDims:a,summedDims:o,idDims:l}=$x(r,i.length);Ax(a.length,l,i);const{path:u,steps:c}=Dx(o,l),h=c.length;let d=null,p=a.length;const f=[];for(let g=0;g<h;++g){for(const e of c[g]){const{permutationIndices:t,expandDims:s}=Rx(p,l[e]);let r;Fx(t)?r=i[e]:(r=lP({inputs:{x:i[e]},backend:n,attrs:{perm:t}}),f.push(r));const a=r.shape.slice();for(let e=0;e<s.length;++e)a.splice(s[e],0,1);yo(r.shape,a)||(r=ZL({inputs:{x:r},backend:n,attrs:{shape:a}}),f.push(r)),null===d?d=r:(d=YL({inputs:{a:r,b:d},backend:n}),f.push(d))}g<h-1&&(u[g]>=0&&(d=aP({inputs:{x:d},backend:n,attrs:{axis:u[g]-(a.length-p),keepDims:!1}}),f.push(d)),p--)}for(const g of f)g!==d&&n.disposeIntermediateTensorInfo(g);return d}},IB=VL({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),CB={kernelName:Zl,backendName:"webgl",kernelFunc:IB},NB={kernelName:Jl,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n}=e,{dy:s,y:r}=t,i=qo().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new $L("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",s.shape,r.shape):new _L("return (b >= 0.0) ? a : a * (b + 1.0);",s.shape,r.shape);return n.runWebGLProgram(i,[s,r],s.dtype)}},TB=UL({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:yO}),_B={kernelName:tu,backendName:"webgl",kernelFunc:TB},EB=VL({opSnippet:`\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = ${dx};\n  float a1 = ${px};\n  float a2 = ${fx};\n  float a3 = ${gx};\n  float a4 = ${mx};\n  float a5 = ${bx};\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n`}),$B={kernelName:eu,backendName:"webgl",kernelFunc:EB},RB=VL({opSnippet:WL+"\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:vO,dtype:"float32"}),AB={kernelName:nu,backendName:"webgl",kernelFunc:RB};function DB(e){const{inputs:t,attrs:n,backend:s}=e,{dim:r}=n,{input:i}=t,a=i.shape.length,o=i.shape.slice();let l=r;return r<0&&(go(-(a+1)<=r,(()=>`Axis must be in the interval [${-(a+1)}, ${a}]`)),l=a+r+1),o.splice(l,0,1),ZL({inputs:{x:i},backend:s,attrs:{shape:o}})}const FB={kernelName:su,backendName:"webgl",kernelFunc:DB},MB="return exp(x) - 1.0;",OB=VL({opSnippet:MB,packedOpSnippet:MB,cpuKernelImpl:wO}),LB={kernelName:ru,backendName:"webgl",kernelFunc:OB};class PB{constructor(e,t,n){this.variableNames=["real","imag"];const s=t[1];this.outputShape=t;const r=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,i=n?`${s}.0`:"1.0";let a;if("real"===e)a="return real * expR - imag * expI;";else{if("imag"!==e)throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);a="return real * expI + imag * expR;"}this.userCode=`\n      const float exponentMultiplier = ${r};\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ${a}\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(${s});\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ${s}; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ${i};\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    `}}function zB(e,t,n){const s=n.texData.get(e.dataId),r=xo(e.shape),i=e.shape[e.shape.length-1],a=ZL({inputs:{x:e},backend:n,attrs:{shape:[r/i,i]}}),o=a.shape,l=new PB("real",o,t),u=new PB("imag",o,t),c=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:o},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:o}],h=n.runWebGLProgram(l,c,"float32"),d=n.runWebGLProgram(u,c,"float32"),p=DL({inputs:{real:h,imag:d},backend:n});n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d);const f=ZL({inputs:{x:p},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(p),f}const BB={kernelName:iu,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:s}=t;return zB(s,!1,n)}};class WB{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function VB(e){const{backend:t,attrs:n}=e,{shape:s,value:r}=n;let{dtype:i}=n;if(i=i||Do(r),"string"===i){const e=_o(i,xo(s));return e.fill(r),t.makeTensorInfo(s,i,e)}{const e=new WB(s,r),n=[[r]];return t.runWebGLProgram(e,[],i,n)}}const UB={kernelName:au,backendName:"webgl",kernelFunc:VB};class GB{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ${t} - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ${t}) {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const HB={kernelName:ou,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n}=e;const{image:s}=t,r=n,i=new GB(s.shape);return r.runWebGLProgram(i,[s],s.dtype)}},jB="return floor(x);",KB=VL({opSnippet:jB,packedOpSnippet:jB,cpuKernelImpl:kO}),XB={kernelName:lu,backendName:"webgl",kernelFunc:KB},qB=UL({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),YB={kernelName:uu,backendName:"webgl",kernelFunc:qB};class QB{constructor(e){this.variableNames=["A"];const t=SM(),[n,s]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}.0, ${n}.0);\n\n        vec4 values = ${t.texture2D}(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    `}}class ZB{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=SM(),[n,s]=e;this.outputShape=e,this.userCode=`\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(${s}.0, ${n}.0);\n            vec4 values = ${t.texture2D}(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ${t.output} = result;\n      }\n    `}}const JB={kernelName:ah,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e;let{pixels:r}=t;const{numChannels:i}=s,a="undefined"!==typeof HTMLVideoElement&&r instanceof HTMLVideoElement,o="undefined"!==typeof HTMLImageElement&&r instanceof HTMLImageElement,[l,u]=a?[r.videoWidth,r.videoHeight]:[r.width,r.height],c=[u,l],h=[u,l,i];if(o||a){const e=qo().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");null!=eW&&e===tW||(tW=e,eW=document.createElement("canvas").getContext("2d",{willReadFrequently:tW})),eW.canvas.width=l,eW.canvas.height=u,eW.drawImage(r,0,0,l,u),r=eW.canvas}const d=n.makeTensorInfo(c,"int32");n.texData.get(d.dataId).usage=HF.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(d.dataId),r);const p=qo().getBool("WEBGL_PACK")?new ZB(h):new QB(h),f=n.runWebGLProgram(p,[d],"int32");return n.disposeData(d.dataId),f}};let eW,tW=qo().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");const nW={kernelName:uh,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,filter:i,bias:a,preluActivationWeights:o}=t,{strides:l,pad:u,dataFormat:c,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=s,g=Qf(c),m=Wf(r.shape,i.shape,l,h,u,d,!1,g);let b;const x=[],y=null!=a,v=null!=o,w="leakyrelu"===p,k=()=>{const e=[r,i],t=(e,t)=>{if("NCHW"===t&&1===e.shape.length&&1!==e.shape[0]){const t=ZL({inputs:{x:e},backend:n,attrs:{shape:[e.shape[0],1,1]}});return x.push(t),t}return e};if(y&&e.push(t(a,c)),v&&e.push(t(o,c)),w){const t=n.makeTensorInfo([],"float32",Oh(f,"float32"));e.push(t),x.push(t)}return e};if(1!==m.filterHeight||1!==m.filterWidth||1!==m.dilationHeight||1!==m.dilationWidth||1!==m.strideHeight||1!==m.strideWidth||"SAME"!==m.padInfo.type&&"VALID"!==m.padInfo.type)if(m.strideWidth<=2&&"channelsLast"===g&&qo().getBool("WEBGL_EXP_CONV")){const e=p?GL(p,!0):null,t=new Fz(m,y,e,v,w),s=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]],r=k();b=n.runWebGLProgram(t,r,"float32",s)}else if(qo().getBool("WEBGL_CONV_IM2COL"))b=Pz({x:r,filter:i,convInfo:m,backend:n,bias:a,activation:p,preluActivationWeights:o,leakyreluAlpha:f});else{const e=p?GL(p,!1):null,t=new Az(m,y,e,v,w),s=k();b=n.runWebGLProgram(t,s,"float32")}else b=Lz({x:r,filter:i,convInfo:m,backend:n,bias:a,activation:p,preluActivationWeights:o,leakyreluAlpha:f});const S=ZL({inputs:{x:b},backend:n,attrs:{shape:m.outShape}});return x.push(b),x.forEach((e=>n.disposeIntermediateTensorInfo(e))),S}};const sW={kernelName:ch,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,filter:i,bias:a,preluActivationWeights:o}=t,{strides:l,pad:u,dilations:c,dimRoundingMode:h,activation:d,leakyreluAlpha:p}=s,f=[];let g=c;null==g&&(g=[1,1]),go(qf(l,g),(()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${g}'`));const m=Wf(r.shape,i.shape,l,g,u,h,!0),b=qo().getBool("WEBGL_PACK_DEPTHWISECONV")&&m.strideWidth<=2&&m.outChannels/m.inChannels===1,x=d?GL(d,b):null,y=[r,i],v=null!=a,w=null!=o,k="leakyrelu"===d;if(v&&y.push(a),w&&y.push(o),k){const e=n.makeTensorInfo([],"float32",Oh(p,"float32"));y.push(e),f.push(e)}let S;S=b?new pB(m,v,x,w,k):new dB(m,v,x,w,k);const I=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]],C=n.runWebGLProgram(S,y,"float32",I);return f.forEach((e=>n.disposeIntermediateTensorInfo(e))),C}};class rW{constructor(e,t,n,s){this.sliceDim=e,this.strides=t,this.paramsShape=s,this.variableNames=["x","indices"],this.outputShape=n;const r=BM(n.length);let i="\n    int index;";for(let a=0;a<this.sliceDim;a++)i+=`\n          index = round(getIndices(coords[0], ${a}));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[a]};\n          flattenIndex += index * ${this.strides[a]};`;this.userCode=`\n         void main() {\n          ${r} coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ${i}\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      `}}const iW={kernelName:du,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:s,indices:r}=t,i=r.shape,a=i[i.length-1],o=xo(s.shape),[l,u,c,h]=ax(s,r),d=ZL({inputs:{x:r},backend:n,attrs:{shape:[u,a]}}),p=ZL({inputs:{x:s},backend:n,attrs:{shape:[xo(s.shape)/c,c]}});if(n.shouldExecuteOnCPU([s,r])||"string"===s.dtype){const e=n.readSync(r.dataId),t=n.bufferSync(s),i=SO(e,t,s.dtype,u,a,c,h,s.shape,o);return n.makeTensorInfo(l,s.dtype,i.values)}const f=new rW(a,h,[u,c],s.shape),g=n.runWebGLProgram(f,[p,d],p.dtype),m=ZL({inputs:{x:g},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(g),m}};class aW{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const n=BM(this.rank),s=function(e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let s=0;s<e.length;s++)2===s?n.push("index"):n.push(`${t[s]}`);return n.join()}(e);this.userCode=`\n      void main() {\n        ${n} resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;\n        setOutput(inBounds * getA(${s}));\n      }\n    `}}function oW(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,indices:i}=t,{axis:a,batchDims:o}=s,l=Co(a,r.shape)[0];if(qo().get("DEBUG")){const e=n.readSync(i.dataId),t=r.shape[l];for(let n=0;n<e.length;++n){const s=e[n];go(s<=t-1&&s>=0,(()=>`GatherV2: the index value ${s} is not in [0, ${t-1}]`))}}const u=Qx(r,i,l,o),c=xo(i.shape),h=[],d=ZL({inputs:{x:r},backend:n,attrs:{shape:[u.batchSize,u.outerSize,u.dimSize,u.sliceSize]}}),p=ZL({inputs:{x:i},backend:n,attrs:{shape:[u.batchSize,c/u.batchSize]}});h.push(d),h.push(p);const f=[u.batchSize,u.outerSize,c/u.batchSize,u.sliceSize];if(n.shouldExecuteOnCPU([r,i])||"string"===r.dtype){const e=n.bufferSync(p),t=n.bufferSync(d),s=IO(t,e,f);return h.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(u.outputShape,s.dtype,s.values)}const g=new aW(d.shape,f),m=n.runWebGLProgram(g,[d,p],d.dtype);h.push(m);const b=ZL({inputs:{x:m},backend:n,attrs:{shape:u.outputShape}});return h.forEach((e=>n.disposeIntermediateTensorInfo(e))),b}const lW={kernelName:hu,backendName:"webgl",kernelFunc:oW},uW=UL({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:CO,dtype:"bool"}),cW={kernelName:pu,backendName:"webgl",kernelFunc:uW},hW=UL({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:NO}),dW={kernelName:fu,backendName:"webgl",kernelFunc:hW};const pW={kernelName:mu,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:s}=t;return zB(s,!0,n)}},fW=VL({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),gW={kernelName:xu,backendName:"webgl",kernelFunc:fW},mW=VL({opSnippet:"return float(isinf(x));",dtype:"bool"}),bW={kernelName:yu,backendName:"webgl",kernelFunc:mW},xW=VL({opSnippet:"return float(isnan(x));",dtype:"bool"}),yW={kernelName:vu,backendName:"webgl",kernelFunc:xW},vW=UL({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:TO,dtype:"bool"}),wW={kernelName:ku,backendName:"webgl",kernelFunc:vW},kW=UL({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:_O,dtype:"bool"}),SW={kernelName:Su,backendName:"webgl",kernelFunc:kW};const IW={kernelName:Iu,backendName:"webgl",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:s,stop:r,num:i}=n,a=EO(s,r,i);return t.makeTensorInfo([a.length],"float32",a)}},CW=VL({opSnippet:WL+"\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:$O}),NW={kernelName:Cu,backendName:"webgl",kernelFunc:CW},TW=VL({opSnippet:WL+"\n  return log(1.0 + x);\n"}),_W={kernelName:Nu,backendName:"webgl",kernelFunc:TW},EW=UL({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),$W={kernelName:Tu,backendName:"webgl",kernelFunc:EW},RW=VL({opSnippet:"return float(!(x >= 1.0));"}),AW={kernelName:_u,backendName:"webgl",kernelFunc:RW},DW=UL({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),FW={kernelName:Eu,backendName:"webgl",kernelFunc:DW};class MW{constructor(e,t,n,s,r){this.variableNames=["x"],this.outputShape=[];const i=t,a=e[3]-1;let o;this.outputShape=e;const l=`float(${n}) + float(${s}) * sum`;o=.5===r?`inversesqrt(${l})`:1===r?`1.0/(${l})`:`exp(log(${l}) * float(-${r}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -${i}; j <= ${i}; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ${a}) {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ${o};\n        setOutput(val);\n      }\n    `}}class OW{constructor(e,t,n,s,r){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const i=t,a=e[3]-1;let o;this.outputShape=e;const l=`float(${n}) + float(${s}) * sum`;o=.5===r?`inversesqrt(${l})`:1===r?`1.0/(${l})`:`exp(log(${l}) * float(-${r}));`,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ${this.outputShape[3]};\n        bool hasNextRow = c < ${this.outputShape[2]};\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ${i};\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ${i}; j <= ${i}; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ${o};\n        setOutput(result);\n      }\n    `}}const LW={kernelName:$u,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{depthRadius:i,bias:a,alpha:o,beta:l}=s,u=qo().getBool("WEBGL_PACK_NORMALIZATION")?new OW(r.shape,i,a,o,l):new MW(r.shape,i,a,o,l);return n.runWebGLProgram(u,[r],r.dtype)}};class PW{constructor(e,t,n,s,r){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=s,this.beta=r,this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ${this.depth}; ++d) {\n          int depthBegin = int(max(0.0, float(d - ${t})));\n          int depthEnd = int(min(float(${this.depth}),\n              float(d + ${t} + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ${this.depth};\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(${s}) * norm + float(${n});\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(${s})\n                * float(${r})\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ${r});\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    `}}const zW={kernelName:Ru,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:s}=e,{x:r,y:i,dy:a}=t,{depthRadius:o,bias:l,alpha:u,beta:c}=s,h=new PW(r.shape,o,l,u,c);return n.runWebGLProgram(h,[r,i,a],r.dtype)}};function BW(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{reductionIndices:i,keepDims:a}=s,o=r.shape.length,l=Co(i,r.shape);let u=l;const c=Gg(u,o),h=null!=c,d=n.shouldExecuteOnCPU([r]);let p=r;if(h){if(d){const e=n.texData.get(p.dataId).values,t=new Array(o);for(let n=0;n<t.length;n++)t[n]=r.shape[c[n]];const s=iL(e,r.shape,r.dtype,c,t);p=n.makeTensorInfo(t,r.dtype);n.texData.get(p.dataId).values=s}else p=iP(r,c,n);u=jg(u.length,o)}Ug("max",u,o);const[f,g]=Wg(p.shape,u);let m,b=f;if(a&&(b=Vg(f,l)),d){const e=n.texData.get(p.dataId).values,t=RO(e,xo(g),b,r.dtype);m=n.makeTensorInfo(b,r.dtype);n.texData.get(m.dataId).values=t}else m=function(e,t,n,s){const r=xo(t),i=ZL({inputs:{x:e},attrs:{shape:[xo(e.shape)/r,r]},backend:s}),a=nP(i,e.dtype,"max",s),o=ZL({inputs:{x:a},attrs:{shape:n},backend:s});return s.disposeIntermediateTensorInfo(i),s.disposeIntermediateTensorInfo(a),o}(p,g,b,n);return h&&n.disposeIntermediateTensorInfo(p),m}const WW={kernelName:Au,backendName:"webgl",kernelFunc:BW},VW=UL({opSnippet:TL+"\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+EL+"\n  return result;\n",cpuKernelImpl:AO}),UW={kernelName:Du,backendName:"webgl",kernelFunc:VW};const GW={kernelName:Fu,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t;wM(r,"maxPool");const{filterSize:i,strides:a,pad:o,dimRoundingMode:l}=s;go(qf(a,1),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '1'`));const u=zf(r.shape,i,a,1,o,l);if(1===u.filterWidth&&1===u.filterHeight&&yo(u.inShape,u.outShape))return RL({inputs:{x:r},backend:n});const c=new UP(u,"max",!1);return n.runWebGLProgram(c,[r],r.dtype)}};const HW={kernelName:Ou,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{filterSize:i,strides:a,pad:o,dataFormat:l,dimRoundingMode:u}=s,c=Bf(r.shape,i,a,[1,1,1],o,u,l),h=new GP(c,"max",!1);return n.runWebGLProgram(h,[r],r.dtype)}};class jW{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,n=e.strideWidth,s=e.dilationHeight,r=e.effectiveFilterHeight,i=e.effectiveFilterWidth,a=r-1-e.padInfo.top,o=i-1-e.padInfo.left,l=r*i-1;this.userCode=`\n      const ivec2 pads = ivec2(${a}, ${o});\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ${r};\n          wR += ${s}) {\n          float dyR = float(dyRCorner + wR) / ${t}.0;\n\n          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ${i}; wC++) {\n            float dyC = float(dyCCorner + wC) / ${n}.0;\n\n            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ${i} + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}class KW{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,n=e.strideHeight,s=e.strideWidth,r=e.dilationDepth,i=e.dilationHeight,a=e.dilationWidth,o=e.effectiveFilterDepth,l=e.effectiveFilterHeight,u=e.effectiveFilterWidth,c=o-1-e.padInfo.front,h=l-1-e.padInfo.top,d=u-1-e.padInfo.left,p=o*l*u-1;this.userCode=`\n      const ivec3 pads = ivec3(${c}, ${h}, ${d});\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ${o};\n           wD += ${r}) {\n          float dyD = float(dyDCorner + wD) / ${t}.0;\n\n          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ${l};\n              wR += ${i}) {\n            float dyR = float(dyRCorner + wR) / ${n}.0;\n\n            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ${u};\n                wC += ${a}) {\n              float dyC = float(dyCCorner + wC) / ${s}.0;\n\n              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ${p} -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ${l} * ${u} +\n                  wR * ${u} + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    `}}const XW={kernelName:Lu,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,input:i}=t,a=i,{filterSize:o,strides:l,pad:u,dimRoundingMode:c}=s,h=Bf(a.shape,o,l,[1,1,1],u,c),d=new GP(h,"max",!0),p=n.runWebGLProgram(d,[a],a.dtype),f=new KW(h),g=n.runWebGLProgram(f,[r,p],a.dtype);return n.disposeIntermediateTensorInfo(p),g}};const qW={kernelName:Mu,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{dy:r,input:i,output:a}=t,o=i;wM([i,a],"maxPoolGrad");const{filterSize:l,strides:u,pad:c,dimRoundingMode:h}=s,d=zf(o.shape,l,u,1,c,h),p=new UP(d,"max",!0),f=n.runWebGLProgram(p,[o],o.dtype),g=new jW(d),m=n.runWebGLProgram(g,[r,f],o.dtype);return n.disposeIntermediateTensorInfo(f),m}};const YW={kernelName:Pu,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:s}=e;const{x:r}=t,{filterSize:i,strides:a,pad:o,includeBatchInIndex:l}=n,u=s;go(4===r.shape.length,(()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`));const c=[1,1];go(qf(a,c),(()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${c}'`));const h=zf(r.shape,i,a,c,o),[d,p]=function(e,t,n,s){let r=new UP(n,"max",!1);const i=s.runWebGLProgram(r,[e],"float32");return r=new UP(n,"max",!0,!0,t),[i,s.runWebGLProgram(r,[e],"float32")]}(r,l,h,u);return[d,p]}};const QW={kernelName:zu,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:s}=e;const{x:r}=t,{keepDims:i,axis:a}=n,o=s,l=r.shape.length,u=Co(a,r.shape);let c=u;const h=Gg(c,l),d=null!=h,p=o.shouldExecuteOnCPU([r]),f=[];let g=r;if(d){if(p){const e=o.texData.get(g.dataId).values,t=new Array(l);for(let s=0;s<t.length;s++)t[s]=r.shape[h[s]];const n=iL(e,r.shape,r.dtype,h,t);g=o.makeTensorInfo(t,r.dtype);o.texData.get(g.dataId).values=n}else g=iP(r,h,o);f.push(g),c=jg(c.length,l)}Ug("sum",c,l);const[m,b]=Wg(g.shape,c);let x=m;i&&(x=Vg(m,u));const y=function(e,t,n,s){const r=xo(t),i=ZL({inputs:{x:e},attrs:{shape:[xo(e.shape)/r,r]},backend:s}),a=nP(i,"float32","mean",s),o=ZL({inputs:{x:a},attrs:{shape:n},backend:s});return s.disposeIntermediateTensorInfo(i),s.disposeIntermediateTensorInfo(a),o}(g,b,x,o);for(const v of f)o.disposeIntermediateTensorInfo(v);return y}};const ZW={kernelName:Bu,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:i,keepDims:a}=s,o=r.shape.length,l=Co(i,r.shape);let u=l;const c=Gg(u,o);let h=r;null!=c&&(h=lP({inputs:{x:r},backend:n,attrs:{perm:c}}),u=jg(u.length,r.shape.length)),Ug("min",u,o);const[d,p]=Wg(h.shape,u),f=ZL({inputs:{x:h},backend:n,attrs:{shape:[-1,xo(p)]}}),g=nP(f,f.dtype,"min",n);let m;if(a){m=ZL({inputs:{x:g},backend:n,attrs:{shape:Vg(d,l)}})}else m=ZL({inputs:{x:g},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),null!=c&&n.disposeIntermediateTensorInfo(h),m}},JW=UL({opSnippet:TL+"\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+EL+"\n  return result;\n",cpuKernelImpl:DO}),eV={kernelName:Wu,backendName:"webgl",kernelFunc:JW};class tV{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const s=e.length,r=BM(s),i=t.map((e=>e[0])).join(","),a=t.map(((t,n)=>t[0]+e[n])).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s),l="reflect"===n?0:1;this.userCode=1!==s?`\n      ${r} start = ${r}(${i});\n      ${r} end = ${r}(${a});\n\n      void main() {\n        ${r} outC = getOutputCoords();\n        for (int i = 0; i < ${s}; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ${l};\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};\n          }\n        }\n        ${r} coords = outC - start;\n        setOutput(getX(${o}));\n      }\n    `:`\n        int start = ${i};\n        int end = ${a};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ${l};\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ${l};\n          }\n          setOutput(getX(outC - start));\n        }\n      `}}class nV{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const s=e.length,r=BM(s),i=t.map((e=>e[0])).join(","),a=t.map(((t,n)=>t[0]+e[n])).join(","),o=lL("rc",s),l=lL("source",s),u=`${o[s-1]} < ${this.outputShape[s-1]}`,c=1===s?"source":`vec2(${l.slice(-2).join()})`,h="reflect"===n?0:1;let d="";if(1===s){const e=`\n        ${r} source = rc;\n        if (source < start) {\n          source = start * 2 - source - ${h};\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ${h};\n        }\n        source -= start;\n      `;d=`\n        ${r} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${l.join()}), ${c});\n        ${o[s-1]} += 1;\n        if(${u}) {\n          ${e}\n          result[1] = getChannel(getX(${l.join()}), ${c});\n        }\n      `}else{const e=`\n        ${r} source = rc;\n        ${r} lt = ${r}(lessThan(source, start));\n        ${r} gte = ${r}(greaterThanEqual(source, end));\n        ${r} orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ${h}) +\n                gte * ((end - 1) * 2 - source + ${h});\n        source -= start;\n      `;d=`\n        ${r} rc = outputLoc;\n        ${e}\n        result[0] = getChannel(getX(${l.join()}), ${c});\n        ${o[s-1]} += 1;\n        if(${u}) {\n          ${e}\n          result[1] = getChannel(getX(${l.join()}), ${c});\n        }\n        rc = outputLoc;\n        ${o[s-2]} += 1;\n        if(${o[s-2]} < ${this.outputShape[s-2]}) {\n          ${e}\n          result[2] = getChannel(getX(${l.join()}), ${c});\n          ${o[s-1]} += 1;\n          if(${u}) {\n            ${e}\n            result[3] = getChannel(getX(${l.join()}), ${c});\n          }\n        }\n      `}this.userCode=`\n      const ${r} start = ${r}(${i});\n      const ${r} end = ${r}(${a});\n\n      void main() {\n        ${r} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${d}\n        setOutput(result);\n      }\n    `}}const sV={kernelName:Vu,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:s}=e;const{x:r}=t,{paddings:i,mode:a}=s,o=qo().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new nV(r.shape,i,a):new tV(r.shape,i,a);return n.runWebGLProgram(o,[r],r.dtype)}},rV=UL({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  "+EL+"\n  return result;\n"}),iV={kernelName:Uu,backendName:"webgl",kernelFunc:rV};class aV{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ${t-1}; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(${t-1}));\n      }\n    `}}const oV=UL({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),lV={kernelName:Yl,backendName:"webgl",kernelFunc:oV},uV="return a - b;",cV=UL({opSnippet:uV,packedOpSnippet:uV,supportsComplex:!0,cpuKernelImpl:nL}),hV={kernelName:Xc,backendName:"webgl",kernelFunc:cV};function dV(e){const{inputs:t,backend:n,attrs:s}=e,{logits:r}=t,{dim:i}=s,a=Co([i],r.shape),o=BW({inputs:{x:r},backend:n,attrs:{reductionIndices:a,keepDims:!1}}),l=Vg(o.shape,a),u=ZL({inputs:{x:o},backend:n,attrs:{shape:l}}),c=cV({inputs:{a:r,b:u},backend:n}),h=RB({inputs:{x:c},backend:n}),d=aP({inputs:{x:h},backend:n,attrs:{axis:a,keepDims:!1}}),p=ZL({inputs:{x:d},backend:n,attrs:{shape:l}}),f=oV({inputs:{a:h,b:p},backend:n});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),f}const pV={kernelName:Mc,backendName:"webgl",kernelFunc:dV};const fV={kernelName:Gu,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{logits:r}=t,{numSamples:i,seed:a,normalized:o}=s,l=o?r:dV({inputs:{logits:r},backend:n,attrs:{dim:r.shape.length-1}}),u=l.shape[0],c=l.shape[1],h=new aV(u,c,i),d=[[a]],p=n.runWebGLProgram(h,[l],"int32",d);return o||n.disposeIntermediateTensorInfo(l),p}},gV=mL+"\n  return -x;\n";const mV={kernelName:ju,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:s}=t;if(n.shouldExecuteOnCPU([s])){const e=n.texData.get(s.dataId),[t,r]=MO(e.values,s.shape,s.dtype);return n.makeTensorInfo(r,s.dtype,t)}let r;return r=qo().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new wL(s.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new gL(s.shape,gV),n.runWebGLProgram(r,[s],s.dtype)}},bV=db;const xV={kernelName:Xu,backendName:"webgl",kernelFunc:function(e){hh("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:s}=e,{boxes:r,scores:i}=t,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l}=s,u=n.readSync(r.dataId),c=n.readSync(i.dataId),{selectedIndices:h}=bV(u,c,a,o,l);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},yV=pb;const vV={kernelName:qu,backendName:"webgl",kernelFunc:function(e){hh("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:s}=e,{boxes:r,scores:i}=t,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:u}=s,c=n.readSync(r.dataId),h=n.readSync(i.dataId),{selectedIndices:d,validOutputs:p}=yV(c,h,a,o,l,u);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},wV=fb;const kV={kernelName:Yu,backendName:"webgl",kernelFunc:function(e){hh("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:s}=e,{boxes:r,scores:i}=t,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l,softNmsSigma:u}=s,c=n.readSync(r.dataId),h=n.readSync(i.dataId),d=a,p=o,f=l,g=u,{selectedIndices:m,selectedScores:b}=wV(c,h,d,p,f,g);return[n.makeTensorInfo([m.length],"int32",new Int32Array(m)),n.makeTensorInfo([b.length],"float32",new Float32Array(b))]}};class SV{constructor(e,t,n,s){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(${s}), float(${n}),\n                      float(index == coords.y)));\n      }\n    `}}const IV={kernelName:Zu,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:s}=e,{indices:r}=t,{dtype:i,depth:a,onValue:o,offValue:l}=s,u=xo(r.shape),c=new SV(u,a,o,l),h=ZL({inputs:{x:r},backend:n,attrs:{shape:[u]}}),d=n.runWebGLProgram(c,[h],i);n.disposeIntermediateTensorInfo(h);const p=ZL({inputs:{x:d},backend:n,attrs:{shape:[...r.shape,a]}});return n.disposeIntermediateTensorInfo(d),p}};function CV(e){const{inputs:t,backend:n}=e,{x:s}=t;if("complex64"===s.dtype){const e=dz({inputs:{input:s},backend:n}),t=CV({inputs:{x:e},backend:n}),r=Tz({inputs:{input:s},backend:n}),i=CV({inputs:{x:r},backend:n}),a=DL({inputs:{real:t,imag:i},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(i),a}return VB({attrs:{shape:s.shape,dtype:s.dtype,value:"string"===s.dtype?"":0},backend:n})}const NV={kernelName:rh,backendName:"webgl",kernelFunc:CV};const TV={kernelName:Qu,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:s}=t,{x:r}=n;if("string"===r.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===r.dtype){const t=dz({inputs:{input:r},backend:s}),n=e({inputs:{x:t},backend:s}),i=Tz({inputs:{input:r},backend:s}),a=CV({inputs:{x:i},backend:s}),o=DL({inputs:{real:n,imag:a},backend:s});return s.disposeIntermediateTensorInfo(t),s.disposeIntermediateTensorInfo(n),s.disposeIntermediateTensorInfo(i),s.disposeIntermediateTensorInfo(a),o}return VB({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:s})}};const _V={kernelName:Ju,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{axis:r}=s;if(1===t.length)return DB({inputs:{input:t[0]},backend:n,attrs:{dim:r}});const i=t[0].shape,a=t[0].dtype;t.forEach((e=>{mo(i,e.shape,"All tensors passed to stack must have matching shapes"),go(a===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const o=[],l=$z({inputs:t.map((e=>{const t=DB({inputs:{input:e},backend:n,attrs:{dim:r}});return o.push(t),t})),backend:n,attrs:{axis:r}});return o.forEach((e=>n.disposeIntermediateTensorInfo(e))),l}};class EV{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const s=e.length,r=BM(s),i=t.map((e=>e[0])).join(","),a=t.map(((t,n)=>t[0]+e[n])).join(","),o=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s);this.userCode=1!==s?`\n      ${r} start = ${r}(${i});\n      ${r} end = ${r}(${a});\n\n      void main() {\n        ${r} outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ${r} coords = outC - start;\n          setOutput(getX(${o}));\n        }\n      }\n    `:`\n        int start = ${i};\n        int end = ${a};\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      `}}class $V{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const s=e.length,r=BM(s),i=t.map((e=>e[0])).join(","),a=t.map(((t,n)=>t[0]+e[n])).join(","),o=lL("rc",s),l=lL("source",s),u=`${o[s-1]} < ${this.outputShape[s-1]}`,c=1===s?"source":`vec2(${l.slice(-2).join()})`,h=[`${r} rc = outputLoc;`,`${o[s-1]} += 1;\n       if(${u}) {\n      `,1===s?"":`}\n       rc = outputLoc;\n       ${o[s-2]} += 1;\n       if(${o[s-2]} < ${this.outputShape[s-2]}) {`,1===s?"":`  ${o[s-1]} += 1;\n         if(${u}) {`],d=1===s?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let f=0,g=1===s?2:4;f<g;f++)p+=`\n        ${h[f]}\n        if (${d}) {\n          result[${f}] = float(value);\n        } else {\n          ${r} source = rc - start;\n          result[${f}] = getChannel(getX(${l.join()}), ${c});\n        }\n      `;p+=1===s?"} ":"}}",this.userCode=`\n      const ${r} start = ${r}(${i});\n      const ${r} end = ${r}(${a});\n\n      void main() {\n        ${r} outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ${p}\n        setOutput(result);\n      }\n    `}}const RV=e=>{const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{paddings:i,constantValue:a}=s;if(0===xo(r.shape)){const e=i.map(((e,t)=>e[0]+r.shape[t]+e[1]));return VB({backend:n,attrs:{shape:e,value:a,dtype:r.dtype}})}const o=qo().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new $V(r.shape,i,a):new EV(r.shape,i,a),l=[[a]];return n.runWebGLProgram(o,[r],r.dtype,l)},AV={kernelName:ec,backendName:"webgl",kernelFunc:RV},DV=UL({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  "+EL+"\n  return result;\n"}),FV={kernelName:tc,backendName:"webgl",kernelFunc:DV};const MV={kernelName:sc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{axis:i,keepDims:a}=s,o=r.shape.length,l=[],u=Co(i,r.shape);let c=u;const h=Gg(c,o);let d,p=r;if(null!=h&&(p=lP({inputs:{x:r},backend:n,attrs:{perm:h}}),c=jg(c.length,o),l.push(p)),Ug("prod",c,o),n.shouldExecuteOnCPU([p])){const e=n.texData.get(p.dataId).values,{outVals:t,outShape:s,outDtype:r}=LO(p.shape,p.dtype,e,c);d=n.makeTensorInfo(s,r,t)}else{const[e,t]=Wg(p.shape,c),s=xo(t),i=ZL({inputs:{x:p},backend:n,attrs:{shape:[-1,s]}}),a=nP(i,hd(r.dtype),"prod",n);d=ZL({inputs:{x:a},backend:n,attrs:{shape:e}}),l.push(i),l.push(a)}if(a){l.push(d);const e=Vg(d.shape,u);d=ZL({inputs:{x:d},backend:n,attrs:{shape:e}})}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),d}};const OV={kernelName:rc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{paramsNestedSplits:r,paramsDenseValues:i,indices:a}=t,{outputRaggedRank:o}=s,l=r.map((e=>n.readSync(e.dataId))),u=r.map((e=>e.shape)),c=n.readSync(i.dataId),h=n.readSync(a.dataId),[d,p,f]=PO(l,u,c,i.shape,i.dtype,h,a.shape,o),g=d.map((e=>n.makeTensorInfo([e.length],"int32",e))),m=n.makeTensorInfo(f,i.dtype,p);return g.concat([m])}};const LV={kernelName:ic,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{starts:s,limits:r,deltas:i}=t,a=n.readSync(s.dataId),o=n.readSync(r.dataId),l=n.readSync(i.dataId),[u,c]=zO(a,s.shape,s.dtype,o,r.shape,l,i.shape);return[n.makeTensorInfo([u.length],"int32",u),n.makeTensorInfo([c.length],s.dtype,c)]}};const PV={kernelName:ac,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{shape:r,values:i,defaultValue:a,rowPartitionTensors:o}=t,{rowPartitionTypes:l}=s,u=n.readSync(r.dataId),c=n.readSync(i.dataId),h=n.readSync(a.dataId),d=o.map((e=>n.readSync(e.dataId))),p=o.map((e=>e.shape)),[f,g]=BO(u,r.shape,c,i.shape,i.dtype,h,a.shape,d,p,l);return n.makeTensorInfo(f,i.dtype,g)}},zV=e=>{const{backend:t,attrs:n}=e,{start:s,stop:r,step:i,dtype:a}=n,o=WO(s,r,i,a);return t.makeTensorInfo([o.length],a,o)},BV={kernelName:oc,backendName:"webgl",kernelFunc:zV},WV=VL({opSnippet:"return 1.0 / x;"}),VV={kernelName:uc,backendName:"webgl",kernelFunc:WV},UV=VL({opSnippet:mL+"\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),GV={kernelName:cc,backendName:"webgl",kernelFunc:UV},HV=VL({opSnippet:mL+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),jV={kernelName:mc,backendName:"webgl",kernelFunc:HV};class KV{constructor(e,t,n,s,r){this.variableNames=["A"],this.outputShape=[];const[i,a,o,l]=e;this.outputShape=[i,t,n,l];const u=[s&&t>1?a-1:a,s&&n>1?o-1:o],c=[s&&t>1?t-1:t,s&&n>1?n-1:n];let h;h=r?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    `}}class XV{constructor(e,t,n,s,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,a,o,l]=e;this.outputShape=[i,t,n,l];const u=[s&&t>1?a-1:a,s&&n>1?o-1:o],c=[s&&t>1?t-1:t,s&&n>1?n-1:n];let h;h=r?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]},\n          ${u[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${a}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${h};\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    `}}const qV={kernelName:fc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{images:r}=t,{alignCorners:i,halfPixelCenters:a,size:o}=s,[l,u]=o,c=qo().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new XV(r.shape,l,u,i,a):new KV(r.shape,l,u,i,a);return n.runWebGLProgram(c,[r],"float32")}};class YV{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,s,r]=t,[,i,a]=e,o=[n&&i>1?s-1:s,n&&a>1?r-1:r],l=[n&&i>1?i-1:i,n&&a>1?a-1:a],u=o[0]/l[0],c=o[1]/l[1],h=1/u,d=1/c,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${d});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${i}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ${s-1}.0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ${r-1}.0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const QV={kernelName:gc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{images:r,dy:i}=t,{alignCorners:a}=s,o=new YV(i.shape,r.shape,a);return n.runWebGLProgram(o,[i],i.dtype)}};class ZV{constructor(e,t,n,s,r){this.variableNames=["A"],this.outputShape=[];const[i,a,o,l]=e;this.outputShape=[i,t,n,l];const u=[s&&t>1?a-1:a,s&&n>1?o-1:o],c=[s&&t>1?t-1:t,s&&n>1?n-1:n],h=s?"0.5":"0.0";let d;d=r?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]});\n      const vec2 inputShapeRC = vec2(${a}.0, ${o}.0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ${d};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${h})));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    `}}class JV{constructor(e,t,n,s,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[i,a,o,l]=e;this.outputShape=[i,t,n,l];const u=[s&&t>1?a-1:a,s&&n>1?o-1:o],c=[s&&t>1?t-1:t,s&&n>1?n-1:n],h=s?"0.5":"0.0";let d;d=r?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ${u[0]/c[0]},\n          ${u[1]/c[1]},\n          ${u[1]/c[1]});\n      const vec3 inputShapeRC = vec3(${a}.0, ${o}.0,\n                                     ${o}.0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ${d};\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${h})));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ${l-1};\n        bool hasNextRow = coords.z < ${n-1};\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    `}}const eU={kernelName:dc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{images:r}=t,{alignCorners:i,halfPixelCenters:a,size:o}=s,[l,u]=o,c=qo().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new JV(r.shape,l,u,i,a):new ZV(r.shape,l,u,i,a);return n.runWebGLProgram(c,[r],r.dtype)}};class tU{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,s,r]=t,[,i,a]=e,o=[n&&i>1?s-1:s,n&&a>1?r-1:r],l=[n&&i>1?i-1:i,n&&a>1?a-1:a],u=o[0]/l[0],c=o[1]/l[1],h=1/u,d=1/c,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode=`\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(${u});\n        const float widthScale = float(${c});\n\n        const float invHeightScale = float(${h});\n        const float invWidthScale = float(${d});\n\n        const int winHeight = int(${p});\n        const int winWidth = int(${f});\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ${i}) {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ${a}) {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(${o[0]}) *\n                (float(dyR) / float(${l[0]}));\n\n            float sourceFracCol =\n                float(${o[1]}) *\n                  (float(dyC) / float(${l[1]}));\n\n            int sourceNearestRow = int(min(\n                float(int(${s}) - 1),\n                ${n} ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(${r}) - 1),\n                ${n} ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    `}}const nU={kernelName:pc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{images:r,dy:i}=t,{alignCorners:a}=s,o=new tU(i.shape,r.shape,a);return n.runWebGLProgram(o,[i],i.dtype)}};class sU{constructor(e,t){this.variableNames=["x"];const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=e,1===n)return void(this.userCode=`\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(${e[0]} - coord - 1));\n        }\n      `);const s=e.map(((n,s)=>(n=>-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - coords[${n}] - 1`:`coords[${n}]`)(s))).join(","),r=BM(n);this.userCode=`\n      void main() {\n        ${r} coords = getOutputCoords();\n        setOutput(getX(${s}));\n      }\n    `}}class rU{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=e.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=e;const s=lL("rc",n),r=`${s[n-1]} + 1 < ${this.outputShape[n-1]}`,i=`${s[n-2]} + 1 < ${this.outputShape[n-2]}`,a=BM(n);function o(n){const s=e.map(((s,r)=>function(n,s){return-1!==t.indexOf(n)&&1!==e[n]?`${e[n]} - ${s[n]} - 1`:`${s[n]}`}(r,n)));return`getChannel(getX(${s.join(",")}), vec2(${s.slice(-2).join(",")}))`}this.userCode=1===n?`\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${e[0]} - rc - 1),\n            ${e[0]} - rc - 1);\n          if(${r}){\n              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),\n                ${e[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `:`\n        void main() {\n          ${a} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${function(e){return o(e)}(s.slice())};\n          if(${r}){\n            result.g = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",o(e)}(s.slice())};\n          }\n          if(${i}) {\n            result.b = ${function(e){return e[n-2]="("+e[n-2]+" + 1)",o(e)}(s.slice())};\n            if(${r}) {\n              result.a = ${function(e){return e[n-1]="("+e[n-1]+" + 1)",e[n-2]="("+e[n-2]+" + 1)",o(e)}(s.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `}}const iU={kernelName:bc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{dims:i}=s,a=r.shape.length,o=Co(i,r.shape);if(0===a)return RL({inputs:{x:r},backend:n});const l=qo().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new rU(r.shape,o):new sU(r.shape,o);return n.runWebGLProgram(l,[r],r.dtype)}};class aU{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const n=e[1],s=e[2];this.outputShape=e;let r="";r="number"===typeof t?`float outputValue = ${t.toFixed(2)};`:`\n        vec3 fill = vec3(${t.join(",")});\n        float outputValue = fill[coords[3]];`,this.userCode=`\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ${r}\n          if(coordX >= 0 && coordX < ${s} && coordY >= 0 && coordY < ${n}) {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    `}}const oU={kernelName:oh,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:s}=e;const{image:r}=t,{radians:i,fillValue:a,center:o}=n,l=s,u=new aU(r.shape,a),[c,h]=ex(o,r.shape[1],r.shape[2]),d=[[c,h,Math.sin(i),Math.cos(i)]];return l.runWebGLProgram(u,[r],r.dtype,d)}},lU=VL({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),uU={kernelName:xc,backendName:"webgl",kernelFunc:lU},cU=VL({opSnippet:"return inversesqrt(x);",cpuKernelImpl:VO}),hU={kernelName:yc,backendName:"webgl",kernelFunc:cU};class dU{constructor(e,t,n,s,r,i){let a=arguments.length>7&&void 0!==arguments[7]&&arguments[7];this.variableNames=["updates","indices","defaultValue"],this.outputShape=i;const o=BM(r.length),l=BM(i.length);let u="";1===n?u="i":2===n&&(u="i, j");const c=`getIndices(${u})`;let h="";1===s?h="i":2===s&&(h="i, coords[1]");const d=`getUpdates(${h})`;let p="";a&&(p="coords[0], coords[1]");const f=`getDefaultValue(${p})`,g=t>1?"strides[j]":"strides";this.userCode=`\n        ${o} strides = ${o}(${r});\n\n        void main() {\n          ${l} coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ${e}; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ${t}; j++) {\n              int index = round(${c});\n              flattenedIndex += index * ${g};\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ${d};\n              found = true;\n            }\n          }\n          setOutput(mix(${f}, sum, float(found)));\n        }\n      `}}class pU{constructor(e,t,n,s,r,i){let a=arguments.length>7&&void 0!==arguments[7]&&arguments[7];this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=i;const o=BM(r.length),l=BM(i.length);let u="";1===n?u="i":2===n&&(u="i, j");const c=`getIndices(${u})`;let h="";1===s?h="i":2===s&&(h="i, coords[1]");const d=`getUpdates(${h})`;let p="";a&&(p="coords[0], coords[1]");const f=`getDefaultValue(${p})`,g=t>1?"strides[j]":"strides",m=t>1?"strides[j + 1]":"strides";this.userCode=`\n        ${o} strides = ${o}(${r});\n\n        void main() {\n          ${l} coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ${e}; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ${t}; j+=2) {\n              ivec4 index = round(${c});\n              flattenedIndex += index.xz * ${g};\n              if (j + 1 < ${t}) {\n                flattenedIndex += index.yw * ${m};\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = ${d};\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(${f}, sum, found));\n        }\n      `}}const fU={kernelName:vc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{indices:r,updates:i}=t,{shape:a}=s,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=ux(0,r,a),d=[h/u,u];if(0===h)return n.makeTensorInfo(a,r.dtype);const p=ZL({inputs:{x:r},backend:n,attrs:{shape:[l,o]}}),f=ZL({inputs:{x:i},backend:n,attrs:{shape:[l,u]}}),g=n.makeTensorInfo([],"float32",new Float32Array([0]));let m;m=qo().getBool("WEBGL_PACK")?new pU(l,o,p.shape.length,f.shape.length,c,d):new dU(l,o,p.shape.length,f.shape.length,c,d);const b=n.runWebGLProgram(m,[f,p,g],f.dtype),x=ZL({inputs:{x:b},backend:n,attrs:{shape:a}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(b),n.disposeIntermediateTensorInfo(g),x}};class gU{constructor(e,t,n,s){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,n];const r=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,i=2===qo().getNumber("WEBGL_VERSION")?"while (left < right) {":r,a="left"===s?"<":"<=";this.userCode=`\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ${i}\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ${a} value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     `}}const mU={kernelName:kc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{sortedSequence:r,values:i}=t,{side:a}=s,o=new gU(r.shape[0],r.shape[1],i.shape[1],a),l=[[r.shape[1]]];return n.runWebGLProgram(o,[r,i],"int32",l)}};class bU{constructor(e,t,n){let s,r;if(this.variableNames=["c","a","b"],this.outputShape=t,n>4)throw Error(`Where for rank ${n} is not yet supported`);if(1===n)r="resRC",s="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],i=[],a=[];for(let s=0;s<t.length;s++)a.push(`${n[s]}`),s<e&&i.push(`${n[s]}`);s=i.join(),r=a.join()}const i=BM(n);this.userCode=`\n      void main() {\n        ${i} resRC = getOutputCoords();\n        float cVal = getC(${s});\n        if (cVal >= 1.0) {\n          setOutput(getA(${r}));\n        } else {\n          setOutput(getB(${r}));\n        }\n      }\n    `}}const xU={kernelName:Sc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:s,t:r,e:i}=t,a=new bU(s.shape.length,r.shape,r.shape.length);return n.runWebGLProgram(a,[s,r,i],cd(r.dtype,i.dtype))}},yU=VL({opSnippet:`\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ${cx};\n  float scale = ${hx};\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n`}),vU={kernelName:Ic,backendName:"webgl",kernelFunc:yU},wU=VL({opSnippet:WL+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:GO}),kU={kernelName:Ec,backendName:"webgl",kernelFunc:wU},SU=VL({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),IU={kernelName:_c,backendName:"webgl",kernelFunc:SU},CU=VL({opSnippet:WL+"\n  return sin(x);\n",packedOpSnippet:`\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ${EL}\n  return result;\n`}),NU={kernelName:Nc,backendName:"webgl",kernelFunc:CU},TU=VL({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),_U={kernelName:Tc,backendName:"webgl",kernelFunc:TU},EU=VL({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),$U={kernelName:$c,backendName:"webgl",kernelFunc:EU},RU={kernelName:Dc,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{blockShape:i,paddings:a}=s;go(r.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"));const o=i.reduce(((e,t)=>e*t)),l=[[0,0]];l.push(...a);for(let b=1+i.length;b<r.shape.length;++b)l.push([0,0]);const u=[],c=RV({inputs:{x:r},backend:n,attrs:{paddings:l,constantValue:0}}),h=tx(c.shape,i,o,!1),d=nx(h.length,i.length,!1),p=sx(c.shape,i,o,!1),f=ZL({inputs:{x:c},backend:n,attrs:{shape:h}}),g=lP({inputs:{x:f},backend:n,attrs:{perm:d}}),m=ZL({inputs:{x:g},backend:n,attrs:{shape:p}});return u.push(c),u.push(f),u.push(g),u.forEach((e=>n.disposeIntermediateTensorInfo(e))),m}};const AU={kernelName:Oc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:s,values:r,denseShape:i,defaultValue:a}=t;if(1!==i.shape.length)throw new Error(`Dense shape must be a vector, saw:\n         ${i.shape}`);if(2!==s.shape.length)throw new Error(`Indices must be a matrix, saw:\n         ${s.shape}`);if(1!==r.shape.length)throw new Error(`Values must be a vector, saw:\n         ${r.shape}`);if(0!==a.shape.length)throw new Error(`Default value must be a scalar, saw:\n        ${a.shape}`);const o=n.readSync(s.dataId),l=n.readSync(r.dataId),u=n.readSync(i.dataId),c=n.readSync(a.dataId)[0],[h,d,p,f,g]=KO(o,s.shape,s.dtype,l,r.dtype,u,c);return[n.makeTensorInfo(d,s.dtype,h),n.makeTensorInfo([d[0]],r.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([g.length],s.dtype,new Int32Array(g))]}};const DU={kernelName:Lc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:s,inputShape:r,newShape:i}=t;if(2!==s.shape.length)throw new Error(`Input indices should be a matrix but received shape ${s.shape}`);if(1!==r.shape.length)throw new Error(`Input shape should be a vector but received shape ${r.shape}`);if(1!==i.shape.length)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const a=Array.from(n.readSync(r.dataId)),o=n.readSync(s.dataId),l=Array.from(n.readSync(i.dataId)),[u,c,h]=XO(o,s.shape,s.dtype,a,l);return[n.makeTensorInfo(c,s.dtype,u),n.makeTensorInfo([h.length],i.dtype,new Int32Array(h))]}};const FU={kernelName:Pc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:s,indices:r,segmentIds:i}=t;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error(`Indices should be a vector but received shape\n              ${r.shape}`);if(1!==i.shape.length)throw new Error(`Segment ids should be a vector but received shape\n              ${i.shape}`);const a=n.readSync(s.dataId),o=n.readSync(r.dataId),l=n.readSync(i.dataId),[u,c]=qO(a,s.shape,s.dtype,o,l,!0);return n.makeTensorInfo(c,s.dtype,u)}};const MU={kernelName:zc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:s,indices:r,segmentIds:i}=t;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error(`Indices should be a vector but received shape\n             ${r.shape}`);if(1!==i.shape.length)throw new Error(`Segment ids should be a vector but received shape\n             ${i.shape}`);const a=n.readSync(s.dataId),o=n.readSync(r.dataId),l=n.readSync(i.dataId),[u,c]=qO(a,s.shape,s.dtype,o,l);return n.makeTensorInfo(c,s.dtype,u)}};const OU={kernelName:Bc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{sparseIndices:r,sparseValues:i,defaultValue:a}=t,{outputShape:o}=s,{sliceRank:l,numUpdates:u,sliceSize:c,strides:h,outputSize:d}=ux(0,r,o),p=!1;if("string"===i.dtype){const e=n.bufferSync(r),t=n.bufferSync(i),s=Bh(n.readSync(a.dataId)[0]),f=UO(e,t,o,d,c,u,l,h,s,p);return n.makeTensorInfo(o,f.dtype,f.values)}const f=new dU(u,l,r.shape.length,i.shape.length,h,[d,1],p),g=n.runWebGLProgram(f,[i,r,a],i.dtype),m=ZL({inputs:{x:g},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(g),m}};const LU={kernelName:Fc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{numOrSizeSplits:i,axis:a}=s,o=Co(a,r.shape)[0],l=Ox(r,i,o),u=r.shape.length,c=new Array(u).fill(0),h=r.shape.slice();return l.map((e=>{const t=[...h];t[o]=e;const s=rz({inputs:{x:r},backend:n,attrs:{begin:c,size:t}});return c[o]+=e,s}))}},PU="return sqrt(x);",zU=VL({opSnippet:PU,packedOpSnippet:PU,cpuKernelImpl:YO}),BU={kernelName:Rc,backendName:"webgl",kernelFunc:zU},WU={kernelName:Vc,backendName:"webgl",kernelFunc:VL({opSnippet:"return x * x;"})},VU="return (a - b) * (a - b);",UU=UL({opSnippet:VU,packedOpSnippet:VU}),GU={kernelName:Wc,backendName:"webgl",kernelFunc:UU};const HU={kernelName:Uc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t;if("string"!==r.dtype)throw new Error("Input must be of datatype string");const i=Zx(n.readSync(r.dataId)),a=QO(i,"string",s);return n.makeTensorInfo(r.shape,"string",a)}};const jU={kernelName:ih,backendName:"webgl",kernelFunc:function(e){let{inputs:t,attrs:n,backend:s}=e;const{x:r}=t,i=mL+`\n    return x > 0.0 ? 1.0 : float(${n.alpha});\n  `,a=new gL(r.shape,i);return s.runWebGLProgram(a,[r],r.dtype)}};class KU{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;const s=n.length,r=BM(n.length),i=BM(n.length);let a="";if(1===s)a="coords * strides + begin";else{let e=0;a=n.map(((t,s)=>(e++,1===n.length?`coords * strides[${s}] + begin[${s}]`:`coords[${e-1}] * strides[${s}] + begin[${s}]`))).join(",")}this.userCode=`\n      ${r} begin = ${r}(${e});\n      ${r} strides = ${r}(${t});\n\n      void main() {\n        ${i} coords = getOutputCoords();\n        setOutput(getX(${a}));\n      }\n    `}}const XU={kernelName:Gc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{begin:i,end:a,strides:o,beginMask:l,endMask:u,ellipsisMask:c,newAxisMask:h,shrinkAxisMask:d}=s,{finalShapeSparse:p,finalShape:f,isIdentity:g,sliceDim0:m,isSimpleSlice:b,begin:x,end:y,strides:v}=Df(r.shape,i,a,o,l,u,c,h,d);let w;if(g)w=ZL({inputs:{x:r},backend:n,attrs:{shape:f}});else if(m||b){go(r.shape.length>=1,(()=>`Input must have rank at least 1, got: ${r.shape.length}`));const e=vf(x,y,v),t=rz({inputs:{x:r},backend:n,attrs:{begin:x,size:e}});w=ZL({inputs:{x:t},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(t)}else{if(n.shouldExecuteOnCPU([r])){const e=n.readSync(r.dataId),t=Tp(r.shape,r.dtype,e),s=ZO(p,t,v,x);w=n.makeTensorInfo(f,r.dtype,s.values)}else{const e=new KU(x,v,p);w=n.runWebGLProgram(e,[r],r.dtype)}}const k=ZL({inputs:{x:w},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(w),k}};const qU={kernelName:Hc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{separator:r,nGramWidths:i,leftPad:a,rightPad:o,padWidth:l,preserveShortSequences:u}=s,{data:c,dataSplits:h}=t,d=n.readSync(c.dataId),p=n.readSync(h.dataId),[f,g]=JO(d,p,r,i,a,o,l,u);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",g)]}};const YU={kernelName:jc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{skipEmpty:r}=s,{input:i,delimiter:a}=t;if("string"!==i.dtype)throw new Error("Input must be of datatype string");if(1!==i.shape.length)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(0!==a.shape.length)throw new Error(`Delimiter must be a scalar, got shape: ${a.shape}`);const o=n.readSync(i.dataId),l=n.readSync(a.dataId)[0],[u,c,h]=eL(o,l,r),d=c.length;return[n.makeTensorInfo([d,2],"int32",u),n.makeTensorInfo([d],"string",c),n.makeTensorInfo([2],"int32",new Int32Array(h))]}};const QU={kernelName:Kc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{numBuckets:r}=s,{input:i}=t;if("string"!==i.dtype)throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const a=n.readSync(i.dataId),o=tL(a,r);return n.makeTensorInfo(i.shape,"int32",o)}},ZU=VL({opSnippet:"return tan(x);"}),JU={kernelName:qc,backendName:"webgl",kernelFunc:ZU},eG=VL({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),tG={kernelName:Yc,backendName:"webgl",kernelFunc:eG};const nG={kernelName:wc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{tensor:r,indices:i,updates:a}=t,{}=s,{sliceRank:o,numUpdates:l,sliceSize:u,strides:c,outputSize:h}=ux(0,i,r.shape),d=[h/u,u];if(0===h)return n.makeTensorInfo(r.shape,i.dtype);const p=ZL({inputs:{x:i},backend:n,attrs:{shape:[l,o]}}),f=ZL({inputs:{x:a},backend:n,attrs:{shape:[l,u]}}),g=ZL({inputs:{x:r},backend:n,attrs:{shape:d}}),m=new dU(l,o,p.shape.length,f.shape.length,c,d,!1,!0),b=n.runWebGLProgram(m,[f,p,g],g.dtype),x=ZL({inputs:{x:b},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(b),x}};class sG{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let i=0;i<n.length;i++)n[i]=e[i]*t[i];this.outputShape=n,this.rank=n.length;const s=BM(this.rank),r=function(e){const t=e.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(1===t)return`imod(resRC, ${e[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],s=[];for(let r=0;r<e.length;r++)s.push(`imod(${n[r]}, ${e[r]})`);return s.join()}(e);this.userCode=`\n      void main() {\n        ${s} resRC = getOutputCoords();\n        setOutput(getA(${r}));\n      }\n    `}}function rG(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{reps:i}=s;if("string"===r.dtype||r.shape.length>5){const e=n.readSync(r.dataId),t="string"===r.dtype?e.map((e=>Bh(e))):e,s=Tp(r.shape,r.dtype,t),a=sL(s,i);return n.makeTensorInfo(a.shape,a.dtype,a.values)}const a=new sG(r.shape,i);return n.runWebGLProgram(a,[r],r.dtype)}const iG={kernelName:Qc,backendName:"webgl",kernelFunc:rG};class aG{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class oG{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function lG(e,t){null!==t&&e.disposeIntermediateTensorInfo(t)}function uG(e){let t=1;for(;t<e;)t*=2;return t}const cG={kernelName:Zc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r}=t,{k:i,sorted:a}=s,o=qo().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=qo().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),u=r.shape,c=u[u.length-1];if(n.shouldExecuteOnCPU([r])||c<o||i>l){const e=n.readSync(r.dataId),[t,s]=rL(e,u,r.dtype,i,a);return[n.makeTensorInfo(t.shape,t.dtype,t.values),n.makeTensorInfo(s.shape,s.dtype,s.values)]}if(0===i)return u[u.length-1]=0,[n.makeTensorInfo(u,r.dtype,[]),n.makeTensorInfo(u,"int32",[])];if(1===c)return[r,VB({attrs:{shape:u,dtype:"int32",value:0},backend:n})];const h=n.texData.get(r.dataId),d=null!==h&&h.isPacked,p=d?n.unpackTensor(r):r,f=xo(u)/c,g=ZL({inputs:{x:p},attrs:{shape:[f,c]},backend:n});d&&lG(n,p);const m=uG(i),b=uG(c);let x=null;const y=()=>null===x?[g,g]:[g,x],v=(e,t,s)=>{const r=y(),i=new aG(s),a=[[c],[null===x?1:0],[Number.NEGATIVE_INFINITY],[e],[t]],o=x;x=n.runWebGLProgram(i,r,"int32",a),lG(n,o)};for(let C=1;C<m;C*=2){const e=2*C;for(let t=C;t>=1;t/=2)v(e,t,[f,b])}for(let C=b;C>m;C/=2){const e=y(),t=new oG([f,C/2]),s=[[c],[null===x?1:0],[m]],r=x;x=n.runWebGLProgram(t,e,"int32",s),lG(n,r);const i=m/2,a=2*i;for(let n=i;n>=1;n/=2)v(a,n,x.shape)}let w=x;x=rz({inputs:{x:x},backend:n,attrs:{begin:0,size:[f,i]}}),lG(n,w);let k=oW({inputs:{x:g,indices:x},backend:n,attrs:{axis:1,batchDims:1}});lG(n,g);const S=u.slice(0,-1);S.push(i),w=x,x=ZL({inputs:{x:x},attrs:{shape:S},backend:n}),lG(n,w);const I=k;return k=ZL({inputs:{x:k},attrs:{shape:S},backend:n}),lG(n,I),[k,x]}};class hG{constructor(e,t,n,s,r,i){this.variableNames=["Image","Transforms"],this.outputShape=i;const a="nearest"===n?1:2;let o;switch(s){case"constant":default:o=1;break;case"reflect":o=2;break;case"wrap":o=3;break;case"nearest":o=4}this.userCode=`\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(${o} == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${o} == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (${o} == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(${r});\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(${r});\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(${t}));\n                float mapY = mapCoord(inY, float(${e}));\n\n                if (${a} == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        `}}const dG={kernelName:Jc,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{image:r,transforms:i}=t,{interpolation:a,fillMode:o,fillValue:l,outputShape:u}=s,[c,h,d,p]=r.shape,[f,g]=null!=u?u:[h,d],m=new hG(h,d,a,o,l,[c,f,g,p]);return n.runWebGLProgram(m,[r,i],"float32")}};const pG={kernelName:th,backendName:"webgl",kernelFunc:function(e){const{inputs:t,attrs:n,backend:s}=e,{axis:r}=n,{x:i}=t;wM(i,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const a=s.readSync(i.dataId),{outputValues:o,outputShape:l,indices:u}=aL(a,r,i.shape,i.dtype);return[s.makeTensorInfo(l,i.dtype,o),s.makeTensorInfo([u.length],"int32",u)]}};const fG={kernelName:nh,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{value:r}=t;let{axis:i}=s;i<0&&(i+=r.shape.length);const a=r,o=a.shape.length,l=r.shape[i],u=new Array(o-1);let c=0;for(let g=0;g<o;g++)g!==i&&(u[c++]=a.shape[g]);const h=[],d=new Array(o).fill(0),p=a.shape.slice();p[i]=1;const f=new Array(l);for(let g=0;g<f.length;g++){d[i]=g;const e=rz({inputs:{x:a},backend:n,attrs:{begin:d,size:p}}),t=ZL({inputs:{x:e},backend:n,attrs:{shape:u}});f[g]=t,h.push(e)}return h.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}};class gG{constructor(e,t){this.variableNames=["x","segmentIds"];const n=e.windowSize,s=e.batchSize,r=e.inSize,i=e.numSegments,a=i*Math.ceil(r/n);this.outputShape=[s,a];const o=4*Math.floor(n/4),l=n%4,u="\n        sumValue += dot(values, segFilter);\n    ";let c="";r%n>0&&(c=`\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return initializationValue;\n        }\n      `);let h="";r%n>0&&(h=`\n        if (inIdx < 0 || inIdx >= ${r}) {\n          return -1.0;\n        }\n      `),this.userCode=`\n      const float initializationValue = 0.0;\n\n      float getValue(int batch, int inIdx) {\n        ${c}\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ${h}\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ${i})) * float(${n}));\n        int currentSeg = int(mod(float(outIdx), float(${i})));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ${o}; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ${u}\n        }\n\n        int inIdx = inOffset + ${o};\n        if (${1===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ${u}\n        } else if (${2===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ${u}\n        } else if (${3===l}) {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ${u}\n        }\n        setOutput(sumValue);\n      }\n    `}}const mG={kernelName:sh,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:s}=e,{x:r,segmentIds:i}=t,{numSegments:a}=s,o=r.shape.length,l=[];let u=0;const c=Gg([u],o);let h=r;null!=c&&(h=lP({inputs:{x:r},backend:n,attrs:{perm:c}}),l.push(h),u=jg(1,o)[0]);const d=Yx(h.shape,u,a),p=xo([h.shape[u]]),f=ZL({inputs:{x:h},backend:n,attrs:{shape:[-1,p]}});l.push(f);const g=hd(r.dtype),m=(e,t,s,r,i)=>{const a=e.shape[0],o=e.shape[1],u=qx(o,i),c=new gG({windowSize:u,inSize:o,batchSize:a,numSegments:i},t),h=n.compileAndRun(c,[e,s],r);if(l.push(h),h.shape[1]===i)return h;const d=zV({backend:n,attrs:{start:0,stop:i,step:1,dtype:"float32"}}),p=rG({inputs:{x:d},backend:n,attrs:{reps:[o/u]}});l.push(d),l.push(p);return m(h,t,p,r,i)},b=ZL({inputs:{x:m(f,"unsortedSegmentSum",i,g,a)},backend:n,attrs:{shape:d}});let x=b;if(null!=c){l.push(b);const e=Hg(c);x=lP({inputs:{x:x},backend:n,attrs:{perm:e}})}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),x}},bG=[hP,pP,gP,bP,vP,SP,IP,CP,RP,AP,FP,OP,PP,BP,VP,HP,jP,qP,YP,QP,ez,az,oz,lz,uz,fz,bz,vz,FL,Sz,Rz,zz,Gz,jz,Kz,Xz,qz,Qz,Jz,tB,oB,lB,uB,hB,fB,bB,xB,vB,kB,SB,CB,NB,_B,$B,AB,FB,LB,BB,UB,HB,XB,YB,JB,nW,sW,iW,lW,cW,dW,AL,pW,_z,gW,bW,yW,LL,wW,SW,IW,NW,_W,$W,AW,FW,LW,zW,WW,UW,GW,HW,XW,qW,YW,QW,ZW,eV,sV,iV,fV,QL,mV,xV,vV,kV,hz,IV,TV,_V,AV,FV,BL,MV,OV,LV,PV,BV,pz,lV,VV,GV,jV,JL,qV,QV,eU,nU,iU,oU,uU,hU,fU,mU,xU,vU,kU,IU,NU,_U,iz,pV,$U,RU,AU,DU,FU,MU,OU,LU,BU,WU,GU,HU,jU,XU,qU,YU,QU,hV,oP,JU,tG,nG,iG,cG,dG,uP,pG,fG,mG,NV];for(const n of bG)xh(n);const xG=800,yG=500,vG={grass:200,bushes:100,trees:50,rabbits:80,wolves:30},wG=()=>{const[e,t]=(0,i.useState)(vG),[n,s]=(0,i.useState)([]),[r,a]=(0,i.useState)(null),[u,h]=(0,i.useState)([{time:0,...vG}]),[d,p]=(0,i.useState)(0),[f,g]=(0,i.useState)({grass:Array.from({length:vG.grass},(()=>({id:`grass-${Math.random()}`,x:Math.random()*xG,y:Math.random()*yG}))),bushes:Array.from({length:vG.bushes},(()=>({id:`bush-${Math.random()}`,x:Math.random()*xG,y:Math.random()*yG}))),trees:Array.from({length:vG.trees},(()=>({id:`tree-${Math.random()}`,x:Math.random()*xG,y:Math.random()*yG}))),rabbits:Array.from({length:vG.rabbits},(()=>({id:`rabbit-${Math.random()}`,x:Math.random()*xG,y:Math.random()*yG,type:"rabbit"}))),wolves:Array.from({length:vG.wolves},(()=>({id:`wolf-${Math.random()}`,x:Math.random()*xG,y:Math.random()*yG,type:"wolf"})))});(0,i.useEffect)((()=>{(async()=>{const e=new lC(t);var t;e.add(_T({inputShape:[5],units:20,activation:"relu"})),e.add(_T({units:10,activation:"relu"})),e.add(_T({units:5,activation:"linear"})),e.compile({optimizer:"adam",loss:"meanSquaredError"});const n=Dm([[200,100,50,80,30],[210,95,55,85,25],[190,105,45,75,35],[205,90,60,90,20],[195,110,40,70,40]]),s=Dm([[205,95,55,85,25],[195,105,45,75,35],[200,100,50,80,30],[210,90,60,90,20],[190,110,40,70,40]]);await e.fit(n,s,{epochs:500}),a(e)})()}),[]),(0,i.useEffect)((()=>{const e=setInterval((()=>{p((e=>e+1)),t((e=>{const t={...e};return t.grass=Math.max(t.grass+m(t.grass,t.trees,t.rabbits)+y(),0),t.bushes=Math.max(t.bushes+b(t.bushes,t.trees)+y(),0),t.trees=Math.min(Math.max(t.trees+b(t.trees,t.trees)+y(),0),500),t.rabbits=Math.max(t.rabbits+x(t.rabbits,t.grass,t.wolves)+y(),0),t.wolves=Math.max(t.wolves+x(t.wolves,t.rabbits,0)+y(),0),t})),g((e=>({...e,rabbits:v(e.rabbits),wolves:v(e.wolves)})))}),500);return()=>clearInterval(e)}),[e]);const m=(e,t,n)=>{let s;s=t>400?e<50?8:e<150?4:e<200?1:0:e<50?10:e<150?5:e<200?2:0;return s-.3*n},b=(e,t)=>t>100?e<50?8:e<150?4:e<200?1:0:e<50?10:e<150?5:e<200?2:0,x=(e,t,n)=>t<1.5*e?-Math.floor(.05*e):n>20?-Math.floor(.02*e):Math.floor(.02*e),y=()=>Math.floor(7*Math.random())-3,v=e=>e.map((e=>{const t=Math.floor(11*Math.random()-5),n=Math.floor(11*Math.random()-5);let s=w(e.x+t,0,xG),r=w(e.y+n,0,yG);return{...e,x:s,y:r}})),w=(e,t,n)=>Math.min(Math.max(e,t),n);(0,i.useEffect)((()=>{h((t=>{const n=[...t,{time:d,...e}];return n.length>100&&n.shift(),n}))}),[e,d]),(0,i.useEffect)((()=>{(async()=>{if(r){const t=Dm([[e.grass,e.bushes,e.trees,e.rabbits,e.wolves]]),n=r.predict(t),i=await n.data(),a={grass:Math.round(i[0]),bushes:Math.round(i[1]),trees:Math.round(i[2]),rabbits:Math.round(i[3]),wolves:Math.round(i[4])},o=[a,{grass:-a.grass,bushes:-a.bushes,trees:-a.trees,rabbits:-a.rabbits,wolves:-a.wolves}];s(o)}})()}),[e,r]);return(0,o.jsxs)("div",{className:"ecosystem-container",children:[(0,o.jsxs)("div",{className:"chart-and-controls",children:[(0,o.jsx)(Ha,{history:u}),(0,o.jsxs)("div",{className:"controls-suggestions",children:[(0,o.jsx)(l,{onAction:(e,n)=>{t((t=>{const s={...t,[e]:Math.max(t[e]+n,0)};return g((t=>{let s={...t};if(n>0){const r=Array.from({length:n},(()=>"grass"===e||"bushes"===e||"trees"===e?{id:`${e}-${Math.random()}`,x:Math.random()*xG,y:Math.random()*yG}:{id:`${e}-${Math.random()}`,x:Math.random()*xG,y:Math.random()*yG,type:e}));s[e]=[...t[e],...r]}else n<0&&(s[e]=t[e].slice(0,Math.max(t[e].length+n,0)));return s})),s}))}}),(0,o.jsx)(c,{suggestions:n,onApply:e=>{t((t=>{const n={...t};return Object.keys(e).forEach((s=>{n[s]=Math.max(t[s]+e[s],0)})),g((t=>{let n={...t};return Object.keys(e).forEach((s=>{const r=e[s];if(r>0){const e=Array.from({length:r},(()=>"grass"===s||"bushes"===s||"trees"===s?{id:`${s}-${Math.random()}`,x:Math.random()*xG,y:Math.random()*yG}:{id:`${s}-${Math.random()}`,x:Math.random()*xG,y:Math.random()*yG,type:s}));n[s]=[...t[s],...e]}else r<0&&(n[s]=t[s].slice(0,Math.max(t[s].length+r,0)))})),n})),n}))}})]})]}),(0,o.jsx)(ao,{map:f}),(0,o.jsxs)("div",{className:"current-populations",children:[(0,o.jsx)("h3",{children:"\u0422\u0435\u043a\u0443\u0449\u0438\u0435 \u041f\u043e\u043f\u0443\u043b\u044f\u0446\u0438\u0438:"}),(0,o.jsxs)("p",{children:["\u0422\u0440\u0430\u0432\u0430: ",e.grass]}),(0,o.jsxs)("p",{children:["\u041a\u0443\u0441\u0442\u044b: ",e.bushes]}),(0,o.jsxs)("p",{children:["\u0414\u0435\u0440\u0435\u0432\u044c\u044f: ",e.trees]}),(0,o.jsxs)("p",{children:["\u041a\u0440\u043e\u043b\u0438\u043a\u0438: ",e.rabbits]}),(0,o.jsxs)("p",{children:["\u0412\u043e\u043b\u043a\u0438: ",e.wolves]})]})]})};const kG=function(){return(0,o.jsxs)("div",{className:"App",children:[(0,o.jsx)("h1",{children:"\u0421\u0438\u043c\u0443\u043b\u044f\u0446\u0438\u044f \u042d\u043a\u043e\u0441\u0438\u0441\u0442\u0435\u043c\u044b"}),(0,o.jsx)(wG,{})]})};a.createRoot(document.getElementById("root")).render((0,o.jsx)(i.StrictMode,{children:(0,o.jsx)(kG,{})}))})()})();
//# sourceMappingURL=main.4de319fa.js.map